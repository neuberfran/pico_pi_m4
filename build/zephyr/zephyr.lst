
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

1fff8000 <_vector_table>:
1fff8000:	a8 0e 00 20 01 92 ff 1f 29 a2 ff 1f d5 91 ff 1f     ... ....).......
1fff8010:	d5 91 ff 1f d5 91 ff 1f d5 91 ff 1f 00 00 00 00     ................
	...
1fff802c:	b5 8e ff 1f d5 91 ff 1f 00 00 00 00 6d 8e ff 1f     ............m...
1fff803c:	19 94 ff 1f                                         ....

1fff8040 <_irq_vector_table>:
1fff8040:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff8050:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff8060:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff8070:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff8080:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff8090:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff80a0:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff80b0:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff80c0:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff80d0:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff80e0:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff80f0:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff8100:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff8110:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff8120:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff8130:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff8140:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff8150:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff8160:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff8170:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff8180:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff8190:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff81a0:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff81b0:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff81c0:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff81d0:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff81e0:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff81f0:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff8200:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff8210:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff8220:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f 31 8f ff 1f     1...1...1...1...
1fff8230:	31 8f ff 1f 31 8f ff 1f 31 8f ff 1f                 1...1...1...

Disassembly of section text:

1fff823c <__aeabi_uldivmod>:
1fff823c:	b953      	cbnz	r3, 1fff8254 <__aeabi_uldivmod+0x18>
1fff823e:	b94a      	cbnz	r2, 1fff8254 <__aeabi_uldivmod+0x18>
1fff8240:	2900      	cmp	r1, #0
1fff8242:	bf08      	it	eq
1fff8244:	2800      	cmpeq	r0, #0
1fff8246:	bf1c      	itt	ne
1fff8248:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
1fff824c:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
1fff8250:	f000 b80c 	b.w	1fff826c <__aeabi_idiv0>
1fff8254:	f1ad 0c08 	sub.w	ip, sp, #8
1fff8258:	e96d ce04 	strd	ip, lr, [sp, #-16]!
1fff825c:	f000 f808 	bl	1fff8270 <__udivmoddi4>
1fff8260:	f8dd e004 	ldr.w	lr, [sp, #4]
1fff8264:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
1fff8268:	b004      	add	sp, #16
1fff826a:	4770      	bx	lr

1fff826c <__aeabi_idiv0>:
1fff826c:	4770      	bx	lr
1fff826e:	bf00      	nop

1fff8270 <__udivmoddi4>:
1fff8270:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
1fff8274:	4686      	mov	lr, r0
1fff8276:	468c      	mov	ip, r1
1fff8278:	4608      	mov	r0, r1
1fff827a:	9e08      	ldr	r6, [sp, #32]
1fff827c:	4615      	mov	r5, r2
1fff827e:	4674      	mov	r4, lr
1fff8280:	4619      	mov	r1, r3
1fff8282:	2b00      	cmp	r3, #0
1fff8284:	f040 80c2 	bne.w	1fff840c <__udivmoddi4+0x19c>
1fff8288:	4285      	cmp	r5, r0
1fff828a:	fab2 f282 	clz	r2, r2
1fff828e:	d945      	bls.n	1fff831c <__udivmoddi4+0xac>
1fff8290:	b14a      	cbz	r2, 1fff82a6 <__udivmoddi4+0x36>
1fff8292:	f1c2 0320 	rsb	r3, r2, #32
1fff8296:	fa00 fc02 	lsl.w	ip, r0, r2
1fff829a:	fa2e f303 	lsr.w	r3, lr, r3
1fff829e:	4095      	lsls	r5, r2
1fff82a0:	ea43 0c0c 	orr.w	ip, r3, ip
1fff82a4:	4094      	lsls	r4, r2
1fff82a6:	ea4f 4e15 	mov.w	lr, r5, lsr #16
1fff82aa:	b2a8      	uxth	r0, r5
1fff82ac:	fbbc f8fe 	udiv	r8, ip, lr
1fff82b0:	0c23      	lsrs	r3, r4, #16
1fff82b2:	fb0e cc18 	mls	ip, lr, r8, ip
1fff82b6:	fb08 f900 	mul.w	r9, r8, r0
1fff82ba:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
1fff82be:	4599      	cmp	r9, r3
1fff82c0:	d928      	bls.n	1fff8314 <__udivmoddi4+0xa4>
1fff82c2:	18eb      	adds	r3, r5, r3
1fff82c4:	f108 37ff 	add.w	r7, r8, #4294967295	; 0xffffffff
1fff82c8:	d204      	bcs.n	1fff82d4 <__udivmoddi4+0x64>
1fff82ca:	4599      	cmp	r9, r3
1fff82cc:	d902      	bls.n	1fff82d4 <__udivmoddi4+0x64>
1fff82ce:	f1a8 0702 	sub.w	r7, r8, #2
1fff82d2:	442b      	add	r3, r5
1fff82d4:	eba3 0309 	sub.w	r3, r3, r9
1fff82d8:	b2a4      	uxth	r4, r4
1fff82da:	fbb3 fcfe 	udiv	ip, r3, lr
1fff82de:	fb0e 331c 	mls	r3, lr, ip, r3
1fff82e2:	fb0c f000 	mul.w	r0, ip, r0
1fff82e6:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
1fff82ea:	42a0      	cmp	r0, r4
1fff82ec:	d914      	bls.n	1fff8318 <__udivmoddi4+0xa8>
1fff82ee:	192c      	adds	r4, r5, r4
1fff82f0:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
1fff82f4:	d204      	bcs.n	1fff8300 <__udivmoddi4+0x90>
1fff82f6:	42a0      	cmp	r0, r4
1fff82f8:	d902      	bls.n	1fff8300 <__udivmoddi4+0x90>
1fff82fa:	f1ac 0302 	sub.w	r3, ip, #2
1fff82fe:	442c      	add	r4, r5
1fff8300:	1a24      	subs	r4, r4, r0
1fff8302:	ea43 4007 	orr.w	r0, r3, r7, lsl #16
1fff8306:	b11e      	cbz	r6, 1fff8310 <__udivmoddi4+0xa0>
1fff8308:	40d4      	lsrs	r4, r2
1fff830a:	2300      	movs	r3, #0
1fff830c:	6034      	str	r4, [r6, #0]
1fff830e:	6073      	str	r3, [r6, #4]
1fff8310:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
1fff8314:	4647      	mov	r7, r8
1fff8316:	e7dd      	b.n	1fff82d4 <__udivmoddi4+0x64>
1fff8318:	4663      	mov	r3, ip
1fff831a:	e7f1      	b.n	1fff8300 <__udivmoddi4+0x90>
1fff831c:	bb92      	cbnz	r2, 1fff8384 <__udivmoddi4+0x114>
1fff831e:	1b43      	subs	r3, r0, r5
1fff8320:	2101      	movs	r1, #1
1fff8322:	ea4f 4e15 	mov.w	lr, r5, lsr #16
1fff8326:	b2af      	uxth	r7, r5
1fff8328:	fbb3 fcfe 	udiv	ip, r3, lr
1fff832c:	0c20      	lsrs	r0, r4, #16
1fff832e:	fb0e 331c 	mls	r3, lr, ip, r3
1fff8332:	fb0c f807 	mul.w	r8, ip, r7
1fff8336:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
1fff833a:	4598      	cmp	r8, r3
1fff833c:	d962      	bls.n	1fff8404 <__udivmoddi4+0x194>
1fff833e:	18eb      	adds	r3, r5, r3
1fff8340:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
1fff8344:	d204      	bcs.n	1fff8350 <__udivmoddi4+0xe0>
1fff8346:	4598      	cmp	r8, r3
1fff8348:	d902      	bls.n	1fff8350 <__udivmoddi4+0xe0>
1fff834a:	f1ac 0002 	sub.w	r0, ip, #2
1fff834e:	442b      	add	r3, r5
1fff8350:	eba3 0308 	sub.w	r3, r3, r8
1fff8354:	b2a4      	uxth	r4, r4
1fff8356:	fbb3 fcfe 	udiv	ip, r3, lr
1fff835a:	fb0e 331c 	mls	r3, lr, ip, r3
1fff835e:	fb0c f707 	mul.w	r7, ip, r7
1fff8362:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
1fff8366:	42a7      	cmp	r7, r4
1fff8368:	d94e      	bls.n	1fff8408 <__udivmoddi4+0x198>
1fff836a:	192c      	adds	r4, r5, r4
1fff836c:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
1fff8370:	d204      	bcs.n	1fff837c <__udivmoddi4+0x10c>
1fff8372:	42a7      	cmp	r7, r4
1fff8374:	d902      	bls.n	1fff837c <__udivmoddi4+0x10c>
1fff8376:	f1ac 0302 	sub.w	r3, ip, #2
1fff837a:	442c      	add	r4, r5
1fff837c:	1be4      	subs	r4, r4, r7
1fff837e:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
1fff8382:	e7c0      	b.n	1fff8306 <__udivmoddi4+0x96>
1fff8384:	f1c2 0320 	rsb	r3, r2, #32
1fff8388:	fa20 f103 	lsr.w	r1, r0, r3
1fff838c:	4095      	lsls	r5, r2
1fff838e:	4090      	lsls	r0, r2
1fff8390:	fa2e f303 	lsr.w	r3, lr, r3
1fff8394:	4303      	orrs	r3, r0
1fff8396:	ea4f 4e15 	mov.w	lr, r5, lsr #16
1fff839a:	b2af      	uxth	r7, r5
1fff839c:	fbb1 fcfe 	udiv	ip, r1, lr
1fff83a0:	fb0e 101c 	mls	r0, lr, ip, r1
1fff83a4:	0c19      	lsrs	r1, r3, #16
1fff83a6:	fb0c f807 	mul.w	r8, ip, r7
1fff83aa:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
1fff83ae:	4588      	cmp	r8, r1
1fff83b0:	fa04 f402 	lsl.w	r4, r4, r2
1fff83b4:	d922      	bls.n	1fff83fc <__udivmoddi4+0x18c>
1fff83b6:	1869      	adds	r1, r5, r1
1fff83b8:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
1fff83bc:	d204      	bcs.n	1fff83c8 <__udivmoddi4+0x158>
1fff83be:	4588      	cmp	r8, r1
1fff83c0:	d902      	bls.n	1fff83c8 <__udivmoddi4+0x158>
1fff83c2:	f1ac 0002 	sub.w	r0, ip, #2
1fff83c6:	4429      	add	r1, r5
1fff83c8:	eba1 0108 	sub.w	r1, r1, r8
1fff83cc:	b29b      	uxth	r3, r3
1fff83ce:	fbb1 fcfe 	udiv	ip, r1, lr
1fff83d2:	fb0e 111c 	mls	r1, lr, ip, r1
1fff83d6:	fb0c f707 	mul.w	r7, ip, r7
1fff83da:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
1fff83de:	429f      	cmp	r7, r3
1fff83e0:	d90e      	bls.n	1fff8400 <__udivmoddi4+0x190>
1fff83e2:	18eb      	adds	r3, r5, r3
1fff83e4:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
1fff83e8:	d204      	bcs.n	1fff83f4 <__udivmoddi4+0x184>
1fff83ea:	429f      	cmp	r7, r3
1fff83ec:	d902      	bls.n	1fff83f4 <__udivmoddi4+0x184>
1fff83ee:	f1ac 0102 	sub.w	r1, ip, #2
1fff83f2:	442b      	add	r3, r5
1fff83f4:	1bdb      	subs	r3, r3, r7
1fff83f6:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
1fff83fa:	e792      	b.n	1fff8322 <__udivmoddi4+0xb2>
1fff83fc:	4660      	mov	r0, ip
1fff83fe:	e7e3      	b.n	1fff83c8 <__udivmoddi4+0x158>
1fff8400:	4661      	mov	r1, ip
1fff8402:	e7f7      	b.n	1fff83f4 <__udivmoddi4+0x184>
1fff8404:	4660      	mov	r0, ip
1fff8406:	e7a3      	b.n	1fff8350 <__udivmoddi4+0xe0>
1fff8408:	4663      	mov	r3, ip
1fff840a:	e7b7      	b.n	1fff837c <__udivmoddi4+0x10c>
1fff840c:	4283      	cmp	r3, r0
1fff840e:	d906      	bls.n	1fff841e <__udivmoddi4+0x1ae>
1fff8410:	b916      	cbnz	r6, 1fff8418 <__udivmoddi4+0x1a8>
1fff8412:	2100      	movs	r1, #0
1fff8414:	4608      	mov	r0, r1
1fff8416:	e77b      	b.n	1fff8310 <__udivmoddi4+0xa0>
1fff8418:	e9c6 e000 	strd	lr, r0, [r6]
1fff841c:	e7f9      	b.n	1fff8412 <__udivmoddi4+0x1a2>
1fff841e:	fab3 f783 	clz	r7, r3
1fff8422:	b98f      	cbnz	r7, 1fff8448 <__udivmoddi4+0x1d8>
1fff8424:	4283      	cmp	r3, r0
1fff8426:	d301      	bcc.n	1fff842c <__udivmoddi4+0x1bc>
1fff8428:	4572      	cmp	r2, lr
1fff842a:	d808      	bhi.n	1fff843e <__udivmoddi4+0x1ce>
1fff842c:	ebbe 0402 	subs.w	r4, lr, r2
1fff8430:	eb60 0303 	sbc.w	r3, r0, r3
1fff8434:	2001      	movs	r0, #1
1fff8436:	469c      	mov	ip, r3
1fff8438:	b91e      	cbnz	r6, 1fff8442 <__udivmoddi4+0x1d2>
1fff843a:	2100      	movs	r1, #0
1fff843c:	e768      	b.n	1fff8310 <__udivmoddi4+0xa0>
1fff843e:	4638      	mov	r0, r7
1fff8440:	e7fa      	b.n	1fff8438 <__udivmoddi4+0x1c8>
1fff8442:	e9c6 4c00 	strd	r4, ip, [r6]
1fff8446:	e7f8      	b.n	1fff843a <__udivmoddi4+0x1ca>
1fff8448:	f1c7 0c20 	rsb	ip, r7, #32
1fff844c:	40bb      	lsls	r3, r7
1fff844e:	fa22 f40c 	lsr.w	r4, r2, ip
1fff8452:	431c      	orrs	r4, r3
1fff8454:	fa2e f10c 	lsr.w	r1, lr, ip
1fff8458:	fa20 f30c 	lsr.w	r3, r0, ip
1fff845c:	40b8      	lsls	r0, r7
1fff845e:	4301      	orrs	r1, r0
1fff8460:	ea4f 4914 	mov.w	r9, r4, lsr #16
1fff8464:	fa0e f507 	lsl.w	r5, lr, r7
1fff8468:	fbb3 f8f9 	udiv	r8, r3, r9
1fff846c:	fa1f fe84 	uxth.w	lr, r4
1fff8470:	fb09 3018 	mls	r0, r9, r8, r3
1fff8474:	0c0b      	lsrs	r3, r1, #16
1fff8476:	fb08 fa0e 	mul.w	sl, r8, lr
1fff847a:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
1fff847e:	459a      	cmp	sl, r3
1fff8480:	fa02 f207 	lsl.w	r2, r2, r7
1fff8484:	d940      	bls.n	1fff8508 <__udivmoddi4+0x298>
1fff8486:	18e3      	adds	r3, r4, r3
1fff8488:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
1fff848c:	d204      	bcs.n	1fff8498 <__udivmoddi4+0x228>
1fff848e:	459a      	cmp	sl, r3
1fff8490:	d902      	bls.n	1fff8498 <__udivmoddi4+0x228>
1fff8492:	f1a8 0002 	sub.w	r0, r8, #2
1fff8496:	4423      	add	r3, r4
1fff8498:	eba3 030a 	sub.w	r3, r3, sl
1fff849c:	b289      	uxth	r1, r1
1fff849e:	fbb3 f8f9 	udiv	r8, r3, r9
1fff84a2:	fb09 3318 	mls	r3, r9, r8, r3
1fff84a6:	fb08 fe0e 	mul.w	lr, r8, lr
1fff84aa:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
1fff84ae:	458e      	cmp	lr, r1
1fff84b0:	d92c      	bls.n	1fff850c <__udivmoddi4+0x29c>
1fff84b2:	1861      	adds	r1, r4, r1
1fff84b4:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
1fff84b8:	d204      	bcs.n	1fff84c4 <__udivmoddi4+0x254>
1fff84ba:	458e      	cmp	lr, r1
1fff84bc:	d902      	bls.n	1fff84c4 <__udivmoddi4+0x254>
1fff84be:	f1a8 0302 	sub.w	r3, r8, #2
1fff84c2:	4421      	add	r1, r4
1fff84c4:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
1fff84c8:	fba0 9802 	umull	r9, r8, r0, r2
1fff84cc:	eba1 010e 	sub.w	r1, r1, lr
1fff84d0:	4541      	cmp	r1, r8
1fff84d2:	46ce      	mov	lr, r9
1fff84d4:	4643      	mov	r3, r8
1fff84d6:	d302      	bcc.n	1fff84de <__udivmoddi4+0x26e>
1fff84d8:	d106      	bne.n	1fff84e8 <__udivmoddi4+0x278>
1fff84da:	454d      	cmp	r5, r9
1fff84dc:	d204      	bcs.n	1fff84e8 <__udivmoddi4+0x278>
1fff84de:	ebb9 0e02 	subs.w	lr, r9, r2
1fff84e2:	eb68 0304 	sbc.w	r3, r8, r4
1fff84e6:	3801      	subs	r0, #1
1fff84e8:	2e00      	cmp	r6, #0
1fff84ea:	d0a6      	beq.n	1fff843a <__udivmoddi4+0x1ca>
1fff84ec:	ebb5 020e 	subs.w	r2, r5, lr
1fff84f0:	eb61 0103 	sbc.w	r1, r1, r3
1fff84f4:	fa01 fc0c 	lsl.w	ip, r1, ip
1fff84f8:	fa22 f307 	lsr.w	r3, r2, r7
1fff84fc:	ea4c 0303 	orr.w	r3, ip, r3
1fff8500:	40f9      	lsrs	r1, r7
1fff8502:	e9c6 3100 	strd	r3, r1, [r6]
1fff8506:	e798      	b.n	1fff843a <__udivmoddi4+0x1ca>
1fff8508:	4640      	mov	r0, r8
1fff850a:	e7c5      	b.n	1fff8498 <__udivmoddi4+0x228>
1fff850c:	4643      	mov	r3, r8
1fff850e:	e7d9      	b.n	1fff84c4 <__udivmoddi4+0x254>

1fff8510 <char_out>:
}

static int char_out(int c, void *ctx_p)
{
	(void) ctx_p;
	return _char_out(c);
1fff8510:	4b01      	ldr	r3, [pc, #4]	; (1fff8518 <char_out+0x8>)
1fff8512:	681b      	ldr	r3, [r3, #0]
1fff8514:	4718      	bx	r3
1fff8516:	bf00      	nop
1fff8518:	20000000 	.word	0x20000000

1fff851c <__printk_hook_install>:
	_char_out = fn;
1fff851c:	4b01      	ldr	r3, [pc, #4]	; (1fff8524 <__printk_hook_install+0x8>)
1fff851e:	6018      	str	r0, [r3, #0]
}
1fff8520:	4770      	bx	lr
1fff8522:	bf00      	nop
1fff8524:	20000000 	.word	0x20000000

1fff8528 <vprintk>:
}

void vprintk(const char *fmt, va_list ap)
{
1fff8528:	b507      	push	{r0, r1, r2, lr}
1fff852a:	460b      	mov	r3, r1
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
1fff852c:	2100      	movs	r1, #0
1fff852e:	4602      	mov	r2, r0
1fff8530:	9100      	str	r1, [sp, #0]
1fff8532:	4803      	ldr	r0, [pc, #12]	; (1fff8540 <vprintk+0x18>)
1fff8534:	f000 f806 	bl	1fff8544 <z_cbvprintf_impl>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
1fff8538:	b003      	add	sp, #12
1fff853a:	f85d fb04 	ldr.w	pc, [sp], #4
1fff853e:	bf00      	nop
1fff8540:	1fff8511 	.word	0x1fff8511

1fff8544 <z_cbvprintf_impl>:
	return (int)count;
}

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
1fff8544:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1fff8548:	4681      	mov	r9, r0
1fff854a:	b095      	sub	sp, #84	; 0x54
1fff854c:	468b      	mov	fp, r1
1fff854e:	4617      	mov	r7, r2
1fff8550:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
1fff8552:	2500      	movs	r5, #0
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
1fff8554:	7838      	ldrb	r0, [r7, #0]
1fff8556:	b908      	cbnz	r0, 1fff855c <z_cbvprintf_impl+0x18>
			OUTC(' ');
			--width;
		}
	}

	return count;
1fff8558:	4628      	mov	r0, r5
1fff855a:	e358      	b.n	1fff8c0e <z_cbvprintf_impl+0x6ca>
			OUTC(*fp++);
1fff855c:	1c7b      	adds	r3, r7, #1
		if (*fp != '%') {
1fff855e:	2825      	cmp	r0, #37	; 0x25
			OUTC(*fp++);
1fff8560:	9303      	str	r3, [sp, #12]
		if (*fp != '%') {
1fff8562:	d006      	beq.n	1fff8572 <z_cbvprintf_impl+0x2e>
			OUTC('%');
1fff8564:	4659      	mov	r1, fp
1fff8566:	47c8      	blx	r9
1fff8568:	2800      	cmp	r0, #0
1fff856a:	f2c0 8350 	blt.w	1fff8c0e <z_cbvprintf_impl+0x6ca>
1fff856e:	3501      	adds	r5, #1
		if (bps == NULL) {
1fff8570:	e1fb      	b.n	1fff896a <z_cbvprintf_impl+0x426>
		} state = {
1fff8572:	2218      	movs	r2, #24
1fff8574:	2100      	movs	r1, #0
1fff8576:	a80e      	add	r0, sp, #56	; 0x38
1fff8578:	f001 fe78 	bl	1fffa26c <memset>
	if (*sp == '%') {
1fff857c:	787b      	ldrb	r3, [r7, #1]
1fff857e:	2b25      	cmp	r3, #37	; 0x25
1fff8580:	d07d      	beq.n	1fff867e <z_cbvprintf_impl+0x13a>
1fff8582:	2300      	movs	r3, #0
1fff8584:	1c78      	adds	r0, r7, #1
1fff8586:	4698      	mov	r8, r3
1fff8588:	469e      	mov	lr, r3
1fff858a:	469c      	mov	ip, r3
1fff858c:	461e      	mov	r6, r3
1fff858e:	4601      	mov	r1, r0
		switch (*sp) {
1fff8590:	f810 2b01 	ldrb.w	r2, [r0], #1
1fff8594:	2a2b      	cmp	r2, #43	; 0x2b
1fff8596:	f000 80a1 	beq.w	1fff86dc <z_cbvprintf_impl+0x198>
1fff859a:	f200 8098 	bhi.w	1fff86ce <z_cbvprintf_impl+0x18a>
1fff859e:	2a20      	cmp	r2, #32
1fff85a0:	f000 809f 	beq.w	1fff86e2 <z_cbvprintf_impl+0x19e>
1fff85a4:	2a23      	cmp	r2, #35	; 0x23
1fff85a6:	f000 809f 	beq.w	1fff86e8 <z_cbvprintf_impl+0x1a4>
1fff85aa:	b12b      	cbz	r3, 1fff85b8 <z_cbvprintf_impl+0x74>
1fff85ac:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
1fff85b0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
1fff85b4:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
1fff85b8:	f1b8 0f00 	cmp.w	r8, #0
1fff85bc:	d005      	beq.n	1fff85ca <z_cbvprintf_impl+0x86>
1fff85be:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
1fff85c2:	f043 0320 	orr.w	r3, r3, #32
1fff85c6:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
1fff85ca:	f1be 0f00 	cmp.w	lr, #0
1fff85ce:	d005      	beq.n	1fff85dc <z_cbvprintf_impl+0x98>
1fff85d0:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
1fff85d4:	f043 0310 	orr.w	r3, r3, #16
1fff85d8:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
1fff85dc:	f1bc 0f00 	cmp.w	ip, #0
1fff85e0:	d005      	beq.n	1fff85ee <z_cbvprintf_impl+0xaa>
1fff85e2:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
1fff85e6:	f043 0308 	orr.w	r3, r3, #8
1fff85ea:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
1fff85ee:	b12e      	cbz	r6, 1fff85fc <z_cbvprintf_impl+0xb8>
1fff85f0:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
1fff85f4:	f043 0304 	orr.w	r3, r3, #4
1fff85f8:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	if (conv->flag_zero && conv->flag_dash) {
1fff85fc:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
1fff8600:	f003 0044 	and.w	r0, r3, #68	; 0x44
1fff8604:	2844      	cmp	r0, #68	; 0x44
1fff8606:	d103      	bne.n	1fff8610 <z_cbvprintf_impl+0xcc>
		conv->flag_zero = false;
1fff8608:	f36f 1386 	bfc	r3, #6, #1
1fff860c:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	conv->width_present = true;
1fff8610:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
	if (*sp == '*') {
1fff8614:	2a2a      	cmp	r2, #42	; 0x2a
	conv->width_present = true;
1fff8616:	f043 0380 	orr.w	r3, r3, #128	; 0x80
1fff861a:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	if (*sp == '*') {
1fff861e:	d17f      	bne.n	1fff8720 <z_cbvprintf_impl+0x1dc>
		conv->width_star = true;
1fff8620:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
1fff8624:	f042 0201 	orr.w	r2, r2, #1
		return ++sp;
1fff8628:	1c4b      	adds	r3, r1, #1
		conv->width_star = true;
1fff862a:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	conv->prec_present = (*sp == '.');
1fff862e:	781a      	ldrb	r2, [r3, #0]
1fff8630:	2a2e      	cmp	r2, #46	; 0x2e
1fff8632:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
1fff8636:	bf0c      	ite	eq
1fff8638:	2101      	moveq	r1, #1
1fff863a:	2100      	movne	r1, #0
1fff863c:	f361 0241 	bfi	r2, r1, #1, #1
1fff8640:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	if (!conv->prec_present) {
1fff8644:	d178      	bne.n	1fff8738 <z_cbvprintf_impl+0x1f4>
	if (*sp == '*') {
1fff8646:	785a      	ldrb	r2, [r3, #1]
1fff8648:	2a2a      	cmp	r2, #42	; 0x2a
1fff864a:	d06e      	beq.n	1fff872a <z_cbvprintf_impl+0x1e6>
	++sp;
1fff864c:	3301      	adds	r3, #1
	size_t val = 0;
1fff864e:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
1fff8650:	f04f 0c0a 	mov.w	ip, #10
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
1fff8654:	4619      	mov	r1, r3
1fff8656:	f811 0b01 	ldrb.w	r0, [r1], #1
1fff865a:	f1a0 0630 	sub.w	r6, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
1fff865e:	2e09      	cmp	r6, #9
1fff8660:	f240 8095 	bls.w	1fff878e <z_cbvprintf_impl+0x24a>
	conv->unsupported |= ((conv->prec_value < 0)
1fff8664:	f89d 1040 	ldrb.w	r1, [sp, #64]	; 0x40
	conv->prec_value = prec;
1fff8668:	9212      	str	r2, [sp, #72]	; 0x48
	conv->unsupported |= ((conv->prec_value < 0)
1fff866a:	f3c1 0040 	ubfx	r0, r1, #1, #1
1fff866e:	ea40 70d2 	orr.w	r0, r0, r2, lsr #31
1fff8672:	460a      	mov	r2, r1
1fff8674:	f360 0241 	bfi	r2, r0, #1, #1
1fff8678:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
	return sp;
1fff867c:	e05c      	b.n	1fff8738 <z_cbvprintf_impl+0x1f4>
		conv->specifier = *sp++;
1fff867e:	1cba      	adds	r2, r7, #2
1fff8680:	9203      	str	r2, [sp, #12]
1fff8682:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
		if (conv->width_star) {
1fff8686:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
1fff868a:	07da      	lsls	r2, r3, #31
1fff868c:	f140 812e 	bpl.w	1fff88ec <z_cbvprintf_impl+0x3a8>
			width = va_arg(ap, int);
1fff8690:	f854 8b04 	ldr.w	r8, [r4], #4
			if (width < 0) {
1fff8694:	f1b8 0f00 	cmp.w	r8, #0
1fff8698:	da07      	bge.n	1fff86aa <z_cbvprintf_impl+0x166>
				conv->flag_dash = true;
1fff869a:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
1fff869e:	f042 0204 	orr.w	r2, r2, #4
1fff86a2:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
				width = -width;
1fff86a6:	f1c8 0800 	rsb	r8, r8, #0
		if (conv->prec_star) {
1fff86aa:	075e      	lsls	r6, r3, #29
1fff86ac:	f140 8127 	bpl.w	1fff88fe <z_cbvprintf_impl+0x3ba>
			int arg = va_arg(ap, int);
1fff86b0:	f854 ab04 	ldr.w	sl, [r4], #4
			if (arg < 0) {
1fff86b4:	f1ba 0f00 	cmp.w	sl, #0
1fff86b8:	f280 8126 	bge.w	1fff8908 <z_cbvprintf_impl+0x3c4>
				conv->prec_present = false;
1fff86bc:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
1fff86c0:	f36f 0341 	bfc	r3, #1, #1
1fff86c4:	f88d 3041 	strb.w	r3, [sp, #65]	; 0x41
		int precision = -1;
1fff86c8:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
1fff86cc:	e11c      	b.n	1fff8908 <z_cbvprintf_impl+0x3c4>
		switch (*sp) {
1fff86ce:	2a2d      	cmp	r2, #45	; 0x2d
1fff86d0:	d00d      	beq.n	1fff86ee <z_cbvprintf_impl+0x1aa>
1fff86d2:	2a30      	cmp	r2, #48	; 0x30
1fff86d4:	f47f af69 	bne.w	1fff85aa <z_cbvprintf_impl+0x66>
1fff86d8:	2301      	movs	r3, #1
	} while (loop);
1fff86da:	e758      	b.n	1fff858e <z_cbvprintf_impl+0x4a>
		switch (*sp) {
1fff86dc:	f04f 0c01 	mov.w	ip, #1
1fff86e0:	e755      	b.n	1fff858e <z_cbvprintf_impl+0x4a>
1fff86e2:	f04f 0e01 	mov.w	lr, #1
1fff86e6:	e752      	b.n	1fff858e <z_cbvprintf_impl+0x4a>
1fff86e8:	f04f 0801 	mov.w	r8, #1
1fff86ec:	e74f      	b.n	1fff858e <z_cbvprintf_impl+0x4a>
1fff86ee:	2601      	movs	r6, #1
1fff86f0:	e74d      	b.n	1fff858e <z_cbvprintf_impl+0x4a>
		val = 10U * val + *sp++ - '0';
1fff86f2:	fb0e 6202 	mla	r2, lr, r2, r6
1fff86f6:	3a30      	subs	r2, #48	; 0x30
1fff86f8:	4603      	mov	r3, r0
1fff86fa:	4618      	mov	r0, r3
1fff86fc:	f810 6b01 	ldrb.w	r6, [r0], #1
1fff8700:	f1a6 0c30 	sub.w	ip, r6, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
1fff8704:	f1bc 0f09 	cmp.w	ip, #9
1fff8708:	d9f3      	bls.n	1fff86f2 <z_cbvprintf_impl+0x1ae>
	if (sp != wp) {
1fff870a:	4299      	cmp	r1, r3
1fff870c:	d08f      	beq.n	1fff862e <z_cbvprintf_impl+0xea>
		conv->unsupported |= ((conv->width_value < 0)
1fff870e:	f89d 1040 	ldrb.w	r1, [sp, #64]	; 0x40
		conv->width_value = width;
1fff8712:	9211      	str	r2, [sp, #68]	; 0x44
				      || (width != (size_t)conv->width_value));
1fff8714:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
1fff8716:	f362 0141 	bfi	r1, r2, #1, #1
1fff871a:	f88d 1040 	strb.w	r1, [sp, #64]	; 0x40
1fff871e:	e786      	b.n	1fff862e <z_cbvprintf_impl+0xea>
1fff8720:	460b      	mov	r3, r1
	size_t val = 0;
1fff8722:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
1fff8724:	f04f 0e0a 	mov.w	lr, #10
1fff8728:	e7e7      	b.n	1fff86fa <z_cbvprintf_impl+0x1b6>
		conv->prec_star = true;
1fff872a:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
1fff872e:	f042 0204 	orr.w	r2, r2, #4
1fff8732:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
		return ++sp;
1fff8736:	3302      	adds	r3, #2
	switch (*sp) {
1fff8738:	781a      	ldrb	r2, [r3, #0]
1fff873a:	2a6c      	cmp	r2, #108	; 0x6c
1fff873c:	d047      	beq.n	1fff87ce <z_cbvprintf_impl+0x28a>
1fff873e:	d82b      	bhi.n	1fff8798 <z_cbvprintf_impl+0x254>
1fff8740:	2a68      	cmp	r2, #104	; 0x68
1fff8742:	d031      	beq.n	1fff87a8 <z_cbvprintf_impl+0x264>
1fff8744:	2a6a      	cmp	r2, #106	; 0x6a
1fff8746:	d04b      	beq.n	1fff87e0 <z_cbvprintf_impl+0x29c>
1fff8748:	2a4c      	cmp	r2, #76	; 0x4c
1fff874a:	d051      	beq.n	1fff87f0 <z_cbvprintf_impl+0x2ac>
	conv->specifier = *sp++;
1fff874c:	461a      	mov	r2, r3
1fff874e:	f812 3b01 	ldrb.w	r3, [r2], #1
1fff8752:	9203      	str	r2, [sp, #12]
	switch (conv->specifier) {
1fff8754:	2b78      	cmp	r3, #120	; 0x78
		if (conv->length_mod == LENGTH_UPPER_L) {
1fff8756:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
	conv->specifier = *sp++;
1fff875a:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
	switch (conv->specifier) {
1fff875e:	f200 80be 	bhi.w	1fff88de <z_cbvprintf_impl+0x39a>
1fff8762:	2b6d      	cmp	r3, #109	; 0x6d
1fff8764:	d851      	bhi.n	1fff880a <z_cbvprintf_impl+0x2c6>
1fff8766:	2b69      	cmp	r3, #105	; 0x69
1fff8768:	f200 80b9 	bhi.w	1fff88de <z_cbvprintf_impl+0x39a>
1fff876c:	2b57      	cmp	r3, #87	; 0x57
1fff876e:	d867      	bhi.n	1fff8840 <z_cbvprintf_impl+0x2fc>
1fff8770:	2b41      	cmp	r3, #65	; 0x41
1fff8772:	d003      	beq.n	1fff877c <z_cbvprintf_impl+0x238>
1fff8774:	3b45      	subs	r3, #69	; 0x45
1fff8776:	2b02      	cmp	r3, #2
1fff8778:	f200 80b1 	bhi.w	1fff88de <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_FP;
1fff877c:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
1fff8780:	2204      	movs	r2, #4
1fff8782:	f362 0302 	bfi	r3, r2, #0, #3
1fff8786:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
			unsupported = true;
1fff878a:	2301      	movs	r3, #1
			break;
1fff878c:	e073      	b.n	1fff8876 <z_cbvprintf_impl+0x332>
		val = 10U * val + *sp++ - '0';
1fff878e:	fb0c 0202 	mla	r2, ip, r2, r0
1fff8792:	3a30      	subs	r2, #48	; 0x30
1fff8794:	460b      	mov	r3, r1
1fff8796:	e75d      	b.n	1fff8654 <z_cbvprintf_impl+0x110>
	switch (*sp) {
1fff8798:	2a74      	cmp	r2, #116	; 0x74
1fff879a:	d025      	beq.n	1fff87e8 <z_cbvprintf_impl+0x2a4>
1fff879c:	2a7a      	cmp	r2, #122	; 0x7a
1fff879e:	d1d5      	bne.n	1fff874c <z_cbvprintf_impl+0x208>
		conv->length_mod = LENGTH_Z;
1fff87a0:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
1fff87a4:	2106      	movs	r1, #6
1fff87a6:	e00c      	b.n	1fff87c2 <z_cbvprintf_impl+0x27e>
		if (*++sp == 'h') {
1fff87a8:	785a      	ldrb	r2, [r3, #1]
1fff87aa:	2a68      	cmp	r2, #104	; 0x68
1fff87ac:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
1fff87b0:	d106      	bne.n	1fff87c0 <z_cbvprintf_impl+0x27c>
			conv->length_mod = LENGTH_HH;
1fff87b2:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
1fff87b4:	f361 02c6 	bfi	r2, r1, #3, #4
1fff87b8:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
			++sp;
1fff87bc:	3302      	adds	r3, #2
1fff87be:	e7c5      	b.n	1fff874c <z_cbvprintf_impl+0x208>
			conv->length_mod = LENGTH_H;
1fff87c0:	2102      	movs	r1, #2
1fff87c2:	f361 02c6 	bfi	r2, r1, #3, #4
1fff87c6:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
		if (*++sp == 'h') {
1fff87ca:	3301      	adds	r3, #1
1fff87cc:	e7be      	b.n	1fff874c <z_cbvprintf_impl+0x208>
		if (*++sp == 'l') {
1fff87ce:	785a      	ldrb	r2, [r3, #1]
1fff87d0:	2a6c      	cmp	r2, #108	; 0x6c
1fff87d2:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
1fff87d6:	d101      	bne.n	1fff87dc <z_cbvprintf_impl+0x298>
			conv->length_mod = LENGTH_LL;
1fff87d8:	2104      	movs	r1, #4
1fff87da:	e7eb      	b.n	1fff87b4 <z_cbvprintf_impl+0x270>
			conv->length_mod = LENGTH_L;
1fff87dc:	2103      	movs	r1, #3
1fff87de:	e7f0      	b.n	1fff87c2 <z_cbvprintf_impl+0x27e>
		conv->length_mod = LENGTH_J;
1fff87e0:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
1fff87e4:	2105      	movs	r1, #5
1fff87e6:	e7ec      	b.n	1fff87c2 <z_cbvprintf_impl+0x27e>
		conv->length_mod = LENGTH_T;
1fff87e8:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
1fff87ec:	2107      	movs	r1, #7
1fff87ee:	e7e8      	b.n	1fff87c2 <z_cbvprintf_impl+0x27e>
		conv->unsupported = true;
1fff87f0:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
1fff87f4:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
1fff87f8:	f022 0202 	bic.w	r2, r2, #2
1fff87fc:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
1fff8800:	f042 0202 	orr.w	r2, r2, #2
1fff8804:	f8ad 2040 	strh.w	r2, [sp, #64]	; 0x40
		break;
1fff8808:	e7df      	b.n	1fff87ca <z_cbvprintf_impl+0x286>
	switch (conv->specifier) {
1fff880a:	3b6e      	subs	r3, #110	; 0x6e
1fff880c:	b2d9      	uxtb	r1, r3
1fff880e:	2301      	movs	r3, #1
1fff8810:	408b      	lsls	r3, r1
1fff8812:	f240 4182 	movw	r1, #1154	; 0x482
1fff8816:	420b      	tst	r3, r1
1fff8818:	d137      	bne.n	1fff888a <z_cbvprintf_impl+0x346>
1fff881a:	f013 0f24 	tst.w	r3, #36	; 0x24
1fff881e:	d151      	bne.n	1fff88c4 <z_cbvprintf_impl+0x380>
1fff8820:	07d8      	lsls	r0, r3, #31
1fff8822:	d55c      	bpl.n	1fff88de <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_PTR;
1fff8824:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
1fff8828:	2103      	movs	r1, #3
1fff882a:	f361 0302 	bfi	r3, r1, #0, #3
1fff882e:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
1fff8832:	f002 0378 	and.w	r3, r2, #120	; 0x78
1fff8836:	f1a3 0140 	sub.w	r1, r3, #64	; 0x40
1fff883a:	424b      	negs	r3, r1
1fff883c:	414b      	adcs	r3, r1
1fff883e:	e01a      	b.n	1fff8876 <z_cbvprintf_impl+0x332>
	switch (conv->specifier) {
1fff8840:	f1a3 0158 	sub.w	r1, r3, #88	; 0x58
1fff8844:	b2c9      	uxtb	r1, r1
1fff8846:	2001      	movs	r0, #1
1fff8848:	fa00 f101 	lsl.w	r1, r0, r1
1fff884c:	f411 4f62 	tst.w	r1, #57856	; 0xe200
1fff8850:	d194      	bne.n	1fff877c <z_cbvprintf_impl+0x238>
1fff8852:	f640 0601 	movw	r6, #2049	; 0x801
1fff8856:	4231      	tst	r1, r6
1fff8858:	d11d      	bne.n	1fff8896 <z_cbvprintf_impl+0x352>
1fff885a:	f411 3f04 	tst.w	r1, #135168	; 0x21000
1fff885e:	d03e      	beq.n	1fff88de <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_SINT;
1fff8860:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
1fff8864:	f360 0302 	bfi	r3, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
1fff8868:	f002 0278 	and.w	r2, r2, #120	; 0x78
1fff886c:	2a40      	cmp	r2, #64	; 0x40
		conv->specifier_cat = SPECIFIER_SINT;
1fff886e:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
1fff8872:	d034      	beq.n	1fff88de <z_cbvprintf_impl+0x39a>
	bool unsupported = false;
1fff8874:	2300      	movs	r3, #0
	conv->unsupported |= unsupported;
1fff8876:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
1fff887a:	f3c2 0140 	ubfx	r1, r2, #1, #1
1fff887e:	430b      	orrs	r3, r1
1fff8880:	f363 0241 	bfi	r2, r3, #1, #1
1fff8884:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
	return sp;
1fff8888:	e6fd      	b.n	1fff8686 <z_cbvprintf_impl+0x142>
		conv->specifier_cat = SPECIFIER_UINT;
1fff888a:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
1fff888e:	2102      	movs	r1, #2
1fff8890:	f361 0302 	bfi	r3, r1, #0, #3
1fff8894:	e7e8      	b.n	1fff8868 <z_cbvprintf_impl+0x324>
1fff8896:	f89d 1042 	ldrb.w	r1, [sp, #66]	; 0x42
1fff889a:	2002      	movs	r0, #2
		if (conv->length_mod == LENGTH_UPPER_L) {
1fff889c:	f002 0278 	and.w	r2, r2, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
1fff88a0:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
1fff88a4:	2a40      	cmp	r2, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
1fff88a6:	f88d 1042 	strb.w	r1, [sp, #66]	; 0x42
			conv->invalid = true;
1fff88aa:	bf02      	ittt	eq
1fff88ac:	f89d 1040 	ldrbeq.w	r1, [sp, #64]	; 0x40
1fff88b0:	f041 0101 	orreq.w	r1, r1, #1
1fff88b4:	f88d 1040 	strbeq.w	r1, [sp, #64]	; 0x40
		if (conv->specifier == 'c') {
1fff88b8:	2b63      	cmp	r3, #99	; 0x63
1fff88ba:	d1db      	bne.n	1fff8874 <z_cbvprintf_impl+0x330>
			unsupported = (conv->length_mod != LENGTH_NONE);
1fff88bc:	1e13      	subs	r3, r2, #0
1fff88be:	bf18      	it	ne
1fff88c0:	2301      	movne	r3, #1
1fff88c2:	e7d8      	b.n	1fff8876 <z_cbvprintf_impl+0x332>
		conv->specifier_cat = SPECIFIER_PTR;
1fff88c4:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
1fff88c8:	2103      	movs	r1, #3
1fff88ca:	f361 0302 	bfi	r3, r1, #0, #3
		if (conv->length_mod != LENGTH_NONE) {
1fff88ce:	f012 0f78 	tst.w	r2, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
1fff88d2:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod != LENGTH_NONE) {
1fff88d6:	bf14      	ite	ne
1fff88d8:	2301      	movne	r3, #1
1fff88da:	2300      	moveq	r3, #0
1fff88dc:	e7cb      	b.n	1fff8876 <z_cbvprintf_impl+0x332>
		conv->invalid = true;
1fff88de:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
1fff88e2:	f043 0301 	orr.w	r3, r3, #1
1fff88e6:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
		break;
1fff88ea:	e7c3      	b.n	1fff8874 <z_cbvprintf_impl+0x330>
		} else if (conv->width_present) {
1fff88ec:	f99d 2040 	ldrsb.w	r2, [sp, #64]	; 0x40
1fff88f0:	2a00      	cmp	r2, #0
			width = conv->width_value;
1fff88f2:	bfb4      	ite	lt
1fff88f4:	f8dd 8044 	ldrlt.w	r8, [sp, #68]	; 0x44
		int width = -1;
1fff88f8:	f04f 38ff 	movge.w	r8, #4294967295	; 0xffffffff
1fff88fc:	e6d5      	b.n	1fff86aa <z_cbvprintf_impl+0x166>
		} else if (conv->prec_present) {
1fff88fe:	0798      	lsls	r0, r3, #30
1fff8900:	f57f aee2 	bpl.w	1fff86c8 <z_cbvprintf_impl+0x184>
			precision = conv->prec_value;
1fff8904:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
			= (enum length_mod_enum)conv->length_mod;
1fff8908:	f89d 1041 	ldrb.w	r1, [sp, #65]	; 0x41
		conv->pad0_value = 0;
1fff890c:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
1fff890e:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
			= (enum specifier_cat_enum)conv->specifier_cat;
1fff8912:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
		enum specifier_cat_enum specifier_cat
1fff8916:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
1fff891a:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
1fff891c:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
1fff8920:	d133      	bne.n	1fff898a <z_cbvprintf_impl+0x446>
			switch (length_mod) {
1fff8922:	1ecb      	subs	r3, r1, #3
1fff8924:	2b04      	cmp	r3, #4
1fff8926:	d804      	bhi.n	1fff8932 <z_cbvprintf_impl+0x3ee>
1fff8928:	e8df f003 	tbb	[pc, r3]
1fff892c:	21464621 	.word	0x21464621
1fff8930:	21          	.byte	0x21
1fff8931:	00          	.byte	0x00
				value->sint = va_arg(ap, int);
1fff8932:	6823      	ldr	r3, [r4, #0]
			if (length_mod == LENGTH_HH) {
1fff8934:	2901      	cmp	r1, #1
				value->sint = va_arg(ap, int);
1fff8936:	ea4f 72e3 	mov.w	r2, r3, asr #31
1fff893a:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
			if (length_mod == LENGTH_HH) {
1fff893e:	d11c      	bne.n	1fff897a <z_cbvprintf_impl+0x436>
				value->sint = (signed char)value->sint;
1fff8940:	f99d 3038 	ldrsb.w	r3, [sp, #56]	; 0x38
1fff8944:	17da      	asrs	r2, r3, #31
1fff8946:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
				value->sint = va_arg(ap, int);
1fff894a:	3404      	adds	r4, #4
		if (conv->invalid || conv->unsupported) {
1fff894c:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
1fff8950:	f013 0603 	ands.w	r6, r3, #3
1fff8954:	d050      	beq.n	1fff89f8 <z_cbvprintf_impl+0x4b4>
			OUTS(sp, fp);
1fff8956:	9b03      	ldr	r3, [sp, #12]
1fff8958:	463a      	mov	r2, r7
1fff895a:	4659      	mov	r1, fp
1fff895c:	4648      	mov	r0, r9
1fff895e:	f001 fc41 	bl	1fffa1e4 <outs>
1fff8962:	2800      	cmp	r0, #0
1fff8964:	f2c0 8153 	blt.w	1fff8c0e <z_cbvprintf_impl+0x6ca>
1fff8968:	4405      	add	r5, r0
			continue;
1fff896a:	9f03      	ldr	r7, [sp, #12]
1fff896c:	e5f2      	b.n	1fff8554 <z_cbvprintf_impl+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
1fff896e:	f854 3b04 	ldr.w	r3, [r4], #4
1fff8972:	17da      	asrs	r2, r3, #31
				value->uint = (unsigned char)value->uint;
1fff8974:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
1fff8978:	e7e8      	b.n	1fff894c <z_cbvprintf_impl+0x408>
			} else if (length_mod == LENGTH_H) {
1fff897a:	2902      	cmp	r1, #2
1fff897c:	d1e5      	bne.n	1fff894a <z_cbvprintf_impl+0x406>
				value->sint = (short)value->sint;
1fff897e:	b21a      	sxth	r2, r3
1fff8980:	f343 33c0 	sbfx	r3, r3, #15, #1
1fff8984:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
1fff8988:	e7df      	b.n	1fff894a <z_cbvprintf_impl+0x406>
		} else if (specifier_cat == SPECIFIER_UINT) {
1fff898a:	2b02      	cmp	r3, #2
1fff898c:	d124      	bne.n	1fff89d8 <z_cbvprintf_impl+0x494>
			switch (length_mod) {
1fff898e:	1ecb      	subs	r3, r1, #3
1fff8990:	2b04      	cmp	r3, #4
1fff8992:	d804      	bhi.n	1fff899e <z_cbvprintf_impl+0x45a>
1fff8994:	e8df f003 	tbb	[pc, r3]
1fff8998:	18101018 	.word	0x18101018
1fff899c:	18          	.byte	0x18
1fff899d:	00          	.byte	0x00
			if (length_mod == LENGTH_HH) {
1fff899e:	2901      	cmp	r1, #1
				value->uint = va_arg(ap, unsigned int);
1fff89a0:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
1fff89a4:	f04f 0200 	mov.w	r2, #0
1fff89a8:	d014      	beq.n	1fff89d4 <z_cbvprintf_impl+0x490>
			} else if (length_mod == LENGTH_H) {
1fff89aa:	2902      	cmp	r1, #2
				value->uint = va_arg(ap, unsigned int);
1fff89ac:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
			} else if (length_mod == LENGTH_H) {
1fff89b0:	d1cc      	bne.n	1fff894c <z_cbvprintf_impl+0x408>
				value->uint = (unsigned short)value->uint;
1fff89b2:	b29b      	uxth	r3, r3
			value->ptr = va_arg(ap, void *);
1fff89b4:	930e      	str	r3, [sp, #56]	; 0x38
1fff89b6:	e7c9      	b.n	1fff894c <z_cbvprintf_impl+0x408>
					(uint_value_type)va_arg(ap,
1fff89b8:	3407      	adds	r4, #7
1fff89ba:	f024 0407 	bic.w	r4, r4, #7
				value->uint =
1fff89be:	e8f4 2302 	ldrd	r2, r3, [r4], #8
1fff89c2:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
			if (length_mod == LENGTH_HH) {
1fff89c6:	e7c1      	b.n	1fff894c <z_cbvprintf_impl+0x408>
					(uint_value_type)va_arg(ap, size_t);
1fff89c8:	f854 3b04 	ldr.w	r3, [r4], #4
1fff89cc:	930e      	str	r3, [sp, #56]	; 0x38
1fff89ce:	2300      	movs	r3, #0
1fff89d0:	930f      	str	r3, [sp, #60]	; 0x3c
			} else if (length_mod == LENGTH_H) {
1fff89d2:	e7bb      	b.n	1fff894c <z_cbvprintf_impl+0x408>
				value->uint = (unsigned char)value->uint;
1fff89d4:	b2db      	uxtb	r3, r3
1fff89d6:	e7cd      	b.n	1fff8974 <z_cbvprintf_impl+0x430>
		} else if (specifier_cat == SPECIFIER_FP) {
1fff89d8:	2b04      	cmp	r3, #4
1fff89da:	d108      	bne.n	1fff89ee <z_cbvprintf_impl+0x4aa>
					(sint_value_type)va_arg(ap, long long);
1fff89dc:	3407      	adds	r4, #7
				value->ldbl = va_arg(ap, long double);
1fff89de:	f024 0407 	bic.w	r4, r4, #7
1fff89e2:	e9d4 2300 	ldrd	r2, r3, [r4]
1fff89e6:	3408      	adds	r4, #8
1fff89e8:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
1fff89ec:	e7ae      	b.n	1fff894c <z_cbvprintf_impl+0x408>
		} else if (specifier_cat == SPECIFIER_PTR) {
1fff89ee:	2b03      	cmp	r3, #3
1fff89f0:	d1ac      	bne.n	1fff894c <z_cbvprintf_impl+0x408>
			value->ptr = va_arg(ap, void *);
1fff89f2:	f854 3b04 	ldr.w	r3, [r4], #4
1fff89f6:	e7dd      	b.n	1fff89b4 <z_cbvprintf_impl+0x470>
		switch (conv->specifier) {
1fff89f8:	f89d 0043 	ldrb.w	r0, [sp, #67]	; 0x43
1fff89fc:	2878      	cmp	r0, #120	; 0x78
1fff89fe:	d8b4      	bhi.n	1fff896a <z_cbvprintf_impl+0x426>
1fff8a00:	2862      	cmp	r0, #98	; 0x62
1fff8a02:	d81c      	bhi.n	1fff8a3e <z_cbvprintf_impl+0x4fa>
1fff8a04:	2825      	cmp	r0, #37	; 0x25
1fff8a06:	f43f adad 	beq.w	1fff8564 <z_cbvprintf_impl+0x20>
1fff8a0a:	2858      	cmp	r0, #88	; 0x58
1fff8a0c:	d1ad      	bne.n	1fff896a <z_cbvprintf_impl+0x426>
			bps = encode_uint(value->uint, conv, buf, bpe);
1fff8a0e:	f10d 0336 	add.w	r3, sp, #54	; 0x36
1fff8a12:	9300      	str	r3, [sp, #0]
1fff8a14:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
1fff8a18:	ab08      	add	r3, sp, #32
1fff8a1a:	aa10      	add	r2, sp, #64	; 0x40
1fff8a1c:	f001 fb9c 	bl	1fffa158 <encode_uint>
			if (precision >= 0) {
1fff8a20:	f1ba 0f00 	cmp.w	sl, #0
			bps = encode_uint(value->uint, conv, buf, bpe);
1fff8a24:	4607      	mov	r7, r0
			if (precision >= 0) {
1fff8a26:	f280 809a 	bge.w	1fff8b5e <z_cbvprintf_impl+0x61a>
		if (bps == NULL) {
1fff8a2a:	2f00      	cmp	r7, #0
1fff8a2c:	d09d      	beq.n	1fff896a <z_cbvprintf_impl+0x426>
		size_t nj_len = (bpe - bps);
1fff8a2e:	f10d 0336 	add.w	r3, sp, #54	; 0x36
1fff8a32:	1bd8      	subs	r0, r3, r7
		if (sign != 0) {
1fff8a34:	2e00      	cmp	r6, #0
1fff8a36:	f000 80c1 	beq.w	1fff8bbc <z_cbvprintf_impl+0x678>
			nj_len += 1U;
1fff8a3a:	3001      	adds	r0, #1
1fff8a3c:	e0be      	b.n	1fff8bbc <z_cbvprintf_impl+0x678>
		switch (conv->specifier) {
1fff8a3e:	3863      	subs	r0, #99	; 0x63
1fff8a40:	2815      	cmp	r0, #21
1fff8a42:	d892      	bhi.n	1fff896a <z_cbvprintf_impl+0x426>
1fff8a44:	a201      	add	r2, pc, #4	; (adr r2, 1fff8a4c <z_cbvprintf_impl+0x508>)
1fff8a46:	f852 f020 	ldr.w	pc, [r2, r0, lsl #2]
1fff8a4a:	bf00      	nop
1fff8a4c:	1fff8b21 	.word	0x1fff8b21
1fff8a50:	1fff8b33 	.word	0x1fff8b33
1fff8a54:	1fff896b 	.word	0x1fff896b
1fff8a58:	1fff896b 	.word	0x1fff896b
1fff8a5c:	1fff896b 	.word	0x1fff896b
1fff8a60:	1fff896b 	.word	0x1fff896b
1fff8a64:	1fff8b33 	.word	0x1fff8b33
1fff8a68:	1fff896b 	.word	0x1fff896b
1fff8a6c:	1fff896b 	.word	0x1fff896b
1fff8a70:	1fff896b 	.word	0x1fff896b
1fff8a74:	1fff896b 	.word	0x1fff896b
1fff8a78:	1fff8bc1 	.word	0x1fff8bc1
1fff8a7c:	1fff8b59 	.word	0x1fff8b59
1fff8a80:	1fff8b7f 	.word	0x1fff8b7f
1fff8a84:	1fff896b 	.word	0x1fff896b
1fff8a88:	1fff896b 	.word	0x1fff896b
1fff8a8c:	1fff8aa5 	.word	0x1fff8aa5
1fff8a90:	1fff896b 	.word	0x1fff896b
1fff8a94:	1fff8b59 	.word	0x1fff8b59
1fff8a98:	1fff896b 	.word	0x1fff896b
1fff8a9c:	1fff896b 	.word	0x1fff896b
1fff8aa0:	1fff8b59 	.word	0x1fff8b59
			if (precision >= 0) {
1fff8aa4:	f1ba 0f00 	cmp.w	sl, #0
			bps = (const char *)value->ptr;
1fff8aa8:	9f0e      	ldr	r7, [sp, #56]	; 0x38
			if (precision >= 0) {
1fff8aaa:	db35      	blt.n	1fff8b18 <z_cbvprintf_impl+0x5d4>
				len = strnlen(bps, precision);
1fff8aac:	4651      	mov	r1, sl
1fff8aae:	4638      	mov	r0, r7
1fff8ab0:	f001 fbc8 	bl	1fffa244 <strnlen>
			bpe = bps + len;
1fff8ab4:	eb07 0a00 	add.w	sl, r7, r0
		if (bps == NULL) {
1fff8ab8:	2f00      	cmp	r7, #0
1fff8aba:	f43f af56 	beq.w	1fff896a <z_cbvprintf_impl+0x426>
		char sign = 0;
1fff8abe:	2600      	movs	r6, #0
		if (conv->altform_0c) {
1fff8ac0:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
1fff8ac4:	f013 0210 	ands.w	r2, r3, #16
1fff8ac8:	9205      	str	r2, [sp, #20]
1fff8aca:	f000 8093 	beq.w	1fff8bf4 <z_cbvprintf_impl+0x6b0>
			nj_len += 2U;
1fff8ace:	3002      	adds	r0, #2
		if (conv->pad_fp) {
1fff8ad0:	065b      	lsls	r3, r3, #25
		nj_len += conv->pad0_value;
1fff8ad2:	9a11      	ldr	r2, [sp, #68]	; 0x44
			nj_len += conv->pad0_pre_exp;
1fff8ad4:	bf48      	it	mi
1fff8ad6:	9b12      	ldrmi	r3, [sp, #72]	; 0x48
		nj_len += conv->pad0_value;
1fff8ad8:	9204      	str	r2, [sp, #16]
1fff8ada:	4410      	add	r0, r2
			nj_len += conv->pad0_pre_exp;
1fff8adc:	bf48      	it	mi
1fff8ade:	18c0      	addmi	r0, r0, r3
		if (width > 0) {
1fff8ae0:	f1b8 0f00 	cmp.w	r8, #0
1fff8ae4:	f340 80a0 	ble.w	1fff8c28 <z_cbvprintf_impl+0x6e4>
			if (!conv->flag_dash) {
1fff8ae8:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
			width -= (int)nj_len;
1fff8aec:	eba8 0800 	sub.w	r8, r8, r0
			if (!conv->flag_dash) {
1fff8af0:	f3c2 0380 	ubfx	r3, r2, #2, #1
1fff8af4:	0750      	lsls	r0, r2, #29
1fff8af6:	9306      	str	r3, [sp, #24]
1fff8af8:	f100 8096 	bmi.w	1fff8c28 <z_cbvprintf_impl+0x6e4>
				if (conv->flag_zero) {
1fff8afc:	0651      	lsls	r1, r2, #25
1fff8afe:	f140 8089 	bpl.w	1fff8c14 <z_cbvprintf_impl+0x6d0>
					if (sign != 0) {
1fff8b02:	b13e      	cbz	r6, 1fff8b14 <z_cbvprintf_impl+0x5d0>
						OUTC(sign);
1fff8b04:	4659      	mov	r1, fp
1fff8b06:	4630      	mov	r0, r6
1fff8b08:	47c8      	blx	r9
1fff8b0a:	2800      	cmp	r0, #0
1fff8b0c:	db7f      	blt.n	1fff8c0e <z_cbvprintf_impl+0x6ca>
1fff8b0e:	9b06      	ldr	r3, [sp, #24]
1fff8b10:	3501      	adds	r5, #1
1fff8b12:	461e      	mov	r6, r3
					pad = '0';
1fff8b14:	2230      	movs	r2, #48	; 0x30
1fff8b16:	e07e      	b.n	1fff8c16 <z_cbvprintf_impl+0x6d2>
				len = strlen(bps);
1fff8b18:	4638      	mov	r0, r7
1fff8b1a:	f001 fb8c 	bl	1fffa236 <strlen>
1fff8b1e:	e7c9      	b.n	1fff8ab4 <z_cbvprintf_impl+0x570>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
1fff8b20:	9b0e      	ldr	r3, [sp, #56]	; 0x38
1fff8b22:	f88d 3020 	strb.w	r3, [sp, #32]
		char sign = 0;
1fff8b26:	2600      	movs	r6, #0
			bps = buf;
1fff8b28:	af08      	add	r7, sp, #32
			bpe = buf + 1;
1fff8b2a:	f10d 0a21 	add.w	sl, sp, #33	; 0x21
		size_t nj_len = (bpe - bps);
1fff8b2e:	2001      	movs	r0, #1
1fff8b30:	e7c6      	b.n	1fff8ac0 <z_cbvprintf_impl+0x57c>
			if (conv->flag_plus) {
1fff8b32:	0719      	lsls	r1, r3, #28
			} else if (conv->flag_space) {
1fff8b34:	bf5c      	itt	pl
1fff8b36:	f3c3 1300 	ubfxpl	r3, r3, #4, #1
1fff8b3a:	015e      	lslpl	r6, r3, #5
			sint = value->sint;
1fff8b3c:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
				sign = '+';
1fff8b40:	bf48      	it	mi
1fff8b42:	262b      	movmi	r6, #43	; 0x2b
			if (sint < 0) {
1fff8b44:	2b00      	cmp	r3, #0
1fff8b46:	f6bf af62 	bge.w	1fff8a0e <z_cbvprintf_impl+0x4ca>
				value->uint = (uint_value_type)-sint;
1fff8b4a:	4252      	negs	r2, r2
1fff8b4c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
1fff8b50:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
				sign = '-';
1fff8b54:	262d      	movs	r6, #45	; 0x2d
1fff8b56:	e75a      	b.n	1fff8a0e <z_cbvprintf_impl+0x4ca>
		switch (conv->specifier) {
1fff8b58:	2600      	movs	r6, #0
1fff8b5a:	e758      	b.n	1fff8a0e <z_cbvprintf_impl+0x4ca>
		char sign = 0;
1fff8b5c:	2600      	movs	r6, #0
				conv->flag_zero = false;
1fff8b5e:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
				size_t len = bpe - bps;
1fff8b62:	f10d 0336 	add.w	r3, sp, #54	; 0x36
1fff8b66:	1bdb      	subs	r3, r3, r7
				conv->flag_zero = false;
1fff8b68:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
1fff8b6c:	459a      	cmp	sl, r3
				conv->flag_zero = false;
1fff8b6e:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
				if (len < (size_t)precision) {
1fff8b72:	f67f af5a 	bls.w	1fff8a2a <z_cbvprintf_impl+0x4e6>
					conv->pad0_value = precision - (int)len;
1fff8b76:	ebaa 0303 	sub.w	r3, sl, r3
1fff8b7a:	9311      	str	r3, [sp, #68]	; 0x44
1fff8b7c:	e755      	b.n	1fff8a2a <z_cbvprintf_impl+0x4e6>
			if (value->ptr != NULL) {
1fff8b7e:	980e      	ldr	r0, [sp, #56]	; 0x38
1fff8b80:	b390      	cbz	r0, 1fff8be8 <z_cbvprintf_impl+0x6a4>
				bps = encode_uint((uintptr_t)value->ptr, conv,
1fff8b82:	f10d 0336 	add.w	r3, sp, #54	; 0x36
1fff8b86:	9300      	str	r3, [sp, #0]
1fff8b88:	aa10      	add	r2, sp, #64	; 0x40
1fff8b8a:	ab08      	add	r3, sp, #32
1fff8b8c:	2100      	movs	r1, #0
1fff8b8e:	f001 fae3 	bl	1fffa158 <encode_uint>
				conv->altform_0c = true;
1fff8b92:	f8bd 3042 	ldrh.w	r3, [sp, #66]	; 0x42
1fff8b96:	f003 03ef 	and.w	r3, r3, #239	; 0xef
1fff8b9a:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
1fff8b9e:	f043 0310 	orr.w	r3, r3, #16
			if (precision >= 0) {
1fff8ba2:	f1ba 0f00 	cmp.w	sl, #0
				bps = encode_uint((uintptr_t)value->ptr, conv,
1fff8ba6:	4607      	mov	r7, r0
				conv->altform_0c = true;
1fff8ba8:	f8ad 3042 	strh.w	r3, [sp, #66]	; 0x42
			if (precision >= 0) {
1fff8bac:	dad6      	bge.n	1fff8b5c <z_cbvprintf_impl+0x618>
		if (bps == NULL) {
1fff8bae:	2800      	cmp	r0, #0
1fff8bb0:	f43f aedb 	beq.w	1fff896a <z_cbvprintf_impl+0x426>
		size_t nj_len = (bpe - bps);
1fff8bb4:	f10d 0336 	add.w	r3, sp, #54	; 0x36
1fff8bb8:	1a18      	subs	r0, r3, r0
		char sign = 0;
1fff8bba:	2600      	movs	r6, #0
1fff8bbc:	469a      	mov	sl, r3
1fff8bbe:	e77f      	b.n	1fff8ac0 <z_cbvprintf_impl+0x57c>
				store_count(conv, value->ptr, count);
1fff8bc0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	switch ((enum length_mod_enum)conv->length_mod) {
1fff8bc2:	2907      	cmp	r1, #7
1fff8bc4:	f63f aed1 	bhi.w	1fff896a <z_cbvprintf_impl+0x426>
1fff8bc8:	e8df f001 	tbb	[pc, r1]
1fff8bcc:	0c06040c 	.word	0x0c06040c
1fff8bd0:	0c0c0808 	.word	0x0c0c0808
		*(signed char *)dp = (signed char)count;
1fff8bd4:	701d      	strb	r5, [r3, #0]
		if (bps == NULL) {
1fff8bd6:	e6c8      	b.n	1fff896a <z_cbvprintf_impl+0x426>
		*(short *)dp = (short)count;
1fff8bd8:	801d      	strh	r5, [r3, #0]
		if (bps == NULL) {
1fff8bda:	e6c6      	b.n	1fff896a <z_cbvprintf_impl+0x426>
		*(intmax_t *)dp = (intmax_t)count;
1fff8bdc:	17ea      	asrs	r2, r5, #31
1fff8bde:	e9c3 5200 	strd	r5, r2, [r3]
		if (bps == NULL) {
1fff8be2:	e6c2      	b.n	1fff896a <z_cbvprintf_impl+0x426>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
1fff8be4:	601d      	str	r5, [r3, #0]
		if (bps == NULL) {
1fff8be6:	e6c0      	b.n	1fff896a <z_cbvprintf_impl+0x426>
1fff8be8:	4f2e      	ldr	r7, [pc, #184]	; (1fff8ca4 <z_cbvprintf_impl+0x760>)
		char sign = 0;
1fff8bea:	4606      	mov	r6, r0
			bpe = bps + 5;
1fff8bec:	f107 0a05 	add.w	sl, r7, #5
		size_t nj_len = (bpe - bps);
1fff8bf0:	2005      	movs	r0, #5
1fff8bf2:	e765      	b.n	1fff8ac0 <z_cbvprintf_impl+0x57c>
		} else if (conv->altform_0) {
1fff8bf4:	071a      	lsls	r2, r3, #28
			nj_len += 1U;
1fff8bf6:	bf48      	it	mi
1fff8bf8:	3001      	addmi	r0, #1
1fff8bfa:	e769      	b.n	1fff8ad0 <z_cbvprintf_impl+0x58c>
1fff8bfc:	9307      	str	r3, [sp, #28]
					OUTC(pad);
1fff8bfe:	4610      	mov	r0, r2
1fff8c00:	9206      	str	r2, [sp, #24]
1fff8c02:	4659      	mov	r1, fp
1fff8c04:	47c8      	blx	r9
1fff8c06:	2800      	cmp	r0, #0
1fff8c08:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
1fff8c0c:	da04      	bge.n	1fff8c18 <z_cbvprintf_impl+0x6d4>
#undef OUTS
#undef OUTC
}
1fff8c0e:	b015      	add	sp, #84	; 0x54
1fff8c10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
1fff8c14:	2220      	movs	r2, #32
					pad = '0';
1fff8c16:	4643      	mov	r3, r8
				while (width-- > 0) {
1fff8c18:	4619      	mov	r1, r3
1fff8c1a:	2900      	cmp	r1, #0
1fff8c1c:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
1fff8c20:	dcec      	bgt.n	1fff8bfc <z_cbvprintf_impl+0x6b8>
1fff8c22:	4445      	add	r5, r8
1fff8c24:	1a6d      	subs	r5, r5, r1
1fff8c26:	4698      	mov	r8, r3
		if (sign != 0) {
1fff8c28:	b12e      	cbz	r6, 1fff8c36 <z_cbvprintf_impl+0x6f2>
			OUTC(sign);
1fff8c2a:	4659      	mov	r1, fp
1fff8c2c:	4630      	mov	r0, r6
1fff8c2e:	47c8      	blx	r9
1fff8c30:	2800      	cmp	r0, #0
1fff8c32:	dbec      	blt.n	1fff8c0e <z_cbvprintf_impl+0x6ca>
1fff8c34:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
1fff8c36:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
1fff8c3a:	06da      	lsls	r2, r3, #27
1fff8c3c:	d401      	bmi.n	1fff8c42 <z_cbvprintf_impl+0x6fe>
1fff8c3e:	071b      	lsls	r3, r3, #28
1fff8c40:	d505      	bpl.n	1fff8c4e <z_cbvprintf_impl+0x70a>
				OUTC('0');
1fff8c42:	4659      	mov	r1, fp
1fff8c44:	2030      	movs	r0, #48	; 0x30
1fff8c46:	47c8      	blx	r9
1fff8c48:	2800      	cmp	r0, #0
1fff8c4a:	dbe0      	blt.n	1fff8c0e <z_cbvprintf_impl+0x6ca>
1fff8c4c:	3501      	adds	r5, #1
			if (conv->altform_0c) {
1fff8c4e:	9b05      	ldr	r3, [sp, #20]
1fff8c50:	b133      	cbz	r3, 1fff8c60 <z_cbvprintf_impl+0x71c>
				OUTC(conv->specifier);
1fff8c52:	f89d 0043 	ldrb.w	r0, [sp, #67]	; 0x43
1fff8c56:	4659      	mov	r1, fp
1fff8c58:	47c8      	blx	r9
1fff8c5a:	2800      	cmp	r0, #0
1fff8c5c:	dbd7      	blt.n	1fff8c0e <z_cbvprintf_impl+0x6ca>
1fff8c5e:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
1fff8c60:	9e04      	ldr	r6, [sp, #16]
1fff8c62:	442e      	add	r6, r5
1fff8c64:	e005      	b.n	1fff8c72 <z_cbvprintf_impl+0x72e>
				OUTC('0');
1fff8c66:	4659      	mov	r1, fp
1fff8c68:	2030      	movs	r0, #48	; 0x30
1fff8c6a:	47c8      	blx	r9
1fff8c6c:	2800      	cmp	r0, #0
1fff8c6e:	dbce      	blt.n	1fff8c0e <z_cbvprintf_impl+0x6ca>
1fff8c70:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
1fff8c72:	1b73      	subs	r3, r6, r5
1fff8c74:	2b00      	cmp	r3, #0
1fff8c76:	dcf6      	bgt.n	1fff8c66 <z_cbvprintf_impl+0x722>
			OUTS(bps, bpe);
1fff8c78:	4653      	mov	r3, sl
1fff8c7a:	463a      	mov	r2, r7
1fff8c7c:	4659      	mov	r1, fp
1fff8c7e:	4648      	mov	r0, r9
1fff8c80:	f001 fab0 	bl	1fffa1e4 <outs>
1fff8c84:	2800      	cmp	r0, #0
1fff8c86:	dbc2      	blt.n	1fff8c0e <z_cbvprintf_impl+0x6ca>
1fff8c88:	4405      	add	r5, r0
		while (width > 0) {
1fff8c8a:	44a8      	add	r8, r5
1fff8c8c:	eba8 0305 	sub.w	r3, r8, r5
1fff8c90:	2b00      	cmp	r3, #0
1fff8c92:	f77f ae6a 	ble.w	1fff896a <z_cbvprintf_impl+0x426>
			OUTC(' ');
1fff8c96:	4659      	mov	r1, fp
1fff8c98:	2020      	movs	r0, #32
1fff8c9a:	47c8      	blx	r9
1fff8c9c:	2800      	cmp	r0, #0
1fff8c9e:	dbb6      	blt.n	1fff8c0e <z_cbvprintf_impl+0x6ca>
1fff8ca0:	3501      	adds	r5, #1
			--width;
1fff8ca2:	e7f3      	b.n	1fff8c8c <z_cbvprintf_impl+0x748>
1fff8ca4:	1fffabad 	.word	0x1fffabad

1fff8ca8 <SOC_ClockInit>:
#include <zephyr/devicetree.h>
#include "wdog_imx.h"

/* Initialize clock. */
void SOC_ClockInit(void)
{
1fff8ca8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	/*
	 * Disable WDOG3
	 *	Note : The WDOG clock Root is shared by all the 4 WDOGs,
	 *	so Zephyr code should avoid closing it
	 */
	CCM_UpdateRoot(CCM, ccmRootWdog, ccmRootmuxWdogOsc24m, 0, 0);
1fff8caa:	4f1a      	ldr	r7, [pc, #104]	; (1fff8d14 <SOC_ClockInit+0x6c>)
1fff8cac:	491a      	ldr	r1, [pc, #104]	; (1fff8d18 <SOC_ClockInit+0x70>)
 * @param ccmGate Gate control (see @ref _ccm_pll_gate and @ref _ccm_ccgr_gate enumeration)
 * @param control Gate control value (see @ref _ccm_gate_value)
 */
static inline void CCM_ControlGate(CCM_Type * base, uint32_t ccmGate, uint32_t control)
{
    CCM_REG(ccmGate) = control;
1fff8cae:	4c1b      	ldr	r4, [pc, #108]	; (1fff8d1c <SOC_ClockInit+0x74>)
1fff8cb0:	2600      	movs	r6, #0
1fff8cb2:	4633      	mov	r3, r6
1fff8cb4:	4632      	mov	r2, r6
1fff8cb6:	9600      	str	r6, [sp, #0]
1fff8cb8:	4638      	mov	r0, r7
1fff8cba:	f000 fc5f 	bl	1fff957c <CCM_UpdateRoot>
    CCM_REG_SET(ccmRoot) = CCM_TARGET_ROOT_SET_ENABLE_MASK;
1fff8cbe:	4b18      	ldr	r3, [pc, #96]	; (1fff8d20 <SOC_ClockInit+0x78>)
1fff8cc0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
1fff8cc4:	f8c3 2b84 	str.w	r2, [r3, #2948]	; 0xb84
 * @param sreq Force acquiring SEMA42 to access this peripheral or not
 * @param lock Whether to lock this setting or not. Once locked, no one can change the RDC setting until reset
 */
static inline void RDC_SetPdapAccess(RDC_Type * base, uint32_t pdap, uint8_t perm, bool sreq, bool lock)
{
    base->PDAP[pdap] = perm | (sreq ? RDC_PDAP_SREQ_MASK : 0) | (lock ? RDC_PDAP_LCK_MASK : 0);
1fff8cc8:	f503 238a 	add.w	r3, r3, #282624	; 0x45000
    CCM_REG(ccmGate) = control;
1fff8ccc:	f241 1111 	movw	r1, #4369	; 0x1111
1fff8cd0:	220c      	movs	r2, #12
1fff8cd2:	f8c4 19e0 	str.w	r1, [r4, #2528]	; 0x9e0
1fff8cd6:	f8c3 2428 	str.w	r2, [r3, #1064]	; 0x428
 *
 * @param base WDOG base pointer.
 */
static inline void WDOG_DisablePowerdown(WDOG_Type *base)
{
    base->WMCR &= ~WDOG_WMCR_PDE_MASK;
1fff8cda:	f5a3 1398 	sub.w	r3, r3, #1245184	; 0x130000
1fff8cde:	891d      	ldrh	r5, [r3, #8]
1fff8ce0:	f025 0501 	bic.w	r5, r5, #1
1fff8ce4:	042d      	lsls	r5, r5, #16
1fff8ce6:	0c2d      	lsrs	r5, r5, #16
1fff8ce8:	811d      	strh	r5, [r3, #8]
1fff8cea:	f8c4 69e0 	str.w	r6, [r4, #2528]	; 0x9e0
1fff8cee:	f8c7 1860 	str.w	r1, [r7, #2144]	; 0x860
1fff8cf2:	f8c7 1880 	str.w	r1, [r7, #2176]	; 0x880
1fff8cf6:	f8c4 10a0 	str.w	r1, [r4, #160]	; 0xa0
1fff8cfa:	f8c4 10b0 	str.w	r1, [r4, #176]	; 0xb0
1fff8cfe:	f8c4 10c0 	str.w	r1, [r4, #192]	; 0xc0
1fff8d02:	f8c4 1a80 	str.w	r1, [r4, #2688]	; 0xa80
1fff8d06:	f8c4 1a90 	str.w	r1, [r4, #2704]	; 0xa90
1fff8d0a:	f8c4 1260 	str.w	r1, [r4, #608]	; 0x260
	CCM_ControlGate(CCM, ccmCcgrGateIomux, ccmClockNeededRun);
	CCM_ControlGate(CCM, ccmCcgrGateIomuxLpsr, ccmClockNeededRun);

	/* Enable clock gate for RDC */
	CCM_ControlGate(CCM, ccmCcgrGateRdc, ccmClockNeededRun);
}
1fff8d0e:	b003      	add	sp, #12
1fff8d10:	bdf0      	pop	{r4, r5, r6, r7, pc}
1fff8d12:	bf00      	nop
1fff8d14:	30380000 	.word	0x30380000
1fff8d18:	3038bb80 	.word	0x3038bb80
1fff8d1c:	30384000 	.word	0x30384000
1fff8d20:	3038b000 	.word	0x3038b000

1fff8d24 <nxp_mcimx7_init>:
	CCM_ControlGate(CCM, ccmCcgrGateMu, ccmClockNeededRun);
}
#endif /* CONFIG_IPM_IMX */

static int nxp_mcimx7_init(const struct device *arg)
{
1fff8d24:	b513      	push	{r0, r1, r4, lr}
    base->MDA[mda] = RDC_MDA_DID(domainId) | (lock ? RDC_MDA_LCK_MASK : 0);
1fff8d26:	4c0f      	ldr	r4, [pc, #60]	; (1fff8d64 <nxp_mcimx7_init+0x40>)
1fff8d28:	2301      	movs	r3, #1
1fff8d2a:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204

	/* SoC specific RDC settings */
	SOC_RdcInit();

	/* BoC specific clock settings */
	SOC_ClockInit();
1fff8d2e:	f7ff ffbb 	bl	1fff8ca8 <SOC_ClockInit>
    base->PDAP[pdap] = perm | (sreq ? RDC_PDAP_SREQ_MASK : 0) | (lock ? RDC_PDAP_LCK_MASK : 0);
1fff8d32:	230f      	movs	r3, #15
1fff8d34:	f8c4 3520 	str.w	r3, [r4, #1312]	; 0x520
	CCM_UpdateRoot(CCM, ccmRootUart6, ccmRootmuxUartOsc24m, 0, 0);
1fff8d38:	2400      	movs	r4, #0
1fff8d3a:	4623      	mov	r3, r4
1fff8d3c:	4622      	mov	r2, r4
1fff8d3e:	490a      	ldr	r1, [pc, #40]	; (1fff8d68 <nxp_mcimx7_init+0x44>)
1fff8d40:	480a      	ldr	r0, [pc, #40]	; (1fff8d6c <nxp_mcimx7_init+0x48>)
1fff8d42:	9400      	str	r4, [sp, #0]
1fff8d44:	f000 fc1a 	bl	1fff957c <CCM_UpdateRoot>
    CCM_REG_SET(ccmRoot) = CCM_TARGET_ROOT_SET_ENABLE_MASK;
1fff8d48:	4b09      	ldr	r3, [pc, #36]	; (1fff8d70 <nxp_mcimx7_init+0x4c>)
1fff8d4a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
1fff8d4e:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
    CCM_REG(ccmGate) = control;
1fff8d52:	f5a3 43e0 	sub.w	r3, r3, #28672	; 0x7000
1fff8d56:	f243 3233 	movw	r2, #13107	; 0x3333
#ifdef CONFIG_IPM_IMX
	nxp_mcimx7_mu_config();
#endif /* CONFIG_IPM_IMX */

	return 0;
}
1fff8d5a:	4620      	mov	r0, r4
1fff8d5c:	f8c3 2990 	str.w	r2, [r3, #2448]	; 0x990
1fff8d60:	b002      	add	sp, #8
1fff8d62:	bd10      	pop	{r4, pc}
1fff8d64:	303d0000 	.word	0x303d0000
1fff8d68:	3038b200 	.word	0x3038b200
1fff8d6c:	30380000 	.word	0x30380000
1fff8d70:	3038b000 	.word	0x3038b000

1fff8d74 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
1fff8d74:	4901      	ldr	r1, [pc, #4]	; (1fff8d7c <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
1fff8d76:	2210      	movs	r2, #16
	str	r2, [r1]
1fff8d78:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
1fff8d7a:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
1fff8d7c:	e000ed10 	.word	0xe000ed10

1fff8d80 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
1fff8d80:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
1fff8d82:	4040      	eors	r0, r0
	msr	BASEPRI, r0
1fff8d84:	f380 8811 	msr	BASEPRI, r0
	isb
1fff8d88:	f3bf 8f6f 	isb	sy
	 * (i.e. if the caller sets _kernel.idle).
	 */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */

	/* Enter low power state */
	_sleep_if_allowed wfi
1fff8d8c:	f3bf 8f4f 	dsb	sy
1fff8d90:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
1fff8d92:	b662      	cpsie	i
	isb
1fff8d94:	f3bf 8f6f 	isb	sy

	bx	lr
1fff8d98:	4770      	bx	lr
1fff8d9a:	bf00      	nop

1fff8d9c <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
1fff8d9c:	b240      	sxtb	r0, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
1fff8d9e:	2800      	cmp	r0, #0
1fff8da0:	db07      	blt.n	1fff8db2 <arch_irq_enable+0x16>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
1fff8da2:	4a04      	ldr	r2, [pc, #16]	; (1fff8db4 <arch_irq_enable+0x18>)
1fff8da4:	0941      	lsrs	r1, r0, #5
1fff8da6:	2301      	movs	r3, #1
1fff8da8:	f000 001f 	and.w	r0, r0, #31
1fff8dac:	4083      	lsls	r3, r0
1fff8dae:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
1fff8db2:	4770      	bx	lr
1fff8db4:	e000e100 	.word	0xe000e100

1fff8db8 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
1fff8db8:	b240      	sxtb	r0, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
1fff8dba:	2800      	cmp	r0, #0
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
1fff8dbc:	bfa8      	it	ge
1fff8dbe:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
		prio += _IRQ_PRIO_OFFSET;
1fff8dc2:	f101 0101 	add.w	r1, r1, #1
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
1fff8dc6:	bfb8      	it	lt
1fff8dc8:	4b06      	ldrlt	r3, [pc, #24]	; (1fff8de4 <z_arm_irq_priority_set+0x2c>)
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
1fff8dca:	ea4f 1101 	mov.w	r1, r1, lsl #4
1fff8dce:	bfac      	ite	ge
1fff8dd0:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
1fff8dd4:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
1fff8dd8:	b2c9      	uxtb	r1, r1
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
1fff8dda:	bfb4      	ite	lt
1fff8ddc:	5419      	strblt	r1, [r3, r0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
1fff8dde:	f880 1300 	strbge.w	r1, [r0, #768]	; 0x300
}
1fff8de2:	4770      	bx	lr
1fff8de4:	e000ed14 	.word	0xe000ed14

1fff8de8 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
1fff8de8:	bf30      	wfi
    b z_SysNmiOnReset
1fff8dea:	f7ff bffd 	b.w	1fff8de8 <z_SysNmiOnReset>
1fff8dee:	bf00      	nop

1fff8df0 <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
1fff8df0:	4a0f      	ldr	r2, [pc, #60]	; (1fff8e30 <z_arm_prep_c+0x40>)
 *
 * This routine prepares for the execution of and runs C code.
 *
 */
void z_arm_prep_c(void)
{
1fff8df2:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
1fff8df4:	4b0f      	ldr	r3, [pc, #60]	; (1fff8e34 <z_arm_prep_c+0x44>)
1fff8df6:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
1fff8dfa:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
1fff8dfc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
1fff8e00:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
1fff8e04:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
1fff8e08:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
1fff8e0c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 */
__STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, control" : "=r" (result) );
1fff8e10:	f3ef 8314 	mrs	r3, CONTROL
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
1fff8e14:	f023 0304 	bic.w	r3, r3, #4
  \details Writes the given value to the Control Register.
  \param [in]    control  Control Register value to set
 */
__STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
{
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
1fff8e18:	f383 8814 	msr	CONTROL, r3
  __ASM volatile ("isb 0xF":::"memory");
1fff8e1c:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
1fff8e20:	f000 fd14 	bl	1fff984c <z_bss_zero>
	z_data_copy();
1fff8e24:	f001 f836 	bl	1fff9e94 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
1fff8e28:	f000 f9de 	bl	1fff91e8 <z_arm_interrupt_init>
	z_cstart();
1fff8e2c:	f000 fd4e 	bl	1fff98cc <z_cstart>
1fff8e30:	1fff8000 	.word	0x1fff8000
1fff8e34:	e000ed00 	.word	0xe000ed00

1fff8e38 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
1fff8e38:	4a09      	ldr	r2, [pc, #36]	; (1fff8e60 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
1fff8e3a:	490a      	ldr	r1, [pc, #40]	; (1fff8e64 <arch_swap+0x2c>)
	_current->arch.basepri = key;
1fff8e3c:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
1fff8e3e:	6809      	ldr	r1, [r1, #0]
1fff8e40:	66d9      	str	r1, [r3, #108]	; 0x6c

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
1fff8e42:	4909      	ldr	r1, [pc, #36]	; (1fff8e68 <arch_swap+0x30>)
	_current->arch.basepri = key;
1fff8e44:	6698      	str	r0, [r3, #104]	; 0x68
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
1fff8e46:	684b      	ldr	r3, [r1, #4]
1fff8e48:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
1fff8e4c:	604b      	str	r3, [r1, #4]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
1fff8e4e:	2300      	movs	r3, #0
1fff8e50:	f383 8811 	msr	BASEPRI, r3
1fff8e54:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
1fff8e58:	6893      	ldr	r3, [r2, #8]
}
1fff8e5a:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
1fff8e5c:	4770      	bx	lr
1fff8e5e:	bf00      	nop
1fff8e60:	20000130 	.word	0x20000130
1fff8e64:	1fffab80 	.word	0x1fffab80
1fff8e68:	e000ed00 	.word	0xe000ed00

1fff8e6c <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
1fff8e6c:	490f      	ldr	r1, [pc, #60]	; (1fff8eac <z_arm_pendsv+0x40>)
    ldr r2, [r1, #_kernel_offset_to_current]
1fff8e6e:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
1fff8e70:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
1fff8e74:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
1fff8e76:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
1fff8e7a:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
1fff8e7e:	2010      	movs	r0, #16
    msr BASEPRI_MAX, r0
1fff8e80:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
1fff8e84:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
1fff8e88:	4f09      	ldr	r7, [pc, #36]	; (1fff8eb0 <z_arm_pendsv+0x44>)
    ldr v3, =_SCS_ICSR_UNPENDSV
1fff8e8a:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
1fff8e8e:	694a      	ldr	r2, [r1, #20]

    str r2, [r1, #_kernel_offset_to_current]
1fff8e90:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
1fff8e92:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
1fff8e94:	6e90      	ldr	r0, [r2, #104]	; 0x68
    movs r3, #0
1fff8e96:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
1fff8e98:	6693      	str	r3, [r2, #104]	; 0x68
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
1fff8e9a:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
1fff8e9e:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
1fff8ea2:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
1fff8ea6:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
1fff8eaa:	4770      	bx	lr
    ldr r1, =_kernel
1fff8eac:	20000130 	.word	0x20000130
    ldr v4, =_SCS_ICSR
1fff8eb0:	e000ed04 	.word	0xe000ed04

1fff8eb4 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
1fff8eb4:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
1fff8eb8:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
1fff8eba:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
1fff8ebe:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
1fff8ec2:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
1fff8ec4:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
1fff8ec8:	2902      	cmp	r1, #2
    beq _oops
1fff8eca:	d0ff      	beq.n	1fff8ecc <_oops>

1fff8ecc <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
1fff8ecc:	b501      	push	{r0, lr}
    push {r1, r2}
    push {r4-r11}
    mov  r1, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    bl z_do_kernel_oops
1fff8ece:	f001 f9a3 	bl	1fffa218 <z_do_kernel_oops>
     * the MSP to its value prior to entering the function
     */
    add sp, #40
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    pop {r0, pc}
1fff8ed2:	bd01      	pop	{r0, pc}

1fff8ed4 <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
1fff8ed4:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
1fff8ed8:	9b00      	ldr	r3, [sp, #0]
1fff8eda:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->pc &= 0xfffffffe;
1fff8ede:	490a      	ldr	r1, [pc, #40]	; (1fff8f08 <arch_new_thread+0x34>)
	iframe->a3 = (uint32_t)p2;
1fff8ee0:	9b01      	ldr	r3, [sp, #4]
1fff8ee2:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
1fff8ee6:	9b02      	ldr	r3, [sp, #8]
1fff8ee8:	f842 3c14 	str.w	r3, [r2, #-20]
	iframe->pc &= 0xfffffffe;
1fff8eec:	f021 0101 	bic.w	r1, r1, #1

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
1fff8ef0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
1fff8ef4:	f842 3c04 	str.w	r3, [r2, #-4]
	iframe->pc &= 0xfffffffe;
1fff8ef8:	f842 1c08 	str.w	r1, [r2, #-8]
		((uintptr_t)iframe - sizeof(struct __fpu_sf));
	memset(iframe, 0, sizeof(struct __fpu_sf));
#endif

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
1fff8efc:	2300      	movs	r3, #0
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
1fff8efe:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
1fff8f00:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
1fff8f02:	6683      	str	r3, [r0, #104]	; 0x68
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
1fff8f04:	4770      	bx	lr
1fff8f06:	bf00      	nop
1fff8f08:	1fffa145 	.word	0x1fffa145

1fff8f0c <arch_switch_to_main_thread>:
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
	z_arm_prepare_switch_to_main();

	_current = main_thread;
1fff8f0c:	4b07      	ldr	r3, [pc, #28]	; (1fff8f2c <arch_switch_to_main_thread+0x20>)
1fff8f0e:	6098      	str	r0, [r3, #8]

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
1fff8f10:	4610      	mov	r0, r2
1fff8f12:	f381 8809 	msr	PSP, r1
1fff8f16:	2100      	movs	r1, #0
1fff8f18:	b663      	cpsie	if
1fff8f1a:	f381 8811 	msr	BASEPRI, r1
1fff8f1e:	f3bf 8f6f 	isb	sy
1fff8f22:	2200      	movs	r2, #0
1fff8f24:	2300      	movs	r3, #0
1fff8f26:	f001 f90d 	bl	1fffa144 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
1fff8f2a:	bf00      	nop
1fff8f2c:	20000130 	.word	0x20000130

1fff8f30 <_isr_wrapper>:
 *
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
1fff8f30:	b501      	push	{r0, lr}
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
1fff8f32:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
1fff8f36:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
1fff8f3a:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
1fff8f3e:	4904      	ldr	r1, [pc, #16]	; (1fff8f50 <_isr_wrapper+0x20>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
1fff8f40:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
1fff8f42:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
1fff8f44:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
1fff8f46:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
1fff8f4a:	4902      	ldr	r1, [pc, #8]	; (1fff8f54 <_isr_wrapper+0x24>)
	bx r1
1fff8f4c:	4708      	bx	r1
1fff8f4e:	0000      	.short	0x0000
	ldr r1, =_sw_isr_table
1fff8f50:	1fffa6d8 	.word	0x1fffa6d8
	ldr r1, =z_arm_int_exit
1fff8f54:	1fff8f59 	.word	0x1fff8f59

1fff8f58 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
1fff8f58:	4b04      	ldr	r3, [pc, #16]	; (1fff8f6c <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
1fff8f5a:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
1fff8f5c:	6958      	ldr	r0, [r3, #20]
	cmp r0, r1
1fff8f5e:	4288      	cmp	r0, r1
	beq _EXIT_EXC
1fff8f60:	d003      	beq.n	1fff8f6a <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
1fff8f62:	4903      	ldr	r1, [pc, #12]	; (1fff8f70 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
1fff8f64:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
1fff8f68:	600a      	str	r2, [r1, #0]

1fff8f6a <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
1fff8f6a:	4770      	bx	lr
	ldr r3, =_kernel
1fff8f6c:	20000130 	.word	0x20000130
	ldr r1, =_SCS_ICSR
1fff8f70:	e000ed04 	.word	0xe000ed04

1fff8f74 <usage_fault.constprop.0>:
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
1fff8f74:	4b13      	ldr	r3, [pc, #76]	; (1fff8fc4 <usage_fault.constprop.0+0x50>)
1fff8f76:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
1fff8f78:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
		reason = K_ERR_ARM_USAGE_DIV_0;
		PR_FAULT_INFO("  Division by zero");
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
1fff8f7c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
1fff8f7e:	bf14      	ite	ne
1fff8f80:	201e      	movne	r0, #30
1fff8f82:	201d      	moveq	r0, #29
		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
1fff8f84:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
1fff8f88:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
1fff8f8a:	bf18      	it	ne
1fff8f8c:	201f      	movne	r0, #31
		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
1fff8f8e:	f412 2f00 	tst.w	r2, #524288	; 0x80000
		PR_FAULT_INFO("  No coprocessor instructions");
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
1fff8f92:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
1fff8f94:	bf18      	it	ne
1fff8f96:	2021      	movne	r0, #33	; 0x21
		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
1fff8f98:	f412 2f80 	tst.w	r2, #262144	; 0x40000
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
1fff8f9c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
1fff8f9e:	bf18      	it	ne
1fff8fa0:	2022      	movne	r0, #34	; 0x22
		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
1fff8fa2:	f412 3f00 	tst.w	r2, #131072	; 0x20000
		PR_FAULT_INFO("  Illegal use of the EPSR");
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
1fff8fa6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
1fff8fa8:	bf18      	it	ne
1fff8faa:	2023      	movne	r0, #35	; 0x23
		reason = K_ERR_ARM_USAGE_UNDEFINED_INSTRUCTION;
1fff8fac:	f412 3f80 	tst.w	r2, #65536	; 0x10000
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
1fff8fb0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
1fff8fb2:	ea6f 4202 	mvn.w	r2, r2, lsl #16
1fff8fb6:	ea6f 4212 	mvn.w	r2, r2, lsr #16
1fff8fba:	629a      	str	r2, [r3, #40]	; 0x28

	return reason;
}
1fff8fbc:	bf18      	it	ne
1fff8fbe:	2024      	movne	r0, #36	; 0x24
1fff8fc0:	4770      	bx	lr
1fff8fc2:	bf00      	nop
1fff8fc4:	e000ed00 	.word	0xe000ed00

1fff8fc8 <bus_fault.constprop.0>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
1fff8fc8:	b510      	push	{r4, lr}
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
1fff8fca:	4b19      	ldr	r3, [pc, #100]	; (1fff9030 <bus_fault.constprop.0+0x68>)
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
1fff8fcc:	4602      	mov	r2, r0
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
1fff8fce:	6a98      	ldr	r0, [r3, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
1fff8fd0:	6a9c      	ldr	r4, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_BUS_GENERIC;
1fff8fd2:	f410 5f80 	tst.w	r0, #4096	; 0x1000
1fff8fd6:	bf14      	ite	ne
1fff8fd8:	2017      	movne	r0, #23
1fff8fda:	2016      	moveq	r0, #22
		reason = K_ERR_ARM_BUS_UNSTACKING;
1fff8fdc:	f414 6f00 	tst.w	r4, #2048	; 0x800
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
1fff8fe0:	6a9c      	ldr	r4, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_UNSTACKING;
1fff8fe2:	bf18      	it	ne
1fff8fe4:	2018      	movne	r0, #24
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
1fff8fe6:	05a4      	lsls	r4, r4, #22
1fff8fe8:	d509      	bpl.n	1fff8ffe <bus_fault.constprop.0+0x36>
		STORE_xFAR(bfar, SCB->BFAR);
1fff8fea:	6b98      	ldr	r0, [r3, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
1fff8fec:	6a98      	ldr	r0, [r3, #40]	; 0x28
1fff8fee:	0400      	lsls	r0, r0, #16
1fff8ff0:	d504      	bpl.n	1fff8ffc <bus_fault.constprop.0+0x34>
			if (from_hard_fault != 0) {
1fff8ff2:	b11a      	cbz	r2, 1fff8ffc <bus_fault.constprop.0+0x34>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
1fff8ff4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
1fff8ff6:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
1fff8ffa:	629a      	str	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_PRECISE_DATA_BUS;
1fff8ffc:	2019      	movs	r0, #25
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
1fff8ffe:	4b0c      	ldr	r3, [pc, #48]	; (1fff9030 <bus_fault.constprop.0+0x68>)
1fff9000:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
1fff9002:	f412 6f80 	tst.w	r2, #1024	; 0x400
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
1fff9006:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
1fff9008:	bf18      	it	ne
1fff900a:	201a      	movne	r0, #26
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
1fff900c:	05d2      	lsls	r2, r2, #23
1fff900e:	d40c      	bmi.n	1fff902a <bus_fault.constprop.0+0x62>
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
1fff9010:	6a9b      	ldr	r3, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_FP_LAZY_STATE_PRESERVATION;
1fff9012:	f413 5f00 	tst.w	r3, #8192	; 0x2000
1fff9016:	bf18      	it	ne
1fff9018:	201c      	movne	r0, #28
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
1fff901a:	4a05      	ldr	r2, [pc, #20]	; (1fff9030 <bus_fault.constprop.0+0x68>)
1fff901c:	6a93      	ldr	r3, [r2, #40]	; 0x28
1fff901e:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
1fff9022:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
1fff9024:	2300      	movs	r3, #0
1fff9026:	700b      	strb	r3, [r1, #0]
}
1fff9028:	bd10      	pop	{r4, pc}
		reason = K_ERR_ARM_BUS_INSTRUCTION_BUS;
1fff902a:	201b      	movs	r0, #27
1fff902c:	e7f5      	b.n	1fff901a <bus_fault.constprop.0+0x52>
1fff902e:	bf00      	nop
1fff9030:	e000ed00 	.word	0xe000ed00

1fff9034 <mem_manage_fault.constprop.0>:
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
1fff9034:	b510      	push	{r4, lr}
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
1fff9036:	4b1c      	ldr	r3, [pc, #112]	; (1fff90a8 <mem_manage_fault.constprop.0+0x74>)
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
1fff9038:	4602      	mov	r2, r0
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
1fff903a:	6a98      	ldr	r0, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
1fff903c:	6a9c      	ldr	r4, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_MEM_GENERIC;
1fff903e:	f010 0f10 	tst.w	r0, #16
1fff9042:	bf14      	ite	ne
1fff9044:	2011      	movne	r0, #17
1fff9046:	2010      	moveq	r0, #16
		reason = K_ERR_ARM_MEM_UNSTACKING;
1fff9048:	f014 0f08 	tst.w	r4, #8
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
1fff904c:	6a9c      	ldr	r4, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_UNSTACKING;
1fff904e:	bf18      	it	ne
1fff9050:	2012      	movne	r0, #18
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
1fff9052:	07a4      	lsls	r4, r4, #30
1fff9054:	d509      	bpl.n	1fff906a <mem_manage_fault.constprop.0+0x36>
		uint32_t temp = SCB->MMFAR;
1fff9056:	6b58      	ldr	r0, [r3, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
1fff9058:	6a98      	ldr	r0, [r3, #40]	; 0x28
1fff905a:	0600      	lsls	r0, r0, #24
1fff905c:	d504      	bpl.n	1fff9068 <mem_manage_fault.constprop.0+0x34>
			if (from_hard_fault != 0) {
1fff905e:	b11a      	cbz	r2, 1fff9068 <mem_manage_fault.constprop.0+0x34>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
1fff9060:	6a9a      	ldr	r2, [r3, #40]	; 0x28
1fff9062:	f022 0280 	bic.w	r2, r2, #128	; 0x80
1fff9066:	629a      	str	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_DATA_ACCESS;
1fff9068:	2013      	movs	r0, #19
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
1fff906a:	4b0f      	ldr	r3, [pc, #60]	; (1fff90a8 <mem_manage_fault.constprop.0+0x74>)
1fff906c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
1fff906e:	f012 0f01 	tst.w	r2, #1
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
1fff9072:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
1fff9074:	bf18      	it	ne
1fff9076:	2014      	movne	r0, #20
		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
1fff9078:	f012 0f20 	tst.w	r2, #32
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
1fff907c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
1fff907e:	bf18      	it	ne
1fff9080:	2015      	movne	r0, #21
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
1fff9082:	06d4      	lsls	r4, r2, #27
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
1fff9084:	bf58      	it	pl
1fff9086:	6a9b      	ldrpl	r3, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
1fff9088:	4b07      	ldr	r3, [pc, #28]	; (1fff90a8 <mem_manage_fault.constprop.0+0x74>)
1fff908a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
1fff908c:	0692      	lsls	r2, r2, #26
		SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTPENDED_Msk;
1fff908e:	bf42      	ittt	mi
1fff9090:	6a5a      	ldrmi	r2, [r3, #36]	; 0x24
1fff9092:	f422 5200 	bicmi.w	r2, r2, #8192	; 0x2000
1fff9096:	625a      	strmi	r2, [r3, #36]	; 0x24
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
1fff9098:	6a9a      	ldr	r2, [r3, #40]	; 0x28
1fff909a:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
1fff909e:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
1fff90a0:	2300      	movs	r3, #0
1fff90a2:	700b      	strb	r3, [r1, #0]
}
1fff90a4:	bd10      	pop	{r4, pc}
1fff90a6:	bf00      	nop
1fff90a8:	e000ed00 	.word	0xe000ed00

1fff90ac <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
1fff90ac:	b570      	push	{r4, r5, r6, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
1fff90ae:	4b44      	ldr	r3, [pc, #272]	; (1fff91c0 <z_arm_fault+0x114>)
1fff90b0:	685b      	ldr	r3, [r3, #4]
{
1fff90b2:	b08a      	sub	sp, #40	; 0x28
1fff90b4:	4606      	mov	r6, r0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
1fff90b6:	f3c3 0308 	ubfx	r3, r3, #0, #9
1fff90ba:	2500      	movs	r5, #0
1fff90bc:	f385 8811 	msr	BASEPRI, r5
1fff90c0:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
1fff90c4:	f002 407f 	and.w	r0, r2, #4278190080	; 0xff000000
1fff90c8:	f1b0 4f7f 	cmp.w	r0, #4278190080	; 0xff000000
1fff90cc:	d111      	bne.n	1fff90f2 <z_arm_fault+0x46>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
1fff90ce:	f002 000c 	and.w	r0, r2, #12
1fff90d2:	2808      	cmp	r0, #8
1fff90d4:	d00d      	beq.n	1fff90f2 <z_arm_fault+0x46>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
1fff90d6:	0710      	lsls	r0, r2, #28
			ptr_esf =  (z_arch_esf_t *)psp;
1fff90d8:	bf4c      	ite	mi
1fff90da:	460e      	movmi	r6, r1
			*nested_exc = true;
1fff90dc:	2501      	movpl	r5, #1
	*recoverable = false;
1fff90de:	2200      	movs	r2, #0
	switch (fault) {
1fff90e0:	3b03      	subs	r3, #3
	*recoverable = false;
1fff90e2:	f88d 2007 	strb.w	r2, [sp, #7]
	switch (fault) {
1fff90e6:	2b03      	cmp	r3, #3
1fff90e8:	d805      	bhi.n	1fff90f6 <z_arm_fault+0x4a>
1fff90ea:	e8df f003 	tbb	[pc, r3]
1fff90ee:	5c1e      	.short	0x5c1e
1fff90f0:	5960      	.short	0x5960
		return NULL;
1fff90f2:	462e      	mov	r6, r5
1fff90f4:	e7f3      	b.n	1fff90de <z_arm_fault+0x32>
1fff90f6:	2400      	movs	r4, #0
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
1fff90f8:	f89d 3007 	ldrb.w	r3, [sp, #7]
1fff90fc:	b99b      	cbnz	r3, 1fff9126 <z_arm_fault+0x7a>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
1fff90fe:	2220      	movs	r2, #32
1fff9100:	4631      	mov	r1, r6
1fff9102:	a802      	add	r0, sp, #8
1fff9104:	f001 f8a7 	bl	1fffa256 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
1fff9108:	9b09      	ldr	r3, [sp, #36]	; 0x24
1fff910a:	2d00      	cmp	r5, #0
1fff910c:	d053      	beq.n	1fff91b6 <z_arm_fault+0x10a>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
1fff910e:	f3c3 0208 	ubfx	r2, r3, #0, #9
1fff9112:	b922      	cbnz	r2, 1fff911e <z_arm_fault+0x72>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
1fff9114:	ea6f 2353 	mvn.w	r3, r3, lsr #9
1fff9118:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
1fff911c:	9309      	str	r3, [sp, #36]	; 0x24

	if (IS_ENABLED(CONFIG_SIMPLIFIED_EXCEPTION_CODES) && (reason >= K_ERR_ARCH_START)) {
		reason = K_ERR_CPU_EXCEPTION;
	}

	z_arm_fatal_error(reason, &esf_copy);
1fff911e:	a902      	add	r1, sp, #8
1fff9120:	4620      	mov	r0, r4
1fff9122:	f001 f877 	bl	1fffa214 <z_arm_fatal_error>
}
1fff9126:	b00a      	add	sp, #40	; 0x28
1fff9128:	bd70      	pop	{r4, r5, r6, pc}
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
1fff912a:	4b25      	ldr	r3, [pc, #148]	; (1fff91c0 <z_arm_fault+0x114>)
1fff912c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1fff912e:	0791      	lsls	r1, r2, #30
1fff9130:	d4e1      	bmi.n	1fff90f6 <z_arm_fault+0x4a>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
1fff9132:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1fff9134:	2a00      	cmp	r2, #0
1fff9136:	dbde      	blt.n	1fff90f6 <z_arm_fault+0x4a>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
1fff9138:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1fff913a:	0052      	lsls	r2, r2, #1
1fff913c:	d5db      	bpl.n	1fff90f6 <z_arm_fault+0x4a>
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
1fff913e:	695a      	ldr	r2, [r3, #20]
	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
1fff9140:	69b1      	ldr	r1, [r6, #24]
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
1fff9142:	f442 7280 	orr.w	r2, r2, #256	; 0x100
1fff9146:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
1fff9148:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
1fff914c:	f3bf 8f6f 	isb	sy
	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
1fff9150:	695a      	ldr	r2, [r3, #20]
	uint16_t fault_insn = *(ret_addr - 1);
1fff9152:	f831 1c02 	ldrh.w	r1, [r1, #-2]
	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
1fff9156:	f422 7280 	bic.w	r2, r2, #256	; 0x100
1fff915a:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
1fff915c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
1fff9160:	f3bf 8f6f 	isb	sy
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
1fff9164:	f64d 7202 	movw	r2, #57090	; 0xdf02
1fff9168:	4291      	cmp	r1, r2
1fff916a:	d009      	beq.n	1fff9180 <z_arm_fault+0xd4>
		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
1fff916c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
1fff916e:	b2d2      	uxtb	r2, r2
1fff9170:	b142      	cbz	r2, 1fff9184 <z_arm_fault+0xd8>
			reason = mem_manage_fault(esf, 1, recoverable);
1fff9172:	f10d 0107 	add.w	r1, sp, #7
1fff9176:	2001      	movs	r0, #1
		reason = mem_manage_fault(esf, 0, recoverable);
1fff9178:	f7ff ff5c 	bl	1fff9034 <mem_manage_fault.constprop.0>
		reason = usage_fault(esf);
1fff917c:	4604      	mov	r4, r0
		break;
1fff917e:	e7bb      	b.n	1fff90f8 <z_arm_fault+0x4c>
			reason = esf->basic.r0;
1fff9180:	6834      	ldr	r4, [r6, #0]
1fff9182:	e7b9      	b.n	1fff90f8 <z_arm_fault+0x4c>
		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
1fff9184:	6a9a      	ldr	r2, [r3, #40]	; 0x28
1fff9186:	f412 4f7f 	tst.w	r2, #65280	; 0xff00
1fff918a:	d005      	beq.n	1fff9198 <z_arm_fault+0xec>
			reason = bus_fault(esf, 1, recoverable);
1fff918c:	f10d 0107 	add.w	r1, sp, #7
1fff9190:	2001      	movs	r0, #1
		reason = bus_fault(esf, 0, recoverable);
1fff9192:	f7ff ff19 	bl	1fff8fc8 <bus_fault.constprop.0>
1fff9196:	e7f1      	b.n	1fff917c <z_arm_fault+0xd0>
		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
1fff9198:	6a9b      	ldr	r3, [r3, #40]	; 0x28
1fff919a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
1fff919e:	d3aa      	bcc.n	1fff90f6 <z_arm_fault+0x4a>
		reason = usage_fault(esf);
1fff91a0:	f7ff fee8 	bl	1fff8f74 <usage_fault.constprop.0>
1fff91a4:	e7ea      	b.n	1fff917c <z_arm_fault+0xd0>
		reason = mem_manage_fault(esf, 0, recoverable);
1fff91a6:	f10d 0107 	add.w	r1, sp, #7
1fff91aa:	2000      	movs	r0, #0
1fff91ac:	e7e4      	b.n	1fff9178 <z_arm_fault+0xcc>
		reason = bus_fault(esf, 0, recoverable);
1fff91ae:	f10d 0107 	add.w	r1, sp, #7
1fff91b2:	2000      	movs	r0, #0
1fff91b4:	e7ed      	b.n	1fff9192 <z_arm_fault+0xe6>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
1fff91b6:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
1fff91ba:	f023 0301 	bic.w	r3, r3, #1
1fff91be:	e7ad      	b.n	1fff911c <z_arm_fault+0x70>
1fff91c0:	e000ed00 	.word	0xe000ed00

1fff91c4 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
1fff91c4:	4a02      	ldr	r2, [pc, #8]	; (1fff91d0 <z_arm_fault_init+0xc>)
1fff91c6:	6953      	ldr	r3, [r2, #20]
1fff91c8:	f043 0310 	orr.w	r3, r3, #16
1fff91cc:	6153      	str	r3, [r2, #20]
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
#ifdef CONFIG_TRAP_UNALIGNED_ACCESS
	SCB->CCR |= SCB_CCR_UNALIGN_TRP_Msk;
#endif /* CONFIG_TRAP_UNALIGNED_ACCESS */
}
1fff91ce:	4770      	bx	lr
1fff91d0:	e000ed00 	.word	0xe000ed00

1fff91d4 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
1fff91d4:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
1fff91d8:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
1fff91dc:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
1fff91de:	4672      	mov	r2, lr
	bl z_arm_fault
1fff91e0:	f7ff ff64 	bl	1fff90ac <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
1fff91e4:	bd01      	pop	{r0, pc}
1fff91e6:	bf00      	nop

1fff91e8 <z_arm_interrupt_init>:
1fff91e8:	4804      	ldr	r0, [pc, #16]	; (1fff91fc <z_arm_interrupt_init+0x14>)
 *
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
1fff91ea:	2300      	movs	r3, #0
1fff91ec:	2110      	movs	r1, #16
1fff91ee:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
1fff91f0:	3301      	adds	r3, #1
1fff91f2:	2b7f      	cmp	r3, #127	; 0x7f
1fff91f4:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
1fff91f8:	d1f9      	bne.n	1fff91ee <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
1fff91fa:	4770      	bx	lr
1fff91fc:	e000e100 	.word	0xe000e100

1fff9200 <__start>:

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
1fff9200:	2010      	movs	r0, #16
    msr BASEPRI, r0
1fff9202:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
1fff9206:	4808      	ldr	r0, [pc, #32]	; (1fff9228 <__start+0x28>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
1fff9208:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
1fff920c:	1840      	adds	r0, r0, r1
    msr PSP, r0
1fff920e:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
1fff9212:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
1fff9216:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
1fff9218:	4308      	orrs	r0, r1
    msr CONTROL, r0
1fff921a:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
1fff921e:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
1fff9222:	f7ff fde5 	bl	1fff8df0 <z_arm_prep_c>
1fff9226:	0000      	.short	0x0000
    ldr r0, =z_interrupt_stacks
1fff9228:	20000168 	.word	0x20000168

1fff922c <z_impl_k_thread_abort>:
#include <zephyr/wait_q.h>
#include <zephyr/sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
1fff922c:	4b08      	ldr	r3, [pc, #32]	; (1fff9250 <z_impl_k_thread_abort+0x24>)
1fff922e:	689b      	ldr	r3, [r3, #8]
1fff9230:	4283      	cmp	r3, r0
1fff9232:	d10b      	bne.n	1fff924c <z_impl_k_thread_abort+0x20>
 */
__STATIC_FORCEINLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
1fff9234:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
1fff9238:	b143      	cbz	r3, 1fff924c <z_impl_k_thread_abort+0x20>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
1fff923a:	4b06      	ldr	r3, [pc, #24]	; (1fff9254 <z_impl_k_thread_abort+0x28>)
1fff923c:	685a      	ldr	r2, [r3, #4]
1fff923e:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
1fff9242:	605a      	str	r2, [r3, #4]
			/* Clear any system calls that may be pending
			 * as they have a higher priority than the PendSV
			 * handler and will check the stack of the thread
			 * being aborted.
			 */
			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
1fff9244:	6a5a      	ldr	r2, [r3, #36]	; 0x24
1fff9246:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
1fff924a:	625a      	str	r2, [r3, #36]	; 0x24
		}
	}

	z_thread_abort(thread);
1fff924c:	f000 bdc2 	b.w	1fff9dd4 <z_thread_abort>
1fff9250:	20000130 	.word	0x20000130
1fff9254:	e000ed00 	.word	0xe000ed00

1fff9258 <__stdout_hook_install>:

static int (*_stdout_hook)(int c) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int c))
{
	_stdout_hook = hook;
1fff9258:	4b01      	ldr	r3, [pc, #4]	; (1fff9260 <__stdout_hook_install+0x8>)
1fff925a:	6018      	str	r0, [r3, #0]
}
1fff925c:	4770      	bx	lr
1fff925e:	bf00      	nop
1fff9260:	20000004 	.word	0x20000004

1fff9264 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
1fff9264:	b508      	push	{r3, lr}
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
1fff9266:	4807      	ldr	r0, [pc, #28]	; (1fff9284 <uart_console_init+0x20>)
1fff9268:	f001 f95b 	bl	1fffa522 <z_device_is_ready>

	ARG_UNUSED(arg);

	if (!device_is_ready(uart_console_dev)) {
1fff926c:	b138      	cbz	r0, 1fff927e <uart_console_init+0x1a>
	__stdout_hook_install(console_out);
1fff926e:	4806      	ldr	r0, [pc, #24]	; (1fff9288 <uart_console_init+0x24>)
1fff9270:	f7ff fff2 	bl	1fff9258 <__stdout_hook_install>
	__printk_hook_install(console_out);
1fff9274:	4804      	ldr	r0, [pc, #16]	; (1fff9288 <uart_console_init+0x24>)
1fff9276:	f7ff f951 	bl	1fff851c <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
1fff927a:	2000      	movs	r0, #0
}
1fff927c:	bd08      	pop	{r3, pc}
		return -ENODEV;
1fff927e:	f06f 0012 	mvn.w	r0, #18
1fff9282:	e7fb      	b.n	1fff927c <uart_console_init+0x18>
1fff9284:	1fffa6c0 	.word	0x1fffa6c0
1fff9288:	1fff928d 	.word	0x1fff928d

1fff928c <console_out>:
	if ('\n' == c) {
1fff928c:	280a      	cmp	r0, #10
{
1fff928e:	b538      	push	{r3, r4, r5, lr}
1fff9290:	4d07      	ldr	r5, [pc, #28]	; (1fff92b0 <console_out+0x24>)
1fff9292:	4604      	mov	r4, r0
	if ('\n' == c) {
1fff9294:	d104      	bne.n	1fff92a0 <console_out+0x14>
					unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
1fff9296:	68ab      	ldr	r3, [r5, #8]
1fff9298:	210d      	movs	r1, #13
1fff929a:	685b      	ldr	r3, [r3, #4]
1fff929c:	4628      	mov	r0, r5
1fff929e:	4798      	blx	r3
1fff92a0:	68ab      	ldr	r3, [r5, #8]
1fff92a2:	4803      	ldr	r0, [pc, #12]	; (1fff92b0 <console_out+0x24>)
1fff92a4:	685b      	ldr	r3, [r3, #4]
1fff92a6:	b2e1      	uxtb	r1, r4
1fff92a8:	4798      	blx	r3
}
1fff92aa:	4620      	mov	r0, r4
1fff92ac:	bd38      	pop	{r3, r4, r5, pc}
1fff92ae:	bf00      	nop
1fff92b0:	1fffa6c0 	.word	0x1fffa6c0

1fff92b4 <uart_imx_irq_err_disable>:
	UART_SetIntCmd(uart, uartIntParityError, true);
	UART_SetIntCmd(uart, uartIntFrameError, true);
}

static void uart_imx_irq_err_disable(const struct device *dev)
{
1fff92b4:	b510      	push	{r4, lr}
	UART_Type *uart = UART_STRUCT(dev);
1fff92b6:	6843      	ldr	r3, [r0, #4]

	UART_SetIntCmd(uart, uartIntParityError, false);
1fff92b8:	4906      	ldr	r1, [pc, #24]	; (1fff92d4 <uart_imx_irq_err_disable+0x20>)
	UART_Type *uart = UART_STRUCT(dev);
1fff92ba:	681c      	ldr	r4, [r3, #0]
	UART_SetIntCmd(uart, uartIntParityError, false);
1fff92bc:	2200      	movs	r2, #0
1fff92be:	4620      	mov	r0, r4
1fff92c0:	f001 f90e 	bl	1fffa4e0 <UART_SetIntCmd>
	UART_SetIntCmd(uart, uartIntFrameError, false);
1fff92c4:	4620      	mov	r0, r4
1fff92c6:	4904      	ldr	r1, [pc, #16]	; (1fff92d8 <uart_imx_irq_err_disable+0x24>)
}
1fff92c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	UART_SetIntCmd(uart, uartIntFrameError, false);
1fff92cc:	2200      	movs	r2, #0
1fff92ce:	f001 b907 	b.w	1fffa4e0 <UART_SetIntCmd>
1fff92d2:	bf00      	nop
1fff92d4:	0088000c 	.word	0x0088000c
1fff92d8:	0088000b 	.word	0x0088000b

1fff92dc <uart_imx_irq_err_enable>:
{
1fff92dc:	b510      	push	{r4, lr}
	UART_Type *uart = UART_STRUCT(dev);
1fff92de:	6843      	ldr	r3, [r0, #4]
	UART_SetIntCmd(uart, uartIntParityError, true);
1fff92e0:	4906      	ldr	r1, [pc, #24]	; (1fff92fc <uart_imx_irq_err_enable+0x20>)
	UART_Type *uart = UART_STRUCT(dev);
1fff92e2:	681c      	ldr	r4, [r3, #0]
	UART_SetIntCmd(uart, uartIntParityError, true);
1fff92e4:	2201      	movs	r2, #1
1fff92e6:	4620      	mov	r0, r4
1fff92e8:	f001 f8fa 	bl	1fffa4e0 <UART_SetIntCmd>
	UART_SetIntCmd(uart, uartIntFrameError, true);
1fff92ec:	4620      	mov	r0, r4
1fff92ee:	4904      	ldr	r1, [pc, #16]	; (1fff9300 <uart_imx_irq_err_enable+0x24>)
}
1fff92f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	UART_SetIntCmd(uart, uartIntFrameError, true);
1fff92f4:	2201      	movs	r2, #1
1fff92f6:	f001 b8f3 	b.w	1fffa4e0 <UART_SetIntCmd>
1fff92fa:	bf00      	nop
1fff92fc:	0088000c 	.word	0x0088000c
1fff9300:	0088000b 	.word	0x0088000b

1fff9304 <uart_imx_irq_rx_disable>:
	UART_Type *uart = UART_STRUCT(dev);
1fff9304:	6843      	ldr	r3, [r0, #4]
	UART_SetIntCmd(uart, uartIntRxReady, false);
1fff9306:	4902      	ldr	r1, [pc, #8]	; (1fff9310 <uart_imx_irq_rx_disable+0xc>)
1fff9308:	6818      	ldr	r0, [r3, #0]
1fff930a:	2200      	movs	r2, #0
1fff930c:	f001 b8e8 	b.w	1fffa4e0 <UART_SetIntCmd>
1fff9310:	00800009 	.word	0x00800009

1fff9314 <uart_imx_irq_rx_enable>:
	UART_Type *uart = UART_STRUCT(dev);
1fff9314:	6843      	ldr	r3, [r0, #4]
	UART_SetIntCmd(uart, uartIntRxReady, true);
1fff9316:	4902      	ldr	r1, [pc, #8]	; (1fff9320 <uart_imx_irq_rx_enable+0xc>)
1fff9318:	6818      	ldr	r0, [r3, #0]
1fff931a:	2201      	movs	r2, #1
1fff931c:	f001 b8e0 	b.w	1fffa4e0 <UART_SetIntCmd>
1fff9320:	00800009 	.word	0x00800009

1fff9324 <uart_imx_irq_tx_disable>:
	UART_Type *uart = UART_STRUCT(dev);
1fff9324:	6843      	ldr	r3, [r0, #4]
	UART_SetIntCmd(uart, uartIntTxReady, false);
1fff9326:	4902      	ldr	r1, [pc, #8]	; (1fff9330 <uart_imx_irq_tx_disable+0xc>)
1fff9328:	6818      	ldr	r0, [r3, #0]
1fff932a:	2200      	movs	r2, #0
1fff932c:	f001 b8d8 	b.w	1fffa4e0 <UART_SetIntCmd>
1fff9330:	0080000d 	.word	0x0080000d

1fff9334 <uart_imx_irq_tx_enable>:
	UART_Type *uart = UART_STRUCT(dev);
1fff9334:	6843      	ldr	r3, [r0, #4]
	UART_SetIntCmd(uart, uartIntTxReady, true);
1fff9336:	4902      	ldr	r1, [pc, #8]	; (1fff9340 <uart_imx_irq_tx_enable+0xc>)
1fff9338:	6818      	ldr	r0, [r3, #0]
1fff933a:	2201      	movs	r2, #1
1fff933c:	f001 b8d0 	b.w	1fffa4e0 <UART_SetIntCmd>
1fff9340:	0080000d 	.word	0x0080000d

1fff9344 <uart_imx_fifo_read>:
{
1fff9344:	b510      	push	{r4, lr}
	UART_Type *uart = UART_STRUCT(dev);
1fff9346:	6843      	ldr	r3, [r0, #4]
1fff9348:	6818      	ldr	r0, [r3, #0]
	while (((size - num_rx) > 0) &&
1fff934a:	2400      	movs	r4, #0
1fff934c:	4294      	cmp	r4, r2
1fff934e:	d003      	beq.n	1fff9358 <uart_imx_fifo_read+0x14>
 */
static inline bool UART_GetStatusFlag(UART_Type* base, uint32_t flag){
    volatile uint32_t* uart_reg = 0;

    uart_reg = (uint32_t *)((uint32_t)base + (flag >> 16));
    return (bool)((*uart_reg >> (flag & 0x0000FFFF)) & 0x1);
1fff9350:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
1fff9354:	059b      	lsls	r3, r3, #22
1fff9356:	d408      	bmi.n	1fff936a <uart_imx_fifo_read+0x26>
1fff9358:	f8d0 3098 	ldr.w	r3, [r0, #152]	; 0x98
	if (UART_GetStatusFlag(uart, uartStatusRxOverrun)) {
1fff935c:	079b      	lsls	r3, r3, #30
1fff935e:	d502      	bpl.n	1fff9366 <uart_imx_fifo_read+0x22>
		UART_ClearStatusFlag(uart, uartStatusRxOverrun);
1fff9360:	4904      	ldr	r1, [pc, #16]	; (1fff9374 <uart_imx_fifo_read+0x30>)
1fff9362:	f001 f8cc 	bl	1fffa4fe <UART_ClearStatusFlag>
}
1fff9366:	4620      	mov	r0, r4
1fff9368:	bd10      	pop	{r4, pc}
    return (uint8_t)(UART_URXD_REG(base) & UART_URXD_RX_DATA_MASK);
1fff936a:	6803      	ldr	r3, [r0, #0]
1fff936c:	550b      	strb	r3, [r1, r4]
1fff936e:	3401      	adds	r4, #1
1fff9370:	e7ec      	b.n	1fff934c <uart_imx_fifo_read+0x8>
1fff9372:	bf00      	nop
1fff9374:	00980001 	.word	0x00980001

1fff9378 <uart_imx_poll_in>:
{
1fff9378:	b508      	push	{r3, lr}
	UART_Type *uart = UART_STRUCT(dev);
1fff937a:	6843      	ldr	r3, [r0, #4]
1fff937c:	6818      	ldr	r0, [r3, #0]
    return (bool)((*uart_reg >> (flag & 0x0000FFFF)) & 0x1);
1fff937e:	f8d0 3098 	ldr.w	r3, [r0, #152]	; 0x98
	if (UART_GetStatusFlag(uart, uartStatusRxDataReady)) {
1fff9382:	07da      	lsls	r2, r3, #31
1fff9384:	d50b      	bpl.n	1fff939e <uart_imx_poll_in+0x26>
    return (uint8_t)(UART_URXD_REG(base) & UART_URXD_RX_DATA_MASK);
1fff9386:	6803      	ldr	r3, [r0, #0]
1fff9388:	700b      	strb	r3, [r1, #0]
    return (bool)((*uart_reg >> (flag & 0x0000FFFF)) & 0x1);
1fff938a:	f8d0 3098 	ldr.w	r3, [r0, #152]	; 0x98
		if (UART_GetStatusFlag(uart, uartStatusRxOverrun)) {
1fff938e:	079b      	lsls	r3, r3, #30
1fff9390:	d401      	bmi.n	1fff9396 <uart_imx_poll_in+0x1e>
		ret = 0;
1fff9392:	2000      	movs	r0, #0
}
1fff9394:	bd08      	pop	{r3, pc}
			UART_ClearStatusFlag(uart, uartStatusRxOverrun);
1fff9396:	4903      	ldr	r1, [pc, #12]	; (1fff93a4 <uart_imx_poll_in+0x2c>)
1fff9398:	f001 f8b1 	bl	1fffa4fe <UART_ClearStatusFlag>
1fff939c:	e7f9      	b.n	1fff9392 <uart_imx_poll_in+0x1a>
	int ret = -1;
1fff939e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	return ret;
1fff93a2:	e7f7      	b.n	1fff9394 <uart_imx_poll_in+0x1c>
1fff93a4:	00980001 	.word	0x00980001

1fff93a8 <elapsed>:
 *     - the timer reset or the last time the function was called
 *     - and until the current call of the function is completed.
 * - the function is invoked with interrupts disabled.
 */
static uint32_t elapsed(void)
{
1fff93a8:	b510      	push	{r4, lr}
	uint32_t val1 = SysTick->VAL;	/* A */
1fff93aa:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
1fff93ae:	699a      	ldr	r2, [r3, #24]
	uint32_t ctrl = SysTick->CTRL;	/* B */
1fff93b0:	6919      	ldr	r1, [r3, #16]
	uint32_t val2 = SysTick->VAL;	/* C */
1fff93b2:	6998      	ldr	r0, [r3, #24]
	 * 4) After C we'll see it next time
	 *
	 * So the count in val2 is post-wrap and last_load needs to be
	 * added if and only if COUNTFLAG is set or val1 < val2.
	 */
	if ((ctrl & SysTick_CTRL_COUNTFLAG_Msk)
1fff93b4:	4b09      	ldr	r3, [pc, #36]	; (1fff93dc <elapsed+0x34>)
1fff93b6:	f411 3f80 	tst.w	r1, #65536	; 0x10000
1fff93ba:	4909      	ldr	r1, [pc, #36]	; (1fff93e0 <elapsed+0x38>)
1fff93bc:	d101      	bne.n	1fff93c2 <elapsed+0x1a>
	    || (val1 < val2)) {
1fff93be:	4282      	cmp	r2, r0
1fff93c0:	d206      	bcs.n	1fff93d0 <elapsed+0x28>
		overflow_cyc += last_load;
1fff93c2:	681a      	ldr	r2, [r3, #0]
1fff93c4:	680c      	ldr	r4, [r1, #0]
1fff93c6:	4422      	add	r2, r4
1fff93c8:	601a      	str	r2, [r3, #0]

		/* We know there was a wrap, but we might not have
		 * seen it in CTRL, so clear it. */
		(void)SysTick->CTRL;
1fff93ca:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
1fff93ce:	6912      	ldr	r2, [r2, #16]
	}

	return (last_load - val2) + overflow_cyc;
1fff93d0:	681b      	ldr	r3, [r3, #0]
1fff93d2:	680a      	ldr	r2, [r1, #0]
1fff93d4:	4413      	add	r3, r2
}
1fff93d6:	1a18      	subs	r0, r3, r0
1fff93d8:	bd10      	pop	{r4, pc}
1fff93da:	bf00      	nop
1fff93dc:	20000120 	.word	0x20000120
1fff93e0:	2000012c 	.word	0x2000012c

1fff93e4 <sys_clock_driver_init>:
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
1fff93e4:	4b09      	ldr	r3, [pc, #36]	; (1fff940c <sys_clock_driver_init+0x28>)
1fff93e6:	2210      	movs	r2, #16
1fff93e8:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
static int sys_clock_driver_init(const struct device *dev)
{
	ARG_UNUSED(dev);

	NVIC_SetPriority(SysTick_IRQn, _IRQ_PRIO_OFFSET);
	last_load = CYC_PER_TICK - 1;
1fff93ec:	4b08      	ldr	r3, [pc, #32]	; (1fff9410 <sys_clock_driver_init+0x2c>)
1fff93ee:	f644 621f 	movw	r2, #19999	; 0x4e1f
1fff93f2:	601a      	str	r2, [r3, #0]
	overflow_cyc = 0U;
1fff93f4:	4b07      	ldr	r3, [pc, #28]	; (1fff9414 <sys_clock_driver_init+0x30>)
1fff93f6:	2000      	movs	r0, #0
1fff93f8:	6018      	str	r0, [r3, #0]
	SysTick->LOAD = last_load;
1fff93fa:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
1fff93fe:	615a      	str	r2, [r3, #20]
	SysTick->VAL = 0; /* resets timer to last_load */
1fff9400:	6198      	str	r0, [r3, #24]
	SysTick->CTRL |= (SysTick_CTRL_ENABLE_Msk |
1fff9402:	691a      	ldr	r2, [r3, #16]
1fff9404:	f042 0207 	orr.w	r2, r2, #7
1fff9408:	611a      	str	r2, [r3, #16]
			  SysTick_CTRL_TICKINT_Msk |
			  SysTick_CTRL_CLKSOURCE_Msk);
	return 0;
}
1fff940a:	4770      	bx	lr
1fff940c:	e000ed00 	.word	0xe000ed00
1fff9410:	2000012c 	.word	0x2000012c
1fff9414:	20000120 	.word	0x20000120

1fff9418 <sys_clock_isr>:
{
1fff9418:	b508      	push	{r3, lr}
	elapsed();
1fff941a:	f7ff ffc5 	bl	1fff93a8 <elapsed>
	cycle_count += overflow_cyc;
1fff941e:	4b0c      	ldr	r3, [pc, #48]	; (1fff9450 <sys_clock_isr+0x38>)
1fff9420:	4a0c      	ldr	r2, [pc, #48]	; (1fff9454 <sys_clock_isr+0x3c>)
1fff9422:	6818      	ldr	r0, [r3, #0]
1fff9424:	6811      	ldr	r1, [r2, #0]
1fff9426:	4408      	add	r0, r1
1fff9428:	6010      	str	r0, [r2, #0]
	overflow_cyc = 0;
1fff942a:	2200      	movs	r2, #0
1fff942c:	601a      	str	r2, [r3, #0]
		dticks = (cycle_count - announced_cycles) / CYC_PER_TICK;
1fff942e:	4a0a      	ldr	r2, [pc, #40]	; (1fff9458 <sys_clock_isr+0x40>)
1fff9430:	6813      	ldr	r3, [r2, #0]
1fff9432:	f644 6120 	movw	r1, #20000	; 0x4e20
1fff9436:	1ac0      	subs	r0, r0, r3
1fff9438:	fbb0 f0f1 	udiv	r0, r0, r1
		announced_cycles += dticks * CYC_PER_TICK;
1fff943c:	fb01 3300 	mla	r3, r1, r0, r3
1fff9440:	6013      	str	r3, [r2, #0]
		sys_clock_announce(dticks);
1fff9442:	f000 fdfd 	bl	1fffa040 <sys_clock_announce>
}
1fff9446:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
1fff944a:	f7ff bd85 	b.w	1fff8f58 <z_arm_exc_exit>
1fff944e:	bf00      	nop
1fff9450:	20000120 	.word	0x20000120
1fff9454:	20000128 	.word	0x20000128
1fff9458:	20000124 	.word	0x20000124

1fff945c <sys_clock_set_timeout>:
{
1fff945c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
1fff9460:	4e32      	ldr	r6, [pc, #200]	; (1fff952c <sys_clock_set_timeout+0xd0>)
	if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && idle && ticks == K_TICKS_FOREVER) {
1fff9462:	2900      	cmp	r1, #0
1fff9464:	d055      	beq.n	1fff9512 <sys_clock_set_timeout+0xb6>
1fff9466:	1c42      	adds	r2, r0, #1
1fff9468:	d10a      	bne.n	1fff9480 <sys_clock_set_timeout+0x24>
		SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
1fff946a:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
1fff946e:	6913      	ldr	r3, [r2, #16]
1fff9470:	f023 0301 	bic.w	r3, r3, #1
1fff9474:	6113      	str	r3, [r2, #16]
		last_load = TIMER_STOPPED;
1fff9476:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
1fff947a:	6033      	str	r3, [r6, #0]
}
1fff947c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uint32_t last_load_ = last_load;
1fff9480:	6835      	ldr	r5, [r6, #0]
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
1fff9482:	2801      	cmp	r0, #1
1fff9484:	dd4b      	ble.n	1fff951e <sys_clock_set_timeout+0xc2>
1fff9486:	f240 3845 	movw	r8, #837	; 0x345
1fff948a:	4540      	cmp	r0, r8
1fff948c:	dc01      	bgt.n	1fff9492 <sys_clock_set_timeout+0x36>
1fff948e:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
	__asm__ volatile(
1fff9492:	f04f 0310 	mov.w	r3, #16
1fff9496:	f3ef 8411 	mrs	r4, BASEPRI
1fff949a:	f383 8812 	msr	BASEPRI_MAX, r3
1fff949e:	f3bf 8f6f 	isb	sy
	uint32_t pending = elapsed();
1fff94a2:	f7ff ff81 	bl	1fff93a8 <elapsed>
	cycle_count += pending;
1fff94a6:	4f22      	ldr	r7, [pc, #136]	; (1fff9530 <sys_clock_set_timeout+0xd4>)
	val1 = SysTick->VAL;
1fff94a8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
	overflow_cyc = 0U;
1fff94ac:	2100      	movs	r1, #0
	val1 = SysTick->VAL;
1fff94ae:	f8d3 c018 	ldr.w	ip, [r3, #24]
	cycle_count += pending;
1fff94b2:	683b      	ldr	r3, [r7, #0]
1fff94b4:	18c2      	adds	r2, r0, r3
	overflow_cyc = 0U;
1fff94b6:	4b1f      	ldr	r3, [pc, #124]	; (1fff9534 <sys_clock_set_timeout+0xd8>)
1fff94b8:	6019      	str	r1, [r3, #0]
	uint32_t unannounced = cycle_count - announced_cycles;
1fff94ba:	4b1f      	ldr	r3, [pc, #124]	; (1fff9538 <sys_clock_set_timeout+0xdc>)
1fff94bc:	681b      	ldr	r3, [r3, #0]
	if ((int32_t)unannounced < 0) {
1fff94be:	1ad1      	subs	r1, r2, r3
1fff94c0:	d430      	bmi.n	1fff9524 <sys_clock_set_timeout+0xc8>
		delay = ticks * CYC_PER_TICK;
1fff94c2:	f644 6020 	movw	r0, #20000	; 0x4e20
		delay += unannounced;
1fff94c6:	fb00 1108 	mla	r1, r0, r8, r1
		 ((delay + CYC_PER_TICK - 1) / CYC_PER_TICK) * CYC_PER_TICK;
1fff94ca:	f501 419c 	add.w	r1, r1, #19968	; 0x4e00
		delay -= unannounced;
1fff94ce:	1a9b      	subs	r3, r3, r2
		 ((delay + CYC_PER_TICK - 1) / CYC_PER_TICK) * CYC_PER_TICK;
1fff94d0:	311f      	adds	r1, #31
1fff94d2:	fbb1 f1f0 	udiv	r1, r1, r0
		delay -= unannounced;
1fff94d6:	fb00 3301 	mla	r3, r0, r1, r3
		delay = MAX(delay, MIN_DELAY);
1fff94da:	f240 41e2 	movw	r1, #1250	; 0x4e2
1fff94de:	428b      	cmp	r3, r1
1fff94e0:	d920      	bls.n	1fff9524 <sys_clock_set_timeout+0xc8>
		if (delay > MAX_CYCLES) {
1fff94e2:	4916      	ldr	r1, [pc, #88]	; (1fff953c <sys_clock_set_timeout+0xe0>)
1fff94e4:	428b      	cmp	r3, r1
1fff94e6:	bf28      	it	cs
1fff94e8:	460b      	movcs	r3, r1
	val2 = SysTick->VAL;
1fff94ea:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
		last_load = MIN_DELAY;
1fff94ee:	6033      	str	r3, [r6, #0]
	val2 = SysTick->VAL;
1fff94f0:	6988      	ldr	r0, [r1, #24]
	SysTick->LOAD = last_load - 1;
1fff94f2:	3b01      	subs	r3, #1
1fff94f4:	614b      	str	r3, [r1, #20]
	SysTick->VAL = 0; /* resets timer to last_load */
1fff94f6:	2300      	movs	r3, #0
1fff94f8:	618b      	str	r3, [r1, #24]
	if (val1 < val2) {
1fff94fa:	4584      	cmp	ip, r0
1fff94fc:	ebac 0300 	sub.w	r3, ip, r0
		cycle_count += (val1 + (last_load_ - val2));
1fff9500:	bf38      	it	cc
1fff9502:	195b      	addcc	r3, r3, r5
		cycle_count += (val1 - val2);
1fff9504:	441a      	add	r2, r3
1fff9506:	603a      	str	r2, [r7, #0]
	__asm__ volatile(
1fff9508:	f384 8811 	msr	BASEPRI, r4
1fff950c:	f3bf 8f6f 	isb	sy
1fff9510:	e7b4      	b.n	1fff947c <sys_clock_set_timeout+0x20>
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
1fff9512:	1c43      	adds	r3, r0, #1
	uint32_t last_load_ = last_load;
1fff9514:	6835      	ldr	r5, [r6, #0]
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
1fff9516:	d1b4      	bne.n	1fff9482 <sys_clock_set_timeout+0x26>
1fff9518:	f240 3045 	movw	r0, #837	; 0x345
1fff951c:	e7b7      	b.n	1fff948e <sys_clock_set_timeout+0x32>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
1fff951e:	f04f 0800 	mov.w	r8, #0
1fff9522:	e7b6      	b.n	1fff9492 <sys_clock_set_timeout+0x36>
1fff9524:	f240 43e2 	movw	r3, #1250	; 0x4e2
1fff9528:	e7df      	b.n	1fff94ea <sys_clock_set_timeout+0x8e>
1fff952a:	bf00      	nop
1fff952c:	2000012c 	.word	0x2000012c
1fff9530:	20000128 	.word	0x20000128
1fff9534:	20000120 	.word	0x20000120
1fff9538:	20000124 	.word	0x20000124
1fff953c:	00ff6ea0 	.word	0x00ff6ea0

1fff9540 <sys_clock_elapsed>:
{
1fff9540:	b510      	push	{r4, lr}
	__asm__ volatile(
1fff9542:	f04f 0310 	mov.w	r3, #16
1fff9546:	f3ef 8411 	mrs	r4, BASEPRI
1fff954a:	f383 8812 	msr	BASEPRI_MAX, r3
1fff954e:	f3bf 8f6f 	isb	sy
	uint32_t cyc = elapsed() + cycle_count - announced_cycles;
1fff9552:	f7ff ff29 	bl	1fff93a8 <elapsed>
1fff9556:	4b07      	ldr	r3, [pc, #28]	; (1fff9574 <sys_clock_elapsed+0x34>)
1fff9558:	4a07      	ldr	r2, [pc, #28]	; (1fff9578 <sys_clock_elapsed+0x38>)
1fff955a:	681b      	ldr	r3, [r3, #0]
1fff955c:	6812      	ldr	r2, [r2, #0]
1fff955e:	1a9b      	subs	r3, r3, r2
1fff9560:	4403      	add	r3, r0
	__asm__ volatile(
1fff9562:	f384 8811 	msr	BASEPRI, r4
1fff9566:	f3bf 8f6f 	isb	sy
}
1fff956a:	f644 6020 	movw	r0, #20000	; 0x4e20
1fff956e:	fbb3 f0f0 	udiv	r0, r3, r0
1fff9572:	bd10      	pop	{r4, pc}
1fff9574:	20000128 	.word	0x20000128
1fff9578:	20000124 	.word	0x20000124

1fff957c <CCM_UpdateRoot>:
 * Function Name : CCM_UpdateRoot
 * Description   : Update clock root in one step, for dynamical clock switching
 *
 *END**************************************************************************/
void CCM_UpdateRoot(CCM_Type * base, uint32_t ccmRoot, uint32_t mux, uint32_t pre, uint32_t post)
{
1fff957c:	b510      	push	{r4, lr}
    assert (pre < 8);
    assert (post < 64);

    CCM_REG(ccmRoot) = (CCM_REG(ccmRoot) &
                        (~(CCM_TARGET_ROOT_MUX_MASK | CCM_TARGET_ROOT_PRE_PODF_MASK | CCM_TARGET_ROOT_POST_PODF_MASK))) |
                       CCM_TARGET_ROOT_MUX(mux) | CCM_TARGET_ROOT_PRE_PODF(pre) | CCM_TARGET_ROOT_POST_PODF(post);
1fff957e:	9802      	ldr	r0, [sp, #8]
    CCM_REG(ccmRoot) = (CCM_REG(ccmRoot) &
1fff9580:	680c      	ldr	r4, [r1, #0]
                       CCM_TARGET_ROOT_MUX(mux) | CCM_TARGET_ROOT_PRE_PODF(pre) | CCM_TARGET_ROOT_POST_PODF(post);
1fff9582:	041b      	lsls	r3, r3, #16
1fff9584:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
1fff9588:	f000 003f 	and.w	r0, r0, #63	; 0x3f
1fff958c:	0612      	lsls	r2, r2, #24
1fff958e:	f002 62e0 	and.w	r2, r2, #117440512	; 0x7000000
1fff9592:	4303      	orrs	r3, r0
1fff9594:	4313      	orrs	r3, r2
    CCM_REG(ccmRoot) = (CCM_REG(ccmRoot) &
1fff9596:	4a02      	ldr	r2, [pc, #8]	; (1fff95a0 <CCM_UpdateRoot+0x24>)
1fff9598:	4022      	ands	r2, r4
                       CCM_TARGET_ROOT_MUX(mux) | CCM_TARGET_ROOT_PRE_PODF(pre) | CCM_TARGET_ROOT_POST_PODF(post);
1fff959a:	4313      	orrs	r3, r2
    CCM_REG(ccmRoot) = (CCM_REG(ccmRoot) &
1fff959c:	600b      	str	r3, [r1, #0]
}
1fff959e:	bd10      	pop	{r4, pc}
1fff95a0:	f8f8ffc0 	.word	0xf8f8ffc0

1fff95a4 <CCM_ANALOG_GetSysPllFreq>:
 *         - true: The PLL is bypassed.
 *         - false: The PLL is not bypassed.
 */
static inline bool CCM_ANALOG_IsPllBypassed(CCM_ANALOG_Type * base, uint32_t pllControl)
{
    return (bool)(CCM_ANALOG_TUPLE_REG(base, pllControl) & CCM_ANALOG_PLL_ARM_BYPASS_MASK);
1fff95a4:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
 * Description   : Get system PLL frequency
 *
 *END**************************************************************************/
uint32_t CCM_ANALOG_GetSysPllFreq(CCM_ANALOG_Type * base)
{
    if (CCM_ANALOG_IsPllBypassed(base, ccmAnalogPll480Control))
1fff95a8:	03db      	lsls	r3, r3, #15
1fff95aa:	d409      	bmi.n	1fff95c0 <CCM_ANALOG_GetSysPllFreq+0x1c>
        return 24000000ul;

    if (CCM_ANALOG_PLL_480 & CCM_ANALOG_PLL_480_DIV_SELECT_MASK)
1fff95ac:	4b05      	ldr	r3, [pc, #20]	; (1fff95c4 <CCM_ANALOG_GetSysPllFreq+0x20>)
        return 528000000ul;
1fff95ae:	4806      	ldr	r0, [pc, #24]	; (1fff95c8 <CCM_ANALOG_GetSysPllFreq+0x24>)
    if (CCM_ANALOG_PLL_480 & CCM_ANALOG_PLL_480_DIV_SELECT_MASK)
1fff95b0:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
        return 528000000ul;
1fff95b4:	f013 0f01 	tst.w	r3, #1
1fff95b8:	4b04      	ldr	r3, [pc, #16]	; (1fff95cc <CCM_ANALOG_GetSysPllFreq+0x28>)
1fff95ba:	bf18      	it	ne
1fff95bc:	4618      	movne	r0, r3
1fff95be:	4770      	bx	lr
        return 24000000ul;
1fff95c0:	4803      	ldr	r0, [pc, #12]	; (1fff95d0 <CCM_ANALOG_GetSysPllFreq+0x2c>)
    else
        return 480000000ul;
}
1fff95c2:	4770      	bx	lr
1fff95c4:	30360000 	.word	0x30360000
1fff95c8:	1c9c3800 	.word	0x1c9c3800
1fff95cc:	1f78a400 	.word	0x1f78a400
1fff95d0:	016e3600 	.word	0x016e3600

1fff95d4 <UART_SetBaudRate>:
    uint32_t refFreqDiv;
    uint32_t divider = 1;

    /* get the approximately maximum divisor */
    numerator = clockRate;
    denominator = baudRate << 4;
1fff95d4:	0113      	lsls	r3, r2, #4
{
1fff95d6:	b5f0      	push	{r4, r5, r6, r7, lr}
    numerator = clockRate;
1fff95d8:	460a      	mov	r2, r1
    denominator = baudRate << 4;
1fff95da:	461c      	mov	r4, r3
    divisor = 1;
1fff95dc:	2501      	movs	r5, #1

    while (denominator != 0)
1fff95de:	2c00      	cmp	r4, #0
1fff95e0:	d147      	bne.n	1fff9672 <UART_SetBaudRate+0x9e>
        divisor = denominator;
        denominator = numerator % denominator;
        numerator = divisor;
    }

    numerator = clockRate / divisor;
1fff95e2:	fbb1 f4f5 	udiv	r4, r1, r5
    denominator = (baudRate << 4) / divisor;
1fff95e6:	fbb3 f3f5 	udiv	r3, r3, r5

    /* numerator ranges from 1 ~ 7 * 64k */
    /* denominator ranges from 1 ~ 64k */
    if ((numerator > (UART_UBIR_INC_MASK * 7)) ||
1fff95ea:	4f2f      	ldr	r7, [pc, #188]	; (1fff96a8 <UART_SetBaudRate+0xd4>)
1fff95ec:	42bc      	cmp	r4, r7
1fff95ee:	f103 35ff 	add.w	r5, r3, #4294967295	; 0xffffffff
1fff95f2:	f104 36ff 	add.w	r6, r4, #4294967295	; 0xffffffff
1fff95f6:	d944      	bls.n	1fff9682 <UART_SetBaudRate+0xae>
        (denominator > UART_UBIR_INC_MASK))
    {
        uint32_t m = (numerator - 1) / (UART_UBIR_INC_MASK * 7) + 1;
1fff95f8:	fbb6 f6f7 	udiv	r6, r6, r7
        uint32_t n = (denominator - 1) / UART_UBIR_INC_MASK + 1;
1fff95fc:	f64f 72ff 	movw	r2, #65535	; 0xffff
        uint32_t m = (numerator - 1) / (UART_UBIR_INC_MASK * 7) + 1;
1fff9600:	3601      	adds	r6, #1
        uint32_t n = (denominator - 1) / UART_UBIR_INC_MASK + 1;
1fff9602:	fbb5 f5f2 	udiv	r5, r5, r2
1fff9606:	1c6a      	adds	r2, r5, #1
        uint32_t max = m > n ? m : n;
1fff9608:	42b2      	cmp	r2, r6
1fff960a:	bf38      	it	cc
1fff960c:	4632      	movcc	r2, r6
        numerator /= max;
1fff960e:	fbb4 f4f2 	udiv	r4, r4, r2
        denominator /= max;
        if (0 == numerator)
            numerator = 1;
        if (0 == denominator)
1fff9612:	4293      	cmp	r3, r2
            denominator = 1;
1fff9614:	bf34      	ite	cc
1fff9616:	2301      	movcc	r3, #1
        denominator /= max;
1fff9618:	fbb3 f3f2 	udivcs	r3, r3, r2
    }
    divider = (numerator - 1) / UART_UBIR_INC_MASK + 1;
1fff961c:	f64f 75ff 	movw	r5, #65535	; 0xffff
1fff9620:	1e62      	subs	r2, r4, #1
1fff9622:	fbb2 f2f5 	udiv	r2, r2, r5
1fff9626:	1c55      	adds	r5, r2, #1

    switch (divider)
1fff9628:	3a01      	subs	r2, #1
1fff962a:	2a05      	cmp	r2, #5
1fff962c:	bf9c      	itt	ls
1fff962e:	4e1f      	ldrls	r6, [pc, #124]	; (1fff96ac <UART_SetBaudRate+0xd8>)
1fff9630:	5cb6      	ldrbls	r6, [r6, r2]
            break;
        default:
        refFreqDiv = 0x05;
    }

    UART_UFCR_REG(base) &= ~UART_UFCR_RFDIV_MASK;
1fff9632:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
1fff9636:	f422 7260 	bic.w	r2, r2, #896	; 0x380
1fff963a:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
    UART_UFCR_REG(base) |= UART_UFCR_RFDIV(refFreqDiv);
1fff963e:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
    divider = (numerator - 1) / UART_UBIR_INC_MASK + 1;
1fff9642:	bf88      	it	hi
1fff9644:	2605      	movhi	r6, #5
    UART_UFCR_REG(base) |= UART_UFCR_RFDIV(refFreqDiv);
1fff9646:	ea42 12c6 	orr.w	r2, r2, r6, lsl #7
1fff964a:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
    UART_UBIR_REG(base) = UART_UBIR_INC(denominator - 1);
1fff964e:	1e5a      	subs	r2, r3, #1
    UART_UBMR_REG(base) = UART_UBMR_MOD(numerator / divider - 1);
1fff9650:	fbb4 f3f5 	udiv	r3, r4, r5
1fff9654:	3b01      	subs	r3, #1
1fff9656:	b29b      	uxth	r3, r3
    UART_UBIR_REG(base) = UART_UBIR_INC(denominator - 1);
1fff9658:	b292      	uxth	r2, r2
1fff965a:	f8c0 20a4 	str.w	r2, [r0, #164]	; 0xa4
    UART_UBMR_REG(base) = UART_UBMR_MOD(numerator / divider - 1);
1fff965e:	f8c0 30a8 	str.w	r3, [r0, #168]	; 0xa8
    UART_ONEMS_REG(base) = UART_ONEMS_ONEMS(clockRate/(1000 * divider));
1fff9662:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
1fff9666:	435d      	muls	r5, r3
1fff9668:	fbb1 f1f5 	udiv	r1, r1, r5
1fff966c:	f8c0 10b0 	str.w	r1, [r0, #176]	; 0xb0
}
1fff9670:	bdf0      	pop	{r4, r5, r6, r7, pc}
        denominator = numerator % denominator;
1fff9672:	fbb2 f6f4 	udiv	r6, r2, r4
1fff9676:	fb04 2616 	mls	r6, r4, r6, r2
1fff967a:	4625      	mov	r5, r4
1fff967c:	4622      	mov	r2, r4
1fff967e:	4634      	mov	r4, r6
1fff9680:	e7ad      	b.n	1fff95de <UART_SetBaudRate+0xa>
    if ((numerator > (UART_UBIR_INC_MASK * 7)) ||
1fff9682:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
1fff9686:	d3c9      	bcc.n	1fff961c <UART_SetBaudRate+0x48>
        uint32_t m = (numerator - 1) / (UART_UBIR_INC_MASK * 7) + 1;
1fff9688:	fbb6 f6f7 	udiv	r6, r6, r7
1fff968c:	1c72      	adds	r2, r6, #1
        uint32_t n = (denominator - 1) / UART_UBIR_INC_MASK + 1;
1fff968e:	f64f 76ff 	movw	r6, #65535	; 0xffff
1fff9692:	fbb5 f5f6 	udiv	r5, r5, r6
1fff9696:	3501      	adds	r5, #1
        uint32_t max = m > n ? m : n;
1fff9698:	42aa      	cmp	r2, r5
1fff969a:	bf38      	it	cc
1fff969c:	462a      	movcc	r2, r5
        if (0 == numerator)
1fff969e:	4294      	cmp	r4, r2
1fff96a0:	d2b5      	bcs.n	1fff960e <UART_SetBaudRate+0x3a>
            numerator = 1;
1fff96a2:	2401      	movs	r4, #1
1fff96a4:	e7b5      	b.n	1fff9612 <UART_SetBaudRate+0x3e>
1fff96a6:	bf00      	nop
1fff96a8:	0006fff9 	.word	0x0006fff9
1fff96ac:	1fffabc1 	.word	0x1fffabc1

1fff96b0 <get_uart_clock_freq>:
{
	uint32_t root;
	uint32_t hz;
	uint32_t pre, post;

	switch ((uint32_t)base) {
1fff96b0:	4b3b      	ldr	r3, [pc, #236]	; (1fff97a0 <get_uart_clock_freq+0xf0>)
1fff96b2:	4298      	cmp	r0, r3
{
1fff96b4:	b513      	push	{r0, r1, r4, lr}
	switch ((uint32_t)base) {
1fff96b6:	d046      	beq.n	1fff9746 <get_uart_clock_freq+0x96>
1fff96b8:	d80e      	bhi.n	1fff96d8 <get_uart_clock_freq+0x28>
1fff96ba:	f5a3 13f0 	sub.w	r3, r3, #1966080	; 0x1e0000
1fff96be:	4298      	cmp	r0, r3
1fff96c0:	d038      	beq.n	1fff9734 <get_uart_clock_freq+0x84>
1fff96c2:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
1fff96c6:	4298      	cmp	r0, r3
1fff96c8:	d02d      	beq.n	1fff9726 <get_uart_clock_freq+0x76>
1fff96ca:	f5a3 3340 	sub.w	r3, r3, #196608	; 0x30000
1fff96ce:	4298      	cmp	r0, r3
1fff96d0:	d016      	beq.n	1fff9700 <get_uart_clock_freq+0x50>
	case UART7_BASE:
		root = CCM_GetRootMux(CCM, ccmRootUart7);
		CCM_GetRootDivider(CCM, ccmRootUart7, &pre, &post);
		break;
	default:
		return 0;
1fff96d2:	2000      	movs	r0, #0
	default:
		return 0;
	}

	return hz / (pre + 1) / (post + 1);
}
1fff96d4:	b002      	add	sp, #8
1fff96d6:	bd10      	pop	{r4, pc}
	switch ((uint32_t)base) {
1fff96d8:	4b32      	ldr	r3, [pc, #200]	; (1fff97a4 <get_uart_clock_freq+0xf4>)
1fff96da:	4298      	cmp	r0, r3
1fff96dc:	d03c      	beq.n	1fff9758 <get_uart_clock_freq+0xa8>
1fff96de:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
1fff96e2:	4298      	cmp	r0, r3
1fff96e4:	d041      	beq.n	1fff976a <get_uart_clock_freq+0xba>
1fff96e6:	f5a3 3300 	sub.w	r3, r3, #131072	; 0x20000
1fff96ea:	4298      	cmp	r0, r3
1fff96ec:	d1f1      	bne.n	1fff96d2 <get_uart_clock_freq+0x22>
    return (CCM_REG(ccmRoot) & CCM_TARGET_ROOT_MUX_MASK) >> CCM_TARGET_ROOT_MUX_SHIFT;
1fff96ee:	4b2e      	ldr	r3, [pc, #184]	; (1fff97a8 <get_uart_clock_freq+0xf8>)
		CCM_GetRootDivider(CCM, ccmRootUart5, &pre, &post);
1fff96f0:	492e      	ldr	r1, [pc, #184]	; (1fff97ac <get_uart_clock_freq+0xfc>)
1fff96f2:	f8d3 4180 	ldr.w	r4, [r3, #384]	; 0x180
1fff96f6:	466a      	mov	r2, sp
1fff96f8:	f3c4 6402 	ubfx	r4, r4, #24, #3
1fff96fc:	ab01      	add	r3, sp, #4
1fff96fe:	e007      	b.n	1fff9710 <get_uart_clock_freq+0x60>
1fff9700:	4b2b      	ldr	r3, [pc, #172]	; (1fff97b0 <get_uart_clock_freq+0x100>)
		CCM_GetRootDivider(CCM, ccmRootUart1, &pre, &post);
1fff9702:	492c      	ldr	r1, [pc, #176]	; (1fff97b4 <get_uart_clock_freq+0x104>)
1fff9704:	f8d3 4f80 	ldr.w	r4, [r3, #3968]	; 0xf80
1fff9708:	466a      	mov	r2, sp
1fff970a:	f3c4 6402 	ubfx	r4, r4, #24, #3
1fff970e:	ab01      	add	r3, sp, #4
		CCM_GetRootDivider(CCM, ccmRootUart7, &pre, &post);
1fff9710:	4829      	ldr	r0, [pc, #164]	; (1fff97b8 <get_uart_clock_freq+0x108>)
1fff9712:	f000 fe8a 	bl	1fffa42a <CCM_GetRootDivider>
	switch (root) {
1fff9716:	2c01      	cmp	r4, #1
1fff9718:	d030      	beq.n	1fff977c <get_uart_clock_freq+0xcc>
1fff971a:	2c04      	cmp	r4, #4
1fff971c:	d03b      	beq.n	1fff9796 <get_uart_clock_freq+0xe6>
1fff971e:	2c00      	cmp	r4, #0
1fff9720:	d1d7      	bne.n	1fff96d2 <get_uart_clock_freq+0x22>
1fff9722:	4826      	ldr	r0, [pc, #152]	; (1fff97bc <get_uart_clock_freq+0x10c>)
1fff9724:	e02e      	b.n	1fff9784 <get_uart_clock_freq+0xd4>
1fff9726:	4920      	ldr	r1, [pc, #128]	; (1fff97a8 <get_uart_clock_freq+0xf8>)
1fff9728:	680c      	ldr	r4, [r1, #0]
		CCM_GetRootDivider(CCM, ccmRootUart2, &pre, &post);
1fff972a:	ab01      	add	r3, sp, #4
1fff972c:	f3c4 6402 	ubfx	r4, r4, #24, #3
1fff9730:	466a      	mov	r2, sp
1fff9732:	e7ed      	b.n	1fff9710 <get_uart_clock_freq+0x60>
1fff9734:	4b1c      	ldr	r3, [pc, #112]	; (1fff97a8 <get_uart_clock_freq+0xf8>)
		CCM_GetRootDivider(CCM, ccmRootUart3, &pre, &post);
1fff9736:	4922      	ldr	r1, [pc, #136]	; (1fff97c0 <get_uart_clock_freq+0x110>)
1fff9738:	f8d3 4080 	ldr.w	r4, [r3, #128]	; 0x80
1fff973c:	466a      	mov	r2, sp
1fff973e:	f3c4 6402 	ubfx	r4, r4, #24, #3
1fff9742:	ab01      	add	r3, sp, #4
1fff9744:	e7e4      	b.n	1fff9710 <get_uart_clock_freq+0x60>
1fff9746:	4b18      	ldr	r3, [pc, #96]	; (1fff97a8 <get_uart_clock_freq+0xf8>)
		CCM_GetRootDivider(CCM, ccmRootUart4, &pre, &post);
1fff9748:	491e      	ldr	r1, [pc, #120]	; (1fff97c4 <get_uart_clock_freq+0x114>)
1fff974a:	f8d3 4100 	ldr.w	r4, [r3, #256]	; 0x100
1fff974e:	466a      	mov	r2, sp
1fff9750:	f3c4 6402 	ubfx	r4, r4, #24, #3
1fff9754:	ab01      	add	r3, sp, #4
1fff9756:	e7db      	b.n	1fff9710 <get_uart_clock_freq+0x60>
1fff9758:	4b13      	ldr	r3, [pc, #76]	; (1fff97a8 <get_uart_clock_freq+0xf8>)
		CCM_GetRootDivider(CCM, ccmRootUart6, &pre, &post);
1fff975a:	491b      	ldr	r1, [pc, #108]	; (1fff97c8 <get_uart_clock_freq+0x118>)
1fff975c:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
1fff9760:	466a      	mov	r2, sp
1fff9762:	f3c4 6402 	ubfx	r4, r4, #24, #3
1fff9766:	ab01      	add	r3, sp, #4
1fff9768:	e7d2      	b.n	1fff9710 <get_uart_clock_freq+0x60>
1fff976a:	4b0f      	ldr	r3, [pc, #60]	; (1fff97a8 <get_uart_clock_freq+0xf8>)
		CCM_GetRootDivider(CCM, ccmRootUart7, &pre, &post);
1fff976c:	4917      	ldr	r1, [pc, #92]	; (1fff97cc <get_uart_clock_freq+0x11c>)
1fff976e:	f8d3 4280 	ldr.w	r4, [r3, #640]	; 0x280
1fff9772:	466a      	mov	r2, sp
1fff9774:	f3c4 6402 	ubfx	r4, r4, #24, #3
1fff9778:	ab01      	add	r3, sp, #4
1fff977a:	e7c9      	b.n	1fff9710 <get_uart_clock_freq+0x60>
		hz = CCM_ANALOG_GetSysPllFreq(CCM_ANALOG) >> 1;
1fff977c:	4814      	ldr	r0, [pc, #80]	; (1fff97d0 <get_uart_clock_freq+0x120>)
1fff977e:	f7ff ff11 	bl	1fff95a4 <CCM_ANALOG_GetSysPllFreq>
1fff9782:	0840      	lsrs	r0, r0, #1
	return hz / (pre + 1) / (post + 1);
1fff9784:	9b00      	ldr	r3, [sp, #0]
1fff9786:	3301      	adds	r3, #1
1fff9788:	fbb0 f0f3 	udiv	r0, r0, r3
1fff978c:	9b01      	ldr	r3, [sp, #4]
1fff978e:	3301      	adds	r3, #1
1fff9790:	fbb0 f0f3 	udiv	r0, r0, r3
1fff9794:	e79e      	b.n	1fff96d4 <get_uart_clock_freq+0x24>
		hz = CCM_ANALOG_GetSysPllFreq(CCM_ANALOG);
1fff9796:	480e      	ldr	r0, [pc, #56]	; (1fff97d0 <get_uart_clock_freq+0x120>)
1fff9798:	f7ff ff04 	bl	1fff95a4 <CCM_ANALOG_GetSysPllFreq>
		break;
1fff979c:	e7f2      	b.n	1fff9784 <get_uart_clock_freq+0xd4>
1fff979e:	bf00      	nop
1fff97a0:	30a60000 	.word	0x30a60000
1fff97a4:	30a80000 	.word	0x30a80000
1fff97a8:	3038b000 	.word	0x3038b000
1fff97ac:	3038b180 	.word	0x3038b180
1fff97b0:	3038a000 	.word	0x3038a000
1fff97b4:	3038af80 	.word	0x3038af80
1fff97b8:	30380000 	.word	0x30380000
1fff97bc:	016e3600 	.word	0x016e3600
1fff97c0:	3038b080 	.word	0x3038b080
1fff97c4:	3038b100 	.word	0x3038b100
1fff97c8:	3038b200 	.word	0x3038b200
1fff97cc:	3038b280 	.word	0x3038b280
1fff97d0:	30360000 	.word	0x30360000

1fff97d4 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
1fff97d4:	4b0f      	ldr	r3, [pc, #60]	; (1fff9814 <z_sys_init_run_level+0x40>)
{
1fff97d6:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
1fff97d8:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
1fff97dc:	3001      	adds	r0, #1
1fff97de:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
1fff97e2:	42a6      	cmp	r6, r4
1fff97e4:	d800      	bhi.n	1fff97e8 <z_sys_init_run_level+0x14>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
1fff97e6:	bd70      	pop	{r4, r5, r6, pc}
		int rc = entry->init(dev);
1fff97e8:	e9d4 3500 	ldrd	r3, r5, [r4]
1fff97ec:	4628      	mov	r0, r5
1fff97ee:	4798      	blx	r3
		if (dev != NULL) {
1fff97f0:	b16d      	cbz	r5, 1fff980e <z_sys_init_run_level+0x3a>
			if (rc != 0) {
1fff97f2:	b138      	cbz	r0, 1fff9804 <z_sys_init_run_level+0x30>
				if (rc < 0) {
1fff97f4:	2800      	cmp	r0, #0
1fff97f6:	bfb8      	it	lt
1fff97f8:	4240      	neglt	r0, r0
				dev->state->init_res = rc;
1fff97fa:	68eb      	ldr	r3, [r5, #12]
				if (rc > UINT8_MAX) {
1fff97fc:	28ff      	cmp	r0, #255	; 0xff
1fff97fe:	bfa8      	it	ge
1fff9800:	20ff      	movge	r0, #255	; 0xff
				dev->state->init_res = rc;
1fff9802:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
1fff9804:	68ea      	ldr	r2, [r5, #12]
1fff9806:	7853      	ldrb	r3, [r2, #1]
1fff9808:	f043 0301 	orr.w	r3, r3, #1
1fff980c:	7053      	strb	r3, [r2, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
1fff980e:	3408      	adds	r4, #8
1fff9810:	e7e7      	b.n	1fff97e2 <z_sys_init_run_level+0xe>
1fff9812:	bf00      	nop
1fff9814:	1fffab84 	.word	0x1fffab84

1fff9818 <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
1fff9818:	b508      	push	{r3, lr}
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
1fff981a:	4b0a      	ldr	r3, [pc, #40]	; (1fff9844 <bg_thread_main+0x2c>)
1fff981c:	2201      	movs	r2, #1

	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
1fff981e:	2003      	movs	r0, #3
	z_sys_post_kernel = true;
1fff9820:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
1fff9822:	f7ff ffd7 	bl	1fff97d4 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
1fff9826:	f000 fc75 	bl	1fffa114 <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
1fff982a:	2004      	movs	r0, #4
1fff982c:	f7ff ffd2 	bl	1fff97d4 <z_sys_init_run_level>

	z_init_static_threads();
1fff9830:	f000 f8dc 	bl	1fff99ec <z_init_static_threads>
	extern int main(void);
#else
	extern void main(void);
#endif

	(void)main();
1fff9834:	f000 fc75 	bl	1fffa122 <main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
1fff9838:	4a03      	ldr	r2, [pc, #12]	; (1fff9848 <bg_thread_main+0x30>)
1fff983a:	7b13      	ldrb	r3, [r2, #12]
1fff983c:	f023 0301 	bic.w	r3, r3, #1
1fff9840:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
1fff9842:	bd08      	pop	{r3, pc}
1fff9844:	20000160 	.word	0x20000160
1fff9848:	20000088 	.word	0x20000088

1fff984c <z_bss_zero>:
{
1fff984c:	b508      	push	{r3, lr}
	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
1fff984e:	4803      	ldr	r0, [pc, #12]	; (1fff985c <z_bss_zero+0x10>)
1fff9850:	4a03      	ldr	r2, [pc, #12]	; (1fff9860 <z_bss_zero+0x14>)
1fff9852:	2100      	movs	r1, #0
1fff9854:	1a12      	subs	r2, r2, r0
1fff9856:	f000 fe96 	bl	1fffa586 <z_early_memset>
}
1fff985a:	bd08      	pop	{r3, pc}
1fff985c:	20000018 	.word	0x20000018
1fff9860:	20000164 	.word	0x20000164

1fff9864 <z_init_cpu>:
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
1fff9864:	b570      	push	{r4, r5, r6, lr}
	struct k_thread *thread = &z_idle_threads[i];
1fff9866:	4e14      	ldr	r6, [pc, #80]	; (1fff98b8 <z_init_cpu+0x54>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
1fff9868:	4d14      	ldr	r5, [pc, #80]	; (1fff98bc <z_init_cpu+0x58>)
	z_setup_new_thread(thread, stack,
1fff986a:	4915      	ldr	r1, [pc, #84]	; (1fff98c0 <z_init_cpu+0x5c>)
	struct k_thread *thread = &z_idle_threads[i];
1fff986c:	2370      	movs	r3, #112	; 0x70
{
1fff986e:	b086      	sub	sp, #24
	struct k_thread *thread = &z_idle_threads[i];
1fff9870:	fb03 6600 	mla	r6, r3, r0, r6
	z_setup_new_thread(thread, stack,
1fff9874:	2201      	movs	r2, #1
1fff9876:	2300      	movs	r3, #0
1fff9878:	e9cd 2304 	strd	r2, r3, [sp, #16]
1fff987c:	220f      	movs	r2, #15
1fff987e:	e9cd 3202 	strd	r3, r2, [sp, #8]
1fff9882:	9301      	str	r3, [sp, #4]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
1fff9884:	2314      	movs	r3, #20
1fff9886:	fb03 5500 	mla	r5, r3, r0, r5
	z_setup_new_thread(thread, stack,
1fff988a:	f44f 72a0 	mov.w	r2, #320	; 0x140
{
1fff988e:	4604      	mov	r4, r0
	z_setup_new_thread(thread, stack,
1fff9890:	fb02 1100 	mla	r1, r2, r0, r1
1fff9894:	4b0b      	ldr	r3, [pc, #44]	; (1fff98c4 <z_init_cpu+0x60>)
1fff9896:	9500      	str	r5, [sp, #0]
1fff9898:	4630      	mov	r0, r6
1fff989a:	f000 f87d 	bl	1fff9998 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
1fff989e:	7b73      	ldrb	r3, [r6, #13]
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
	_kernel.cpus[id].id = id;
1fff98a0:	742c      	strb	r4, [r5, #16]
1fff98a2:	f023 0304 	bic.w	r3, r3, #4
1fff98a6:	7373      	strb	r3, [r6, #13]
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
1fff98a8:	4b07      	ldr	r3, [pc, #28]	; (1fff98c8 <z_init_cpu+0x64>)
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
1fff98aa:	60ee      	str	r6, [r5, #12]
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
1fff98ac:	3401      	adds	r4, #1
1fff98ae:	eb03 23c4 	add.w	r3, r3, r4, lsl #11
	_kernel.cpus[id].irq_stack =
1fff98b2:	606b      	str	r3, [r5, #4]
		 K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[id]));
#ifdef CONFIG_SCHED_THREAD_USAGE_ALL
	_kernel.cpus[id].usage.track_usage =
		CONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;
#endif
}
1fff98b4:	b006      	add	sp, #24
1fff98b6:	bd70      	pop	{r4, r5, r6, pc}
1fff98b8:	20000018 	.word	0x20000018
1fff98bc:	20000130 	.word	0x20000130
1fff98c0:	20000968 	.word	0x20000968
1fff98c4:	1fffa58f 	.word	0x1fffa58f
1fff98c8:	20000168 	.word	0x20000168

1fff98cc <z_cstart>:
 * @return Does not return
 */
__boot_func
FUNC_NO_STACK_PROTECTOR
FUNC_NORETURN void z_cstart(void)
{
1fff98cc:	b580      	push	{r7, lr}
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
1fff98ce:	2000      	movs	r0, #0
{
1fff98d0:	b0a2      	sub	sp, #136	; 0x88
	z_sys_init_run_level(INIT_LEVEL_EARLY);
1fff98d2:	f7ff ff7f 	bl	1fff97d4 <z_sys_init_run_level>
 * pointer) register, and switched to automatically when taking an exception.
 *
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
1fff98d6:	4b29      	ldr	r3, [pc, #164]	; (1fff997c <z_cstart+0xb0>)
  \details Assigns the given value to the Main Stack Pointer (MSP).
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
1fff98d8:	f383 8808 	msr	MSP, r3
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
1fff98dc:	4c28      	ldr	r4, [pc, #160]	; (1fff9980 <z_cstart+0xb4>)

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
1fff98de:	4e29      	ldr	r6, [pc, #164]	; (1fff9984 <z_cstart+0xb8>)
1fff98e0:	6963      	ldr	r3, [r4, #20]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
1fff98e2:	4f29      	ldr	r7, [pc, #164]	; (1fff9988 <z_cstart+0xbc>)
1fff98e4:	f443 7300 	orr.w	r3, r3, #512	; 0x200
1fff98e8:	6163      	str	r3, [r4, #20]
1fff98ea:	2500      	movs	r5, #0
1fff98ec:	23f0      	movs	r3, #240	; 0xf0
1fff98ee:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
1fff98f2:	77e5      	strb	r5, [r4, #31]
1fff98f4:	7625      	strb	r5, [r4, #24]
1fff98f6:	7665      	strb	r5, [r4, #25]
1fff98f8:	76a5      	strb	r5, [r4, #26]
1fff98fa:	f884 5020 	strb.w	r5, [r4, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
1fff98fe:	6a63      	ldr	r3, [r4, #36]	; 0x24
1fff9900:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
1fff9904:	6263      	str	r3, [r4, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
1fff9906:	f7ff fc5d 	bl	1fff91c4 <z_arm_fault_init>
	z_arm_cpu_idle_init();
1fff990a:	f7ff fa33 	bl	1fff8d74 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
1fff990e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
1fff9912:	62a3      	str	r3, [r4, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
1fff9914:	62e3      	str	r3, [r4, #44]	; 0x2c
	dummy_thread->base.user_options = K_ESSENTIAL;
1fff9916:	f240 1301 	movw	r3, #257	; 0x101
1fff991a:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
1fff991e:	ab06      	add	r3, sp, #24
1fff9920:	60b3      	str	r3, [r6, #8]
	dummy_thread->resource_pool = NULL;
1fff9922:	951f      	str	r5, [sp, #124]	; 0x7c
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
1fff9924:	f000 fdfc 	bl	1fffa520 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
1fff9928:	2001      	movs	r0, #1
1fff992a:	f7ff ff53 	bl	1fff97d4 <z_sys_init_run_level>
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
1fff992e:	2002      	movs	r0, #2
	_kernel.ready_q.cache = &z_main_thread;
1fff9930:	4c16      	ldr	r4, [pc, #88]	; (1fff998c <z_cstart+0xc0>)
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
1fff9932:	f7ff ff4f 	bl	1fff97d4 <z_sys_init_run_level>
	z_sched_init();
1fff9936:	f000 fa3b 	bl	1fff9db0 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
1fff993a:	4b15      	ldr	r3, [pc, #84]	; (1fff9990 <z_cstart+0xc4>)
	_kernel.ready_q.cache = &z_main_thread;
1fff993c:	6174      	str	r4, [r6, #20]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
1fff993e:	9305      	str	r3, [sp, #20]
1fff9940:	2301      	movs	r3, #1
1fff9942:	4914      	ldr	r1, [pc, #80]	; (1fff9994 <z_cstart+0xc8>)
1fff9944:	9500      	str	r5, [sp, #0]
1fff9946:	e9cd 5303 	strd	r5, r3, [sp, #12]
1fff994a:	f44f 6280 	mov.w	r2, #1024	; 0x400
1fff994e:	463b      	mov	r3, r7
1fff9950:	e9cd 5501 	strd	r5, r5, [sp, #4]
1fff9954:	4620      	mov	r0, r4
1fff9956:	f000 f81f 	bl	1fff9998 <z_setup_new_thread>
1fff995a:	7b62      	ldrb	r2, [r4, #13]
1fff995c:	4606      	mov	r6, r0
1fff995e:	f022 0204 	bic.w	r2, r2, #4
	z_ready_thread(&z_main_thread);
1fff9962:	4620      	mov	r0, r4
1fff9964:	7362      	strb	r2, [r4, #13]
1fff9966:	f000 fe30 	bl	1fffa5ca <z_ready_thread>
	z_init_cpu(0);
1fff996a:	4628      	mov	r0, r5
1fff996c:	f7ff ff7a 	bl	1fff9864 <z_init_cpu>
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
1fff9970:	463a      	mov	r2, r7
1fff9972:	4631      	mov	r1, r6
1fff9974:	4620      	mov	r0, r4
1fff9976:	f7ff fac9 	bl	1fff8f0c <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
1fff997a:	bf00      	nop
1fff997c:	20000968 	.word	0x20000968
1fff9980:	e000ed00 	.word	0xe000ed00
1fff9984:	20000130 	.word	0x20000130
1fff9988:	1fff9819 	.word	0x1fff9819
1fff998c:	20000088 	.word	0x20000088
1fff9990:	1fffabc7 	.word	0x1fffabc7
1fff9994:	20000aa8 	.word	0x20000aa8

1fff9998 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
1fff9998:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
1fff999a:	9e0c      	ldr	r6, [sp, #48]	; 0x30
1fff999c:	7306      	strb	r6, [r0, #12]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
1fff999e:	3207      	adds	r2, #7
	thread_base->thread_state = (uint8_t)initial_state;
1fff99a0:	2604      	movs	r6, #4
1fff99a2:	7346      	strb	r6, [r0, #13]
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
1fff99a4:	f100 0558 	add.w	r5, r0, #88	; 0x58

	thread_base->prio = priority;
1fff99a8:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
1fff99aa:	7386      	strb	r6, [r0, #14]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
1fff99ac:	f022 0207 	bic.w	r2, r2, #7
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
1fff99b0:	e9c0 5516 	strd	r5, r5, [r0, #88]	; 0x58
	stack_ptr = (char *)stack + stack_obj_size;
1fff99b4:	188e      	adds	r6, r1, r2
	thread_base->pended_on = NULL;
1fff99b6:	2500      	movs	r5, #0
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
1fff99b8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
	thread_base->pended_on = NULL;
1fff99ba:	6085      	str	r5, [r0, #8]
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
1fff99bc:	e9c0 5506 	strd	r5, r5, [r0, #24]

	thread_base->sched_locked = 0U;
1fff99c0:	73c5      	strb	r5, [r0, #15]
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
1fff99c2:	9202      	str	r2, [sp, #8]
1fff99c4:	9a09      	ldr	r2, [sp, #36]	; 0x24
1fff99c6:	9201      	str	r2, [sp, #4]
1fff99c8:	9a08      	ldr	r2, [sp, #32]
1fff99ca:	9200      	str	r2, [sp, #0]
1fff99cc:	4632      	mov	r2, r6
{
1fff99ce:	4604      	mov	r4, r0
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
1fff99d0:	f7ff fa80 	bl	1fff8ed4 <arch_new_thread>
	if (!_current) {
1fff99d4:	4b04      	ldr	r3, [pc, #16]	; (1fff99e8 <z_setup_new_thread+0x50>)
	new_thread->init_data = NULL;
1fff99d6:	6565      	str	r5, [r4, #84]	; 0x54
	if (!_current) {
1fff99d8:	689b      	ldr	r3, [r3, #8]
1fff99da:	b103      	cbz	r3, 1fff99de <z_setup_new_thread+0x46>
	new_thread->resource_pool = _current->resource_pool;
1fff99dc:	6e5b      	ldr	r3, [r3, #100]	; 0x64
	return stack_ptr;
1fff99de:	6663      	str	r3, [r4, #100]	; 0x64
}
1fff99e0:	4630      	mov	r0, r6
1fff99e2:	b004      	add	sp, #16
1fff99e4:	bd70      	pop	{r4, r5, r6, pc}
1fff99e6:	bf00      	nop
1fff99e8:	20000130 	.word	0x20000130

1fff99ec <z_init_static_threads>:
{
1fff99ec:	b5f0      	push	{r4, r5, r6, r7, lr}
1fff99ee:	4c22      	ldr	r4, [pc, #136]	; (1fff9a78 <z_init_static_threads+0x8c>)
	_FOREACH_STATIC_THREAD(thread_data) {
1fff99f0:	4d22      	ldr	r5, [pc, #136]	; (1fff9a7c <z_init_static_threads+0x90>)
{
1fff99f2:	b087      	sub	sp, #28
1fff99f4:	4626      	mov	r6, r4
	_FOREACH_STATIC_THREAD(thread_data) {
1fff99f6:	42ae      	cmp	r6, r5
1fff99f8:	f104 042c 	add.w	r4, r4, #44	; 0x2c
1fff99fc:	d30b      	bcc.n	1fff9a16 <z_init_static_threads+0x2a>
	k_sched_lock();
1fff99fe:	f000 f9a7 	bl	1fff9d50 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
1fff9a02:	4c1d      	ldr	r4, [pc, #116]	; (1fff9a78 <z_init_static_threads+0x8c>)

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
1fff9a04:	4f1e      	ldr	r7, [pc, #120]	; (1fff9a80 <z_init_static_threads+0x94>)
		}
	} else if (mul_ratio) {
		if (result32) {
			return ((uint32_t)t) * (to_hz / from_hz);
		} else {
			return t * ((uint64_t)to_hz / from_hz);
1fff9a06:	260a      	movs	r6, #10
1fff9a08:	42ac      	cmp	r4, r5
1fff9a0a:	d320      	bcc.n	1fff9a4e <z_init_static_threads+0x62>
}
1fff9a0c:	b007      	add	sp, #28
1fff9a0e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	k_sched_unlock();
1fff9a12:	f000 b9b1 	b.w	1fff9d78 <k_sched_unlock>
		z_setup_new_thread(
1fff9a16:	f854 3c04 	ldr.w	r3, [r4, #-4]
1fff9a1a:	9305      	str	r3, [sp, #20]
1fff9a1c:	f854 3c0c 	ldr.w	r3, [r4, #-12]
1fff9a20:	9304      	str	r3, [sp, #16]
1fff9a22:	f854 3c10 	ldr.w	r3, [r4, #-16]
1fff9a26:	9303      	str	r3, [sp, #12]
1fff9a28:	f854 3c14 	ldr.w	r3, [r4, #-20]
1fff9a2c:	9302      	str	r3, [sp, #8]
1fff9a2e:	f854 3c18 	ldr.w	r3, [r4, #-24]
1fff9a32:	9301      	str	r3, [sp, #4]
1fff9a34:	f854 3c1c 	ldr.w	r3, [r4, #-28]
1fff9a38:	9300      	str	r3, [sp, #0]
1fff9a3a:	e954 2309 	ldrd	r2, r3, [r4, #-36]	; 0x24
1fff9a3e:	e954 010b 	ldrd	r0, r1, [r4, #-44]	; 0x2c
1fff9a42:	f7ff ffa9 	bl	1fff9998 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
1fff9a46:	f854 3c2c 	ldr.w	r3, [r4, #-44]
1fff9a4a:	655e      	str	r6, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
1fff9a4c:	e7d2      	b.n	1fff99f4 <z_init_static_threads+0x8>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
1fff9a4e:	6a62      	ldr	r2, [r4, #36]	; 0x24
1fff9a50:	1c53      	adds	r3, r2, #1
1fff9a52:	d009      	beq.n	1fff9a68 <z_init_static_threads+0x7c>
					    K_MSEC(thread_data->init_delay));
1fff9a54:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
1fff9a58:	fb82 2306 	smull	r2, r3, r2, r6
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
1fff9a5c:	ea52 0103 	orrs.w	r1, r2, r3
			schedule_new_thread(thread_data->init_thread,
1fff9a60:	6820      	ldr	r0, [r4, #0]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
1fff9a62:	d103      	bne.n	1fff9a6c <z_init_static_threads+0x80>
	z_sched_start(thread);
1fff9a64:	f000 f956 	bl	1fff9d14 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
1fff9a68:	342c      	adds	r4, #44	; 0x2c
1fff9a6a:	e7cd      	b.n	1fff9a08 <z_init_static_threads+0x1c>
1fff9a6c:	4639      	mov	r1, r7
1fff9a6e:	3018      	adds	r0, #24
1fff9a70:	f000 fa70 	bl	1fff9f54 <z_add_timeout>
1fff9a74:	e7f8      	b.n	1fff9a68 <z_init_static_threads+0x7c>
1fff9a76:	bf00      	nop
1fff9a78:	1fffaad0 	.word	0x1fffaad0
1fff9a7c:	1fffaad0 	.word	0x1fffaad0
1fff9a80:	1fffa62f 	.word	0x1fffa62f

1fff9a84 <sliceable>:
{
	bool ret = is_preempt(thread)
		&& slice_time(thread) != 0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
		&& !z_is_thread_prevented_from_running(thread)
		&& !z_is_idle_thread_object(thread);
1fff9a84:	89c3      	ldrh	r3, [r0, #14]
1fff9a86:	2b7f      	cmp	r3, #127	; 0x7f
1fff9a88:	d812      	bhi.n	1fff9ab0 <sliceable+0x2c>
	int ret = slice_ticks;
1fff9a8a:	4b0a      	ldr	r3, [pc, #40]	; (1fff9ab4 <sliceable+0x30>)
1fff9a8c:	681b      	ldr	r3, [r3, #0]
		&& slice_time(thread) != 0
1fff9a8e:	b163      	cbz	r3, 1fff9aaa <sliceable+0x26>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
1fff9a90:	4b09      	ldr	r3, [pc, #36]	; (1fff9ab8 <sliceable+0x34>)
1fff9a92:	f990 200e 	ldrsb.w	r2, [r0, #14]
1fff9a96:	681b      	ldr	r3, [r3, #0]
1fff9a98:	429a      	cmp	r2, r3
1fff9a9a:	db09      	blt.n	1fff9ab0 <sliceable+0x2c>
		&& !z_is_thread_prevented_from_running(thread)
1fff9a9c:	7b43      	ldrb	r3, [r0, #13]
1fff9a9e:	06db      	lsls	r3, r3, #27
1fff9aa0:	d106      	bne.n	1fff9ab0 <sliceable+0x2c>
		&& !z_is_idle_thread_object(thread);
1fff9aa2:	4b06      	ldr	r3, [pc, #24]	; (1fff9abc <sliceable+0x38>)
1fff9aa4:	1ac3      	subs	r3, r0, r3
1fff9aa6:	bf18      	it	ne
1fff9aa8:	2301      	movne	r3, #1
#ifdef CONFIG_TIMESLICE_PER_THREAD
	ret |= thread->base.slice_ticks != 0;
#endif

	return ret;
}
1fff9aaa:	f003 0001 	and.w	r0, r3, #1
1fff9aae:	4770      	bx	lr
		&& !z_is_idle_thread_object(thread);
1fff9ab0:	2300      	movs	r3, #0
1fff9ab2:	e7fa      	b.n	1fff9aaa <sliceable+0x26>
1fff9ab4:	20000158 	.word	0x20000158
1fff9ab8:	20000154 	.word	0x20000154
1fff9abc:	20000018 	.word	0x20000018

1fff9ac0 <slice_timeout>:

static void slice_timeout(struct _timeout *t)
{
	int cpu = ARRAY_INDEX(slice_timeouts, t);
1fff9ac0:	4b04      	ldr	r3, [pc, #16]	; (1fff9ad4 <slice_timeout+0x14>)
1fff9ac2:	1ac0      	subs	r0, r0, r3
1fff9ac4:	4b04      	ldr	r3, [pc, #16]	; (1fff9ad8 <slice_timeout+0x18>)
1fff9ac6:	10c0      	asrs	r0, r0, #3
1fff9ac8:	4358      	muls	r0, r3

	slice_expired[cpu] = true;
1fff9aca:	4b04      	ldr	r3, [pc, #16]	; (1fff9adc <slice_timeout+0x1c>)
1fff9acc:	2201      	movs	r2, #1
1fff9ace:	541a      	strb	r2, [r3, r0]
	 * the specific core, but that's not part of the API yet.
	 */
	if (IS_ENABLED(CONFIG_SMP) && cpu != _current_cpu->id) {
		flag_ipi();
	}
}
1fff9ad0:	4770      	bx	lr
1fff9ad2:	bf00      	nop
1fff9ad4:	200000f8 	.word	0x200000f8
1fff9ad8:	aaaaaaab 	.word	0xaaaaaaab
1fff9adc:	20000161 	.word	0x20000161

1fff9ae0 <z_reset_time_slice>:

void z_reset_time_slice(struct k_thread *curr)
{
1fff9ae0:	b570      	push	{r4, r5, r6, lr}
	int cpu = _current_cpu->id;
1fff9ae2:	4b0e      	ldr	r3, [pc, #56]	; (1fff9b1c <z_reset_time_slice+0x3c>)

	z_abort_timeout(&slice_timeouts[cpu]);
1fff9ae4:	4c0e      	ldr	r4, [pc, #56]	; (1fff9b20 <z_reset_time_slice+0x40>)
	int cpu = _current_cpu->id;
1fff9ae6:	7c1e      	ldrb	r6, [r3, #16]
	z_abort_timeout(&slice_timeouts[cpu]);
1fff9ae8:	eb06 0346 	add.w	r3, r6, r6, lsl #1
1fff9aec:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
{
1fff9af0:	4605      	mov	r5, r0
	z_abort_timeout(&slice_timeouts[cpu]);
1fff9af2:	4620      	mov	r0, r4
1fff9af4:	f000 fdb5 	bl	1fffa662 <z_abort_timeout>
	slice_expired[cpu] = false;
1fff9af8:	4b0a      	ldr	r3, [pc, #40]	; (1fff9b24 <z_reset_time_slice+0x44>)
1fff9afa:	2200      	movs	r2, #0
	if (sliceable(curr)) {
1fff9afc:	4628      	mov	r0, r5
	slice_expired[cpu] = false;
1fff9afe:	559a      	strb	r2, [r3, r6]
	if (sliceable(curr)) {
1fff9b00:	f7ff ffc0 	bl	1fff9a84 <sliceable>
1fff9b04:	b148      	cbz	r0, 1fff9b1a <z_reset_time_slice+0x3a>
	int ret = slice_ticks;
1fff9b06:	4b08      	ldr	r3, [pc, #32]	; (1fff9b28 <z_reset_time_slice+0x48>)
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
1fff9b08:	4908      	ldr	r1, [pc, #32]	; (1fff9b2c <z_reset_time_slice+0x4c>)
			      K_TICKS(slice_time(curr) - 1));
1fff9b0a:	681a      	ldr	r2, [r3, #0]
1fff9b0c:	3a01      	subs	r2, #1
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
1fff9b0e:	4620      	mov	r0, r4
1fff9b10:	17d3      	asrs	r3, r2, #31
	}
}
1fff9b12:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
1fff9b16:	f000 ba1d 	b.w	1fff9f54 <z_add_timeout>
}
1fff9b1a:	bd70      	pop	{r4, r5, r6, pc}
1fff9b1c:	20000130 	.word	0x20000130
1fff9b20:	200000f8 	.word	0x200000f8
1fff9b24:	20000161 	.word	0x20000161
1fff9b28:	20000158 	.word	0x20000158
1fff9b2c:	1fff9ac1 	.word	0x1fff9ac1

1fff9b30 <update_cache>:
	}
#endif
}

static void update_cache(int preempt_ok)
{
1fff9b30:	b538      	push	{r3, r4, r5, lr}
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
1fff9b32:	4d0d      	ldr	r5, [pc, #52]	; (1fff9b68 <update_cache+0x38>)
1fff9b34:	462b      	mov	r3, r5
1fff9b36:	f853 4f18 	ldr.w	r4, [r3, #24]!
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fff9b3a:	429c      	cmp	r4, r3
1fff9b3c:	d000      	beq.n	1fff9b40 <update_cache+0x10>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
1fff9b3e:	b904      	cbnz	r4, 1fff9b42 <update_cache+0x12>
1fff9b40:	68ec      	ldr	r4, [r5, #12]
	if (z_is_thread_prevented_from_running(_current)) {
1fff9b42:	68ab      	ldr	r3, [r5, #8]
	if (preempt_ok != 0) {
1fff9b44:	b938      	cbnz	r0, 1fff9b56 <update_cache+0x26>
	if (z_is_thread_prevented_from_running(_current)) {
1fff9b46:	7b5a      	ldrb	r2, [r3, #13]
1fff9b48:	06d2      	lsls	r2, r2, #27
1fff9b4a:	d104      	bne.n	1fff9b56 <update_cache+0x26>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
1fff9b4c:	69a2      	ldr	r2, [r4, #24]
1fff9b4e:	b912      	cbnz	r2, 1fff9b56 <update_cache+0x26>
	if (is_preempt(_current) || is_metairq(thread)) {
1fff9b50:	89da      	ldrh	r2, [r3, #14]
1fff9b52:	2a7f      	cmp	r2, #127	; 0x7f
1fff9b54:	d805      	bhi.n	1fff9b62 <update_cache+0x32>
#ifndef CONFIG_SMP
	struct k_thread *thread = next_up();

	if (should_preempt(thread, preempt_ok)) {
#ifdef CONFIG_TIMESLICING
		if (thread != _current) {
1fff9b56:	429c      	cmp	r4, r3
1fff9b58:	d002      	beq.n	1fff9b60 <update_cache+0x30>
			z_reset_time_slice(thread);
1fff9b5a:	4620      	mov	r0, r4
1fff9b5c:	f7ff ffc0 	bl	1fff9ae0 <z_reset_time_slice>
		}
#endif
		update_metairq_preempt(thread);
		_kernel.ready_q.cache = thread;
1fff9b60:	4623      	mov	r3, r4
1fff9b62:	616b      	str	r3, [r5, #20]
	 * thread because if the thread gets preempted for whatever
	 * reason the scheduler will make the same decision anyway.
	 */
	_current_cpu->swap_ok = preempt_ok;
#endif
}
1fff9b64:	bd38      	pop	{r3, r4, r5, pc}
1fff9b66:	bf00      	nop
1fff9b68:	20000130 	.word	0x20000130

1fff9b6c <move_thread_to_end_of_prio_q>:
{
1fff9b6c:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
1fff9b6e:	f990 200d 	ldrsb.w	r2, [r0, #13]
	return (thread->base.thread_state & state) != 0U;
1fff9b72:	7b43      	ldrb	r3, [r0, #13]
1fff9b74:	2a00      	cmp	r2, #0
{
1fff9b76:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
1fff9b78:	da04      	bge.n	1fff9b84 <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
1fff9b7a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
1fff9b7e:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
1fff9b80:	f000 fd11 	bl	1fffa5a6 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
1fff9b84:	7b4b      	ldrb	r3, [r1, #13]
	return list->head == list;
1fff9b86:	4a15      	ldr	r2, [pc, #84]	; (1fff9bdc <move_thread_to_end_of_prio_q+0x70>)
1fff9b88:	f063 037f 	orn	r3, r3, #127	; 0x7f
1fff9b8c:	4610      	mov	r0, r2
1fff9b8e:	734b      	strb	r3, [r1, #13]
1fff9b90:	f850 3f18 	ldr.w	r3, [r0, #24]!
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
1fff9b94:	69d4      	ldr	r4, [r2, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fff9b96:	4283      	cmp	r3, r0
1fff9b98:	bf08      	it	eq
1fff9b9a:	2300      	moveq	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
1fff9b9c:	b923      	cbnz	r3, 1fff9ba8 <move_thread_to_end_of_prio_q+0x3c>
static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	sys_dnode_t *const tail = list->tail;

	node->next = list;
	node->prev = tail;
1fff9b9e:	e9c1 0400 	strd	r0, r4, [r1]

	tail->next = node;
1fff9ba2:	6021      	str	r1, [r4, #0]
	list->tail = node;
1fff9ba4:	61d1      	str	r1, [r2, #28]
}
1fff9ba6:	e00c      	b.n	1fff9bc2 <move_thread_to_end_of_prio_q+0x56>
	int32_t b1 = thread_1->base.prio;
1fff9ba8:	f991 500e 	ldrsb.w	r5, [r1, #14]
	int32_t b2 = thread_2->base.prio;
1fff9bac:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
1fff9bb0:	42b5      	cmp	r5, r6
1fff9bb2:	d00e      	beq.n	1fff9bd2 <move_thread_to_end_of_prio_q+0x66>
		if (z_sched_prio_cmp(thread, t) > 0) {
1fff9bb4:	42ae      	cmp	r6, r5
1fff9bb6:	dd0c      	ble.n	1fff9bd2 <move_thread_to_end_of_prio_q+0x66>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
1fff9bb8:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
1fff9bba:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
1fff9bbe:	6001      	str	r1, [r0, #0]
	successor->prev = node;
1fff9bc0:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
1fff9bc2:	6890      	ldr	r0, [r2, #8]
1fff9bc4:	1a43      	subs	r3, r0, r1
1fff9bc6:	4258      	negs	r0, r3
}
1fff9bc8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
1fff9bcc:	4158      	adcs	r0, r3
1fff9bce:	f7ff bfaf 	b.w	1fff9b30 <update_cache>
	return (node == list->tail) ? NULL : node->next;
1fff9bd2:	429c      	cmp	r4, r3
1fff9bd4:	d0e3      	beq.n	1fff9b9e <move_thread_to_end_of_prio_q+0x32>
1fff9bd6:	681b      	ldr	r3, [r3, #0]
1fff9bd8:	e7e0      	b.n	1fff9b9c <move_thread_to_end_of_prio_q+0x30>
1fff9bda:	bf00      	nop
1fff9bdc:	20000130 	.word	0x20000130

1fff9be0 <ready_thread>:
{
1fff9be0:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
1fff9be2:	f990 300d 	ldrsb.w	r3, [r0, #13]
1fff9be6:	7b42      	ldrb	r2, [r0, #13]
1fff9be8:	2b00      	cmp	r3, #0
1fff9bea:	db29      	blt.n	1fff9c40 <ready_thread+0x60>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
1fff9bec:	06d3      	lsls	r3, r2, #27
1fff9bee:	d127      	bne.n	1fff9c40 <ready_thread+0x60>
	return node->next != NULL;
1fff9bf0:	6983      	ldr	r3, [r0, #24]
1fff9bf2:	bb2b      	cbnz	r3, 1fff9c40 <ready_thread+0x60>
	return list->head == list;
1fff9bf4:	4913      	ldr	r1, [pc, #76]	; (1fff9c44 <ready_thread+0x64>)
	thread->base.thread_state |= _THREAD_QUEUED;
1fff9bf6:	f062 027f 	orn	r2, r2, #127	; 0x7f
1fff9bfa:	7342      	strb	r2, [r0, #13]
1fff9bfc:	460a      	mov	r2, r1
1fff9bfe:	f852 4f18 	ldr.w	r4, [r2, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fff9c02:	4294      	cmp	r4, r2
1fff9c04:	bf18      	it	ne
1fff9c06:	4623      	movne	r3, r4
	return (node == list->tail) ? NULL : node->next;
1fff9c08:	69cc      	ldr	r4, [r1, #28]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
1fff9c0a:	b923      	cbnz	r3, 1fff9c16 <ready_thread+0x36>
	node->prev = tail;
1fff9c0c:	e9c0 2400 	strd	r2, r4, [r0]
	tail->next = node;
1fff9c10:	6020      	str	r0, [r4, #0]
	list->tail = node;
1fff9c12:	61c8      	str	r0, [r1, #28]
}
1fff9c14:	e00c      	b.n	1fff9c30 <ready_thread+0x50>
	int32_t b1 = thread_1->base.prio;
1fff9c16:	f990 500e 	ldrsb.w	r5, [r0, #14]
	int32_t b2 = thread_2->base.prio;
1fff9c1a:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
1fff9c1e:	42b5      	cmp	r5, r6
1fff9c20:	d00a      	beq.n	1fff9c38 <ready_thread+0x58>
		if (z_sched_prio_cmp(thread, t) > 0) {
1fff9c22:	42ae      	cmp	r6, r5
1fff9c24:	dd08      	ble.n	1fff9c38 <ready_thread+0x58>
	sys_dnode_t *const prev = successor->prev;
1fff9c26:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
1fff9c28:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
1fff9c2c:	6010      	str	r0, [r2, #0]
	successor->prev = node;
1fff9c2e:	6058      	str	r0, [r3, #4]
}
1fff9c30:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
1fff9c32:	2000      	movs	r0, #0
1fff9c34:	f7ff bf7c 	b.w	1fff9b30 <update_cache>
	return (node == list->tail) ? NULL : node->next;
1fff9c38:	42a3      	cmp	r3, r4
1fff9c3a:	d0e7      	beq.n	1fff9c0c <ready_thread+0x2c>
1fff9c3c:	681b      	ldr	r3, [r3, #0]
1fff9c3e:	e7e4      	b.n	1fff9c0a <ready_thread+0x2a>
}
1fff9c40:	bc70      	pop	{r4, r5, r6}
1fff9c42:	4770      	bx	lr
1fff9c44:	20000130 	.word	0x20000130

1fff9c48 <k_sched_time_slice_set>:
{
1fff9c48:	b510      	push	{r4, lr}
	__asm__ volatile(
1fff9c4a:	f04f 0310 	mov.w	r3, #16
1fff9c4e:	f3ef 8411 	mrs	r4, BASEPRI
1fff9c52:	f383 8812 	msr	BASEPRI_MAX, r3
1fff9c56:	f3bf 8f6f 	isb	sy
			return ((uint32_t)t) * (to_hz / from_hz);
1fff9c5a:	230a      	movs	r3, #10
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
1fff9c5c:	2800      	cmp	r0, #0
1fff9c5e:	fb00 f303 	mul.w	r3, r0, r3
1fff9c62:	dd02      	ble.n	1fff9c6a <k_sched_time_slice_set+0x22>
			slice_ticks = MAX(2, slice_ticks);
1fff9c64:	2b02      	cmp	r3, #2
1fff9c66:	bfb8      	it	lt
1fff9c68:	2302      	movlt	r3, #2
		slice_ticks = k_ms_to_ticks_ceil32(slice);
1fff9c6a:	4a06      	ldr	r2, [pc, #24]	; (1fff9c84 <k_sched_time_slice_set+0x3c>)
1fff9c6c:	6013      	str	r3, [r2, #0]
		slice_max_prio = prio;
1fff9c6e:	4b06      	ldr	r3, [pc, #24]	; (1fff9c88 <k_sched_time_slice_set+0x40>)
1fff9c70:	6019      	str	r1, [r3, #0]
		z_reset_time_slice(_current);
1fff9c72:	4b06      	ldr	r3, [pc, #24]	; (1fff9c8c <k_sched_time_slice_set+0x44>)
1fff9c74:	6898      	ldr	r0, [r3, #8]
1fff9c76:	f7ff ff33 	bl	1fff9ae0 <z_reset_time_slice>
	__asm__ volatile(
1fff9c7a:	f384 8811 	msr	BASEPRI, r4
1fff9c7e:	f3bf 8f6f 	isb	sy
}
1fff9c82:	bd10      	pop	{r4, pc}
1fff9c84:	20000158 	.word	0x20000158
1fff9c88:	20000154 	.word	0x20000154
1fff9c8c:	20000130 	.word	0x20000130

1fff9c90 <z_time_slice>:
{
1fff9c90:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
1fff9c92:	f04f 0310 	mov.w	r3, #16
1fff9c96:	f3ef 8511 	mrs	r5, BASEPRI
1fff9c9a:	f383 8812 	msr	BASEPRI_MAX, r3
1fff9c9e:	f3bf 8f6f 	isb	sy
	struct k_thread *curr = _current;
1fff9ca2:	4b10      	ldr	r3, [pc, #64]	; (1fff9ce4 <z_time_slice+0x54>)
	if (pending_current == curr) {
1fff9ca4:	4a10      	ldr	r2, [pc, #64]	; (1fff9ce8 <z_time_slice+0x58>)
	struct k_thread *curr = _current;
1fff9ca6:	689c      	ldr	r4, [r3, #8]
	if (pending_current == curr) {
1fff9ca8:	6810      	ldr	r0, [r2, #0]
1fff9caa:	42a0      	cmp	r0, r4
1fff9cac:	d106      	bne.n	1fff9cbc <z_time_slice+0x2c>
		z_reset_time_slice(curr);
1fff9cae:	f7ff ff17 	bl	1fff9ae0 <z_reset_time_slice>
	__asm__ volatile(
1fff9cb2:	f385 8811 	msr	BASEPRI, r5
1fff9cb6:	f3bf 8f6f 	isb	sy
}
1fff9cba:	bd38      	pop	{r3, r4, r5, pc}
	pending_current = NULL;
1fff9cbc:	2100      	movs	r1, #0
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
1fff9cbe:	7c1b      	ldrb	r3, [r3, #16]
	pending_current = NULL;
1fff9cc0:	6011      	str	r1, [r2, #0]
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
1fff9cc2:	4a0a      	ldr	r2, [pc, #40]	; (1fff9cec <z_time_slice+0x5c>)
1fff9cc4:	5cd3      	ldrb	r3, [r2, r3]
1fff9cc6:	2b00      	cmp	r3, #0
1fff9cc8:	d0f3      	beq.n	1fff9cb2 <z_time_slice+0x22>
1fff9cca:	4620      	mov	r0, r4
1fff9ccc:	f7ff feda 	bl	1fff9a84 <sliceable>
1fff9cd0:	2800      	cmp	r0, #0
1fff9cd2:	d0ee      	beq.n	1fff9cb2 <z_time_slice+0x22>
		if (!z_is_thread_prevented_from_running(curr)) {
1fff9cd4:	7b63      	ldrb	r3, [r4, #13]
1fff9cd6:	06db      	lsls	r3, r3, #27
1fff9cd8:	d102      	bne.n	1fff9ce0 <z_time_slice+0x50>
			move_thread_to_end_of_prio_q(curr);
1fff9cda:	4620      	mov	r0, r4
1fff9cdc:	f7ff ff46 	bl	1fff9b6c <move_thread_to_end_of_prio_q>
		z_reset_time_slice(curr);
1fff9ce0:	4620      	mov	r0, r4
1fff9ce2:	e7e4      	b.n	1fff9cae <z_time_slice+0x1e>
1fff9ce4:	20000130 	.word	0x20000130
1fff9ce8:	20000150 	.word	0x20000150
1fff9cec:	20000161 	.word	0x20000161

1fff9cf0 <z_reschedule>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
1fff9cf0:	b949      	cbnz	r1, 1fff9d06 <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
1fff9cf2:	f3ef 8005 	mrs	r0, IPSR
1fff9cf6:	b930      	cbnz	r0, 1fff9d06 <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
1fff9cf8:	4b05      	ldr	r3, [pc, #20]	; (1fff9d10 <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
1fff9cfa:	695a      	ldr	r2, [r3, #20]
1fff9cfc:	689b      	ldr	r3, [r3, #8]
1fff9cfe:	429a      	cmp	r2, r3
1fff9d00:	d001      	beq.n	1fff9d06 <z_reschedule+0x16>
	ret = arch_swap(key);
1fff9d02:	f7ff b899 	b.w	1fff8e38 <arch_swap>
1fff9d06:	f381 8811 	msr	BASEPRI, r1
1fff9d0a:	f3bf 8f6f 	isb	sy
}
1fff9d0e:	4770      	bx	lr
1fff9d10:	20000130 	.word	0x20000130

1fff9d14 <z_sched_start>:
{
1fff9d14:	b510      	push	{r4, lr}
	__asm__ volatile(
1fff9d16:	f04f 0210 	mov.w	r2, #16
1fff9d1a:	f3ef 8411 	mrs	r4, BASEPRI
1fff9d1e:	f382 8812 	msr	BASEPRI_MAX, r2
1fff9d22:	f3bf 8f6f 	isb	sy
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
1fff9d26:	7b42      	ldrb	r2, [r0, #13]
	if (z_has_thread_started(thread)) {
1fff9d28:	0751      	lsls	r1, r2, #29
1fff9d2a:	d404      	bmi.n	1fff9d36 <z_sched_start+0x22>
	__asm__ volatile(
1fff9d2c:	f384 8811 	msr	BASEPRI, r4
1fff9d30:	f3bf 8f6f 	isb	sy
}
1fff9d34:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
1fff9d36:	f022 0204 	bic.w	r2, r2, #4
1fff9d3a:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
1fff9d3c:	f7ff ff50 	bl	1fff9be0 <ready_thread>
	z_reschedule(&sched_spinlock, key);
1fff9d40:	4621      	mov	r1, r4
1fff9d42:	4802      	ldr	r0, [pc, #8]	; (1fff9d4c <z_sched_start+0x38>)
}
1fff9d44:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
1fff9d48:	f7ff bfd2 	b.w	1fff9cf0 <z_reschedule>
1fff9d4c:	20000162 	.word	0x20000162

1fff9d50 <k_sched_lock>:
	__asm__ volatile(
1fff9d50:	f04f 0310 	mov.w	r3, #16
1fff9d54:	f3ef 8111 	mrs	r1, BASEPRI
1fff9d58:	f383 8812 	msr	BASEPRI_MAX, r3
1fff9d5c:	f3bf 8f6f 	isb	sy
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
1fff9d60:	4b04      	ldr	r3, [pc, #16]	; (1fff9d74 <k_sched_lock+0x24>)
1fff9d62:	689a      	ldr	r2, [r3, #8]
1fff9d64:	7bd3      	ldrb	r3, [r2, #15]
1fff9d66:	3b01      	subs	r3, #1
1fff9d68:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
1fff9d6a:	f381 8811 	msr	BASEPRI, r1
1fff9d6e:	f3bf 8f6f 	isb	sy
}
1fff9d72:	4770      	bx	lr
1fff9d74:	20000130 	.word	0x20000130

1fff9d78 <k_sched_unlock>:
{
1fff9d78:	b510      	push	{r4, lr}
	__asm__ volatile(
1fff9d7a:	f04f 0310 	mov.w	r3, #16
1fff9d7e:	f3ef 8411 	mrs	r4, BASEPRI
1fff9d82:	f383 8812 	msr	BASEPRI_MAX, r3
1fff9d86:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
1fff9d8a:	4b08      	ldr	r3, [pc, #32]	; (1fff9dac <k_sched_unlock+0x34>)
1fff9d8c:	689a      	ldr	r2, [r3, #8]
1fff9d8e:	7bd3      	ldrb	r3, [r2, #15]
1fff9d90:	3301      	adds	r3, #1
1fff9d92:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
1fff9d94:	2000      	movs	r0, #0
1fff9d96:	f7ff fecb 	bl	1fff9b30 <update_cache>
	__asm__ volatile(
1fff9d9a:	f384 8811 	msr	BASEPRI, r4
1fff9d9e:	f3bf 8f6f 	isb	sy
}
1fff9da2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
1fff9da6:	f000 bc52 	b.w	1fffa64e <z_reschedule_unlocked>
1fff9daa:	bf00      	nop
1fff9dac:	20000130 	.word	0x20000130

1fff9db0 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
1fff9db0:	4b04      	ldr	r3, [pc, #16]	; (1fff9dc4 <z_sched_init+0x14>)
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
1fff9db2:	2100      	movs	r1, #0
1fff9db4:	f103 0218 	add.w	r2, r3, #24
1fff9db8:	4608      	mov	r0, r1
	list->tail = (sys_dnode_t *)list;
1fff9dba:	e9c3 2206 	strd	r2, r2, [r3, #24]
1fff9dbe:	f7ff bf43 	b.w	1fff9c48 <k_sched_time_slice_set>
1fff9dc2:	bf00      	nop
1fff9dc4:	20000130 	.word	0x20000130

1fff9dc8 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
1fff9dc8:	4b01      	ldr	r3, [pc, #4]	; (1fff9dd0 <z_impl_z_current_get+0x8>)
1fff9dca:	6898      	ldr	r0, [r3, #8]
1fff9dcc:	4770      	bx	lr
1fff9dce:	bf00      	nop
1fff9dd0:	20000130 	.word	0x20000130

1fff9dd4 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
1fff9dd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
1fff9dd8:	4604      	mov	r4, r0
	__asm__ volatile(
1fff9dda:	f04f 0310 	mov.w	r3, #16
1fff9dde:	f3ef 8611 	mrs	r6, BASEPRI
1fff9de2:	f383 8812 	msr	BASEPRI_MAX, r3
1fff9de6:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
1fff9dea:	7b03      	ldrb	r3, [r0, #12]
1fff9dec:	07d9      	lsls	r1, r3, #31
1fff9dee:	d50b      	bpl.n	1fff9e08 <z_thread_abort+0x34>
	__asm__ volatile(
1fff9df0:	f386 8811 	msr	BASEPRI, r6
1fff9df4:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&sched_spinlock, key);
		__ASSERT(false, "aborting essential thread %p", thread);
		k_panic();
1fff9df8:	4040      	eors	r0, r0
1fff9dfa:	f380 8811 	msr	BASEPRI, r0
1fff9dfe:	f04f 0004 	mov.w	r0, #4
1fff9e02:	df02      	svc	2
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
1fff9e04:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
1fff9e08:	7b43      	ldrb	r3, [r0, #13]
1fff9e0a:	071a      	lsls	r2, r3, #28
1fff9e0c:	d504      	bpl.n	1fff9e18 <z_thread_abort+0x44>
1fff9e0e:	f386 8811 	msr	BASEPRI, r6
1fff9e12:	f3bf 8f6f 	isb	sy
1fff9e16:	e7f5      	b.n	1fff9e04 <z_thread_abort+0x30>
		thread->base.thread_state &= ~_THREAD_ABORTING;
1fff9e18:	f023 0220 	bic.w	r2, r3, #32
1fff9e1c:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
1fff9e20:	09d2      	lsrs	r2, r2, #7
1fff9e22:	d120      	bne.n	1fff9e66 <z_thread_abort+0x92>
		thread->base.thread_state &= ~_THREAD_ABORTING;
1fff9e24:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
1fff9e26:	68a3      	ldr	r3, [r4, #8]
1fff9e28:	b113      	cbz	r3, 1fff9e30 <z_thread_abort+0x5c>
			unpend_thread_no_timeout(thread);
1fff9e2a:	4620      	mov	r0, r4
1fff9e2c:	f000 fbc3 	bl	1fffa5b6 <unpend_thread_no_timeout>
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
1fff9e30:	f104 0018 	add.w	r0, r4, #24
1fff9e34:	f000 fc15 	bl	1fffa662 <z_abort_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
1fff9e38:	f104 0758 	add.w	r7, r4, #88	; 0x58
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
1fff9e3c:	f04f 0800 	mov.w	r8, #0
	return list->head == list;
1fff9e40:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fff9e42:	42bd      	cmp	r5, r7
1fff9e44:	d000      	beq.n	1fff9e48 <z_thread_abort+0x74>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
1fff9e46:	b9b5      	cbnz	r5, 1fff9e76 <z_thread_abort+0xa2>
		update_cache(1);
1fff9e48:	2001      	movs	r0, #1
1fff9e4a:	f7ff fe71 	bl	1fff9b30 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
1fff9e4e:	4b10      	ldr	r3, [pc, #64]	; (1fff9e90 <z_thread_abort+0xbc>)
1fff9e50:	689b      	ldr	r3, [r3, #8]
1fff9e52:	42a3      	cmp	r3, r4
1fff9e54:	d1db      	bne.n	1fff9e0e <z_thread_abort+0x3a>
1fff9e56:	f3ef 8305 	mrs	r3, IPSR
1fff9e5a:	2b00      	cmp	r3, #0
1fff9e5c:	d1d7      	bne.n	1fff9e0e <z_thread_abort+0x3a>
1fff9e5e:	4630      	mov	r0, r6
1fff9e60:	f7fe ffea 	bl	1fff8e38 <arch_swap>
	return ret;
1fff9e64:	e7d3      	b.n	1fff9e0e <z_thread_abort+0x3a>
	thread->base.thread_state &= ~_THREAD_QUEUED;
1fff9e66:	f003 035f 	and.w	r3, r3, #95	; 0x5f
1fff9e6a:	f043 0308 	orr.w	r3, r3, #8
1fff9e6e:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
1fff9e70:	f000 fb99 	bl	1fffa5a6 <sys_dlist_remove>
}
1fff9e74:	e7d7      	b.n	1fff9e26 <z_thread_abort+0x52>
		unpend_thread_no_timeout(thread);
1fff9e76:	4628      	mov	r0, r5
1fff9e78:	f000 fb9d 	bl	1fffa5b6 <unpend_thread_no_timeout>
1fff9e7c:	f105 0018 	add.w	r0, r5, #24
1fff9e80:	f000 fbef 	bl	1fffa662 <z_abort_timeout>
1fff9e84:	f8c5 806c 	str.w	r8, [r5, #108]	; 0x6c
		ready_thread(thread);
1fff9e88:	4628      	mov	r0, r5
1fff9e8a:	f7ff fea9 	bl	1fff9be0 <ready_thread>
1fff9e8e:	e7d7      	b.n	1fff9e40 <z_thread_abort+0x6c>
1fff9e90:	20000130 	.word	0x20000130

1fff9e94 <z_data_copy>:
 * @brief Copy the data section from ROM to RAM
 *
 * This routine copies the data section from ROM to RAM.
 */
void z_data_copy(void)
{
1fff9e94:	b508      	push	{r3, lr}
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
		       __data_region_end - __data_region_start);
1fff9e96:	4806      	ldr	r0, [pc, #24]	; (1fff9eb0 <z_data_copy+0x1c>)
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
1fff9e98:	4a06      	ldr	r2, [pc, #24]	; (1fff9eb4 <z_data_copy+0x20>)
1fff9e9a:	4907      	ldr	r1, [pc, #28]	; (1fff9eb8 <z_data_copy+0x24>)
1fff9e9c:	1a12      	subs	r2, r2, r0
1fff9e9e:	f000 fb74 	bl	1fffa58a <z_early_memcpy>
#else
	z_early_memcpy(&_app_smem_start, &_app_smem_rom_start,
		       _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
1fff9ea2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_early_memcpy(&__ramfunc_start, &__ramfunc_load_start,
1fff9ea6:	4a05      	ldr	r2, [pc, #20]	; (1fff9ebc <z_data_copy+0x28>)
1fff9ea8:	4905      	ldr	r1, [pc, #20]	; (1fff9ec0 <z_data_copy+0x2c>)
1fff9eaa:	4806      	ldr	r0, [pc, #24]	; (1fff9ec4 <z_data_copy+0x30>)
1fff9eac:	f000 bb6d 	b.w	1fffa58a <z_early_memcpy>
1fff9eb0:	20000000 	.word	0x20000000
1fff9eb4:	20000012 	.word	0x20000012
1fff9eb8:	1fffac14 	.word	0x1fffac14
1fff9ebc:	00000000 	.word	0x00000000
1fff9ec0:	1fffac14 	.word	0x1fffac14
1fff9ec4:	20000000 	.word	0x20000000

1fff9ec8 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
1fff9ec8:	4b03      	ldr	r3, [pc, #12]	; (1fff9ed8 <elapsed+0x10>)
1fff9eca:	681b      	ldr	r3, [r3, #0]
1fff9ecc:	b90b      	cbnz	r3, 1fff9ed2 <elapsed+0xa>
1fff9ece:	f7ff bb37 	b.w	1fff9540 <sys_clock_elapsed>
}
1fff9ed2:	2000      	movs	r0, #0
1fff9ed4:	4770      	bx	lr
1fff9ed6:	bf00      	nop
1fff9ed8:	2000015c 	.word	0x2000015c

1fff9edc <next_timeout>:

static int32_t next_timeout(void)
{
1fff9edc:	b510      	push	{r4, lr}
	return list->head == list;
1fff9ede:	4b0e      	ldr	r3, [pc, #56]	; (1fff9f18 <next_timeout+0x3c>)
1fff9ee0:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fff9ee2:	429c      	cmp	r4, r3
1fff9ee4:	d104      	bne.n	1fff9ef0 <next_timeout+0x14>
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
1fff9ee6:	f7ff ffef 	bl	1fff9ec8 <elapsed>
	int32_t ret;

	if ((to == NULL) ||
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
		ret = MAX_WAIT;
1fff9eea:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
	}

	return ret;
}
1fff9eee:	bd10      	pop	{r4, pc}
	int32_t ticks_elapsed = elapsed();
1fff9ef0:	f7ff ffea 	bl	1fff9ec8 <elapsed>
	if ((to == NULL) ||
1fff9ef4:	2c00      	cmp	r4, #0
1fff9ef6:	d0f8      	beq.n	1fff9eea <next_timeout+0xe>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
1fff9ef8:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
1fff9efc:	1a1b      	subs	r3, r3, r0
1fff9efe:	eb62 72e0 	sbc.w	r2, r2, r0, asr #31
	if ((to == NULL) ||
1fff9f02:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
1fff9f06:	f172 0100 	sbcs.w	r1, r2, #0
1fff9f0a:	daee      	bge.n	1fff9eea <next_timeout+0xe>
		ret = MAX(0, to->dticks - ticks_elapsed);
1fff9f0c:	2a00      	cmp	r2, #0
1fff9f0e:	bfac      	ite	ge
1fff9f10:	4618      	movge	r0, r3
1fff9f12:	2000      	movlt	r0, #0
	return ret;
1fff9f14:	e7eb      	b.n	1fff9eee <next_timeout+0x12>
1fff9f16:	bf00      	nop
1fff9f18:	20000008 	.word	0x20000008

1fff9f1c <remove_timeout>:
{
1fff9f1c:	b530      	push	{r4, r5, lr}
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
1fff9f1e:	b170      	cbz	r0, 1fff9f3e <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
1fff9f20:	4b0b      	ldr	r3, [pc, #44]	; (1fff9f50 <remove_timeout+0x34>)
1fff9f22:	685b      	ldr	r3, [r3, #4]
1fff9f24:	4298      	cmp	r0, r3
1fff9f26:	d00a      	beq.n	1fff9f3e <remove_timeout+0x22>
1fff9f28:	6803      	ldr	r3, [r0, #0]
	if (next(t) != NULL) {
1fff9f2a:	b143      	cbz	r3, 1fff9f3e <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
1fff9f2c:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
1fff9f30:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
1fff9f34:	1912      	adds	r2, r2, r4
1fff9f36:	eb41 0105 	adc.w	r1, r1, r5
1fff9f3a:	e9c3 2104 	strd	r2, r1, [r3, #16]
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
	sys_dnode_t *const next = node->next;
1fff9f3e:	e9d0 3200 	ldrd	r3, r2, [r0]

	prev->next = next;
1fff9f42:	6013      	str	r3, [r2, #0]
	next->prev = prev;
1fff9f44:	605a      	str	r2, [r3, #4]
	node->next = NULL;
1fff9f46:	2300      	movs	r3, #0
	node->prev = NULL;
1fff9f48:	e9c0 3300 	strd	r3, r3, [r0]
}
1fff9f4c:	bd30      	pop	{r4, r5, pc}
1fff9f4e:	bf00      	nop
1fff9f50:	20000008 	.word	0x20000008

1fff9f54 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
1fff9f54:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
1fff9f58:	bf08      	it	eq
1fff9f5a:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
1fff9f5e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1fff9f60:	4604      	mov	r4, r0
1fff9f62:	461d      	mov	r5, r3
1fff9f64:	4616      	mov	r6, r2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
1fff9f66:	d05c      	beq.n	1fffa022 <z_add_timeout+0xce>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
1fff9f68:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
1fff9f6a:	f04f 0310 	mov.w	r3, #16
1fff9f6e:	f3ef 8711 	mrs	r7, BASEPRI
1fff9f72:	f383 8812 	msr	BASEPRI_MAX, r3
1fff9f76:	f3bf 8f6f 	isb	sy

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
1fff9f7a:	3201      	adds	r2, #1
1fff9f7c:	f175 33ff 	sbcs.w	r3, r5, #4294967295	; 0xffffffff
1fff9f80:	da24      	bge.n	1fff9fcc <z_add_timeout+0x78>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
1fff9f82:	492d      	ldr	r1, [pc, #180]	; (1fffa038 <z_add_timeout+0xe4>)
1fff9f84:	e9d1 2000 	ldrd	r2, r0, [r1]
1fff9f88:	f06f 0301 	mvn.w	r3, #1
1fff9f8c:	1a9b      	subs	r3, r3, r2
1fff9f8e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
1fff9f92:	eb62 0000 	sbc.w	r0, r2, r0
1fff9f96:	1b9e      	subs	r6, r3, r6
1fff9f98:	eb60 0005 	sbc.w	r0, r0, r5

			to->dticks = MAX(1, ticks);
1fff9f9c:	2e01      	cmp	r6, #1
1fff9f9e:	f170 0300 	sbcs.w	r3, r0, #0
1fff9fa2:	da01      	bge.n	1fff9fa8 <z_add_timeout+0x54>
1fff9fa4:	2601      	movs	r6, #1
1fff9fa6:	2000      	movs	r0, #0
1fff9fa8:	e9c4 6004 	strd	r6, r0, [r4, #16]
	return list->head == list;
1fff9fac:	4e23      	ldr	r6, [pc, #140]	; (1fffa03c <z_add_timeout+0xe8>)
1fff9fae:	f8d6 c000 	ldr.w	ip, [r6]
	return (node == list->tail) ? NULL : node->next;
1fff9fb2:	6875      	ldr	r5, [r6, #4]
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fff9fb4:	45b4      	cmp	ip, r6
1fff9fb6:	bf08      	it	eq
1fff9fb8:	f04f 0c00 	moveq.w	ip, #0
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
		}

		for (t = first(); t != NULL; t = next(t)) {
1fff9fbc:	f1bc 0f00 	cmp.w	ip, #0
1fff9fc0:	d10d      	bne.n	1fff9fde <z_add_timeout+0x8a>
	node->prev = tail;
1fff9fc2:	e9c4 6500 	strd	r6, r5, [r4]
	tail->next = node;
1fff9fc6:	602c      	str	r4, [r5, #0]
	list->tail = node;
1fff9fc8:	6074      	str	r4, [r6, #4]
}
1fff9fca:	e01c      	b.n	1fffa006 <z_add_timeout+0xb2>
			to->dticks = timeout.ticks + 1 + elapsed();
1fff9fcc:	f7ff ff7c 	bl	1fff9ec8 <elapsed>
1fff9fd0:	3601      	adds	r6, #1
1fff9fd2:	f145 0500 	adc.w	r5, r5, #0
1fff9fd6:	1836      	adds	r6, r6, r0
1fff9fd8:	eb45 70e0 	adc.w	r0, r5, r0, asr #31
1fff9fdc:	e7e4      	b.n	1fff9fa8 <z_add_timeout+0x54>
			if (t->dticks > to->dticks) {
1fff9fde:	e9dc 2004 	ldrd	r2, r0, [ip, #16]
1fff9fe2:	e9d4 3104 	ldrd	r3, r1, [r4, #16]
1fff9fe6:	4293      	cmp	r3, r2
1fff9fe8:	eb71 0e00 	sbcs.w	lr, r1, r0
1fff9fec:	da1a      	bge.n	1fffa024 <z_add_timeout+0xd0>
				t->dticks -= to->dticks;
1fff9fee:	1ad2      	subs	r2, r2, r3
	sys_dnode_t *const prev = successor->prev;
1fff9ff0:	f8dc 3004 	ldr.w	r3, [ip, #4]
1fff9ff4:	eb60 0001 	sbc.w	r0, r0, r1
1fff9ff8:	e9cc 2004 	strd	r2, r0, [ip, #16]
	node->next = successor;
1fff9ffc:	e9c4 c300 	strd	ip, r3, [r4]
	prev->next = node;
1fffa000:	601c      	str	r4, [r3, #0]
	successor->prev = node;
1fffa002:	f8cc 4004 	str.w	r4, [ip, #4]
	return list->head == list;
1fffa006:	6833      	ldr	r3, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fffa008:	42b3      	cmp	r3, r6
1fffa00a:	d006      	beq.n	1fffa01a <z_add_timeout+0xc6>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
1fffa00c:	429c      	cmp	r4, r3
1fffa00e:	d104      	bne.n	1fffa01a <z_add_timeout+0xc6>
			sys_clock_set_timeout(next_timeout(), false);
1fffa010:	f7ff ff64 	bl	1fff9edc <next_timeout>
1fffa014:	2100      	movs	r1, #0
1fffa016:	f7ff fa21 	bl	1fff945c <sys_clock_set_timeout>
	__asm__ volatile(
1fffa01a:	f387 8811 	msr	BASEPRI, r7
1fffa01e:	f3bf 8f6f 	isb	sy
		}
	}
}
1fffa022:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			to->dticks -= t->dticks;
1fffa024:	1a9b      	subs	r3, r3, r2
1fffa026:	eb61 0100 	sbc.w	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
1fffa02a:	45ac      	cmp	ip, r5
1fffa02c:	e9c4 3104 	strd	r3, r1, [r4, #16]
1fffa030:	d0c7      	beq.n	1fff9fc2 <z_add_timeout+0x6e>
1fffa032:	f8dc c000 	ldr.w	ip, [ip]
1fffa036:	e7c1      	b.n	1fff9fbc <z_add_timeout+0x68>
1fffa038:	20000110 	.word	0x20000110
1fffa03c:	20000008 	.word	0x20000008

1fffa040 <sys_clock_announce>:
	}
	return ret;
}

void sys_clock_announce(int32_t ticks)
{
1fffa040:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	__asm__ volatile(
1fffa044:	f04f 0310 	mov.w	r3, #16
1fffa048:	f3ef 8c11 	mrs	ip, BASEPRI
1fffa04c:	f383 8812 	msr	BASEPRI_MAX, r3
1fffa050:	f3bf 8f6f 	isb	sy
	return list->head == list;
1fffa054:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 1fffa108 <sys_clock_announce+0xc8>
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
1fffa058:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 1fffa10c <sys_clock_announce+0xcc>
	for (t = first();
	     (t != NULL) && (t->dticks <= announce_remaining);
	     t = first()) {
		int dt = t->dticks;

		curr_tick += dt;
1fffa05c:	4f2c      	ldr	r7, [pc, #176]	; (1fffa110 <sys_clock_announce+0xd0>)
	announce_remaining = ticks;
1fffa05e:	f8c9 0000 	str.w	r0, [r9]
1fffa062:	f8da 0000 	ldr.w	r0, [sl]
		t->dticks = 0;
1fffa066:	2400      	movs	r4, #0
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fffa068:	4550      	cmp	r0, sl
1fffa06a:	bf08      	it	eq
1fffa06c:	2000      	moveq	r0, #0
1fffa06e:	2500      	movs	r5, #0
		curr_tick += dt;
1fffa070:	e9d7 2100 	ldrd	r2, r1, [r7]
	     (t != NULL) && (t->dticks <= announce_remaining);
1fffa074:	f8d9 3000 	ldr.w	r3, [r9]
	 * a memory barrier when used like this, and we don't have a
	 * Zephyr framework for that.
	 */
	atomic_clear(&l->locked);
#endif
	arch_irq_unlock(key.key);
1fffa078:	46e0      	mov	r8, ip
1fffa07a:	b380      	cbz	r0, 1fffa0de <sys_clock_announce+0x9e>
1fffa07c:	e9d0 6c04 	ldrd	r6, ip, [r0, #16]
1fffa080:	ea4f 7ee3 	mov.w	lr, r3, asr #31
1fffa084:	42b3      	cmp	r3, r6
1fffa086:	eb7e 0b0c 	sbcs.w	fp, lr, ip
1fffa08a:	da05      	bge.n	1fffa098 <sys_clock_announce+0x58>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
	}

	if (t != NULL) {
		t->dticks -= announce_remaining;
1fffa08c:	1af6      	subs	r6, r6, r3
1fffa08e:	eb6c 040e 	sbc.w	r4, ip, lr
1fffa092:	e9c0 6404 	strd	r6, r4, [r0, #16]
1fffa096:	e022      	b.n	1fffa0de <sys_clock_announce+0x9e>
		curr_tick += dt;
1fffa098:	18b2      	adds	r2, r6, r2
1fffa09a:	eb41 71e6 	adc.w	r1, r1, r6, asr #31
		t->dticks = 0;
1fffa09e:	e9c0 4504 	strd	r4, r5, [r0, #16]
		curr_tick += dt;
1fffa0a2:	e9c7 2100 	strd	r2, r1, [r7]
		remove_timeout(t);
1fffa0a6:	f7ff ff39 	bl	1fff9f1c <remove_timeout>
	__asm__ volatile(
1fffa0aa:	f388 8811 	msr	BASEPRI, r8
1fffa0ae:	f3bf 8f6f 	isb	sy
		t->fn(t);
1fffa0b2:	6883      	ldr	r3, [r0, #8]
1fffa0b4:	4798      	blx	r3
	__asm__ volatile(
1fffa0b6:	f04f 0310 	mov.w	r3, #16
1fffa0ba:	f3ef 8811 	mrs	r8, BASEPRI
1fffa0be:	f383 8812 	msr	BASEPRI_MAX, r3
1fffa0c2:	f3bf 8f6f 	isb	sy
		announce_remaining -= dt;
1fffa0c6:	f8d9 3000 	ldr.w	r3, [r9]
	return list->head == list;
1fffa0ca:	f8da 0000 	ldr.w	r0, [sl]
1fffa0ce:	1b9b      	subs	r3, r3, r6
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fffa0d0:	4550      	cmp	r0, sl
	k.key = arch_irq_lock();
1fffa0d2:	46c4      	mov	ip, r8
1fffa0d4:	f8c9 3000 	str.w	r3, [r9]
1fffa0d8:	d1ca      	bne.n	1fffa070 <sys_clock_announce+0x30>
		curr_tick += dt;
1fffa0da:	e9d7 2100 	ldrd	r2, r1, [r7]
	}

	curr_tick += announce_remaining;
1fffa0de:	189a      	adds	r2, r3, r2
1fffa0e0:	eb41 73e3 	adc.w	r3, r1, r3, asr #31
	announce_remaining = 0;
1fffa0e4:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
1fffa0e6:	e9c7 2300 	strd	r2, r3, [r7]
	announce_remaining = 0;
1fffa0ea:	f8c9 4000 	str.w	r4, [r9]

	sys_clock_set_timeout(next_timeout(), false);
1fffa0ee:	f7ff fef5 	bl	1fff9edc <next_timeout>
1fffa0f2:	4621      	mov	r1, r4
1fffa0f4:	f7ff f9b2 	bl	1fff945c <sys_clock_set_timeout>
	__asm__ volatile(
1fffa0f8:	f388 8811 	msr	BASEPRI, r8
1fffa0fc:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&timeout_lock, key);

#ifdef CONFIG_TIMESLICING
	z_time_slice();
#endif
}
1fffa100:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	z_time_slice();
1fffa104:	f7ff bdc4 	b.w	1fff9c90 <z_time_slice>
1fffa108:	20000008 	.word	0x20000008
1fffa10c:	2000015c 	.word	0x2000015c
1fffa110:	20000110 	.word	0x20000110

1fffa114 <boot_banner>:
	printk("***** delaying boot " DELAY_STR "ms (per build configuration) *****\n");
	k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
#endif /* defined(CONFIG_BOOT_DELAY) && (CONFIG_BOOT_DELAY > 0) */

#if CONFIG_BOOT_BANNER
	printk("*** Booting Zephyr OS build " BANNER_VERSION BANNER_POSTFIX " ***\n");
1fffa114:	4801      	ldr	r0, [pc, #4]	; (1fffa11c <boot_banner+0x8>)
1fffa116:	f000 b808 	b.w	1fffa12a <printk>
1fffa11a:	bf00      	nop
1fffa11c:	1fffabcf 	.word	0x1fffabcf

1fffa120 <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
1fffa120:	4770      	bx	lr

1fffa122 <main>:
    my_rproc_start(&remote_proc);
    my_rproc_stop(&remote_proc);
    my_rproc_kick(&remote_proc, 0);

    return 0;
1fffa122:	2000      	movs	r0, #0
1fffa124:	4770      	bx	lr

1fffa126 <arch_printk_char_out>:
}
1fffa126:	2000      	movs	r0, #0
1fffa128:	4770      	bx	lr

1fffa12a <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
1fffa12a:	b40f      	push	{r0, r1, r2, r3}
1fffa12c:	b507      	push	{r0, r1, r2, lr}
1fffa12e:	a904      	add	r1, sp, #16
1fffa130:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
1fffa134:	9101      	str	r1, [sp, #4]

	vprintk(fmt, ap);
1fffa136:	f7fe f9f7 	bl	1fff8528 <vprintk>

	va_end(ap);
}
1fffa13a:	b003      	add	sp, #12
1fffa13c:	f85d eb04 	ldr.w	lr, [sp], #4
1fffa140:	b004      	add	sp, #16
1fffa142:	4770      	bx	lr

1fffa144 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
1fffa144:	4604      	mov	r4, r0
1fffa146:	b508      	push	{r3, lr}
1fffa148:	4608      	mov	r0, r1
1fffa14a:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
1fffa14c:	461a      	mov	r2, r3
1fffa14e:	47a0      	blx	r4
	if (z_syscall_trap()) {
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_Z_CURRENT_GET);
	}
#endif
	compiler_barrier();
	return z_impl_z_current_get();
1fffa150:	f7ff fe3a 	bl	1fff9dc8 <z_impl_z_current_get>
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_THREAD_ABORT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_abort(thread);
1fffa154:	f7ff f86a 	bl	1fff922c <z_impl_k_thread_abort>

1fffa158 <encode_uint>:
{
1fffa158:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
1fffa15c:	469a      	mov	sl, r3
	bool upcase = isupper((int)conv->specifier);
1fffa15e:	78d3      	ldrb	r3, [r2, #3]
	switch (specifier) {
1fffa160:	2b6f      	cmp	r3, #111	; 0x6f
{
1fffa162:	4680      	mov	r8, r0
1fffa164:	460f      	mov	r7, r1
1fffa166:	4615      	mov	r5, r2
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
1fffa168:	f1a3 0b41 	sub.w	fp, r3, #65	; 0x41
	switch (specifier) {
1fffa16c:	d029      	beq.n	1fffa1c2 <encode_uint+0x6a>
1fffa16e:	d824      	bhi.n	1fffa1ba <encode_uint+0x62>
		return 10;
1fffa170:	2b58      	cmp	r3, #88	; 0x58
1fffa172:	bf0c      	ite	eq
1fffa174:	2610      	moveq	r6, #16
1fffa176:	260a      	movne	r6, #10
	char *bp = bps + (bpe - bps);
1fffa178:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
		unsigned int lsv = (unsigned int)(value % radix);
1fffa17c:	4632      	mov	r2, r6
1fffa17e:	2300      	movs	r3, #0
1fffa180:	4640      	mov	r0, r8
1fffa182:	4639      	mov	r1, r7
1fffa184:	f7fe f85a 	bl	1fff823c <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
1fffa188:	2a09      	cmp	r2, #9
1fffa18a:	b2d4      	uxtb	r4, r2
1fffa18c:	d81e      	bhi.n	1fffa1cc <encode_uint+0x74>
1fffa18e:	3430      	adds	r4, #48	; 0x30
	} while ((value != 0) && (bps < bp));
1fffa190:	45b0      	cmp	r8, r6
		*--bp = (lsv <= 9) ? ('0' + lsv)
1fffa192:	b2e4      	uxtb	r4, r4
	} while ((value != 0) && (bps < bp));
1fffa194:	f177 0700 	sbcs.w	r7, r7, #0
		*--bp = (lsv <= 9) ? ('0' + lsv)
1fffa198:	f809 4d01 	strb.w	r4, [r9, #-1]!
	} while ((value != 0) && (bps < bp));
1fffa19c:	d301      	bcc.n	1fffa1a2 <encode_uint+0x4a>
1fffa19e:	45d1      	cmp	r9, sl
1fffa1a0:	d811      	bhi.n	1fffa1c6 <encode_uint+0x6e>
	if (conv->flag_hash) {
1fffa1a2:	782b      	ldrb	r3, [r5, #0]
1fffa1a4:	069b      	lsls	r3, r3, #26
1fffa1a6:	d505      	bpl.n	1fffa1b4 <encode_uint+0x5c>
		if (radix == 8) {
1fffa1a8:	2e08      	cmp	r6, #8
1fffa1aa:	d115      	bne.n	1fffa1d8 <encode_uint+0x80>
			conv->altform_0 = true;
1fffa1ac:	78ab      	ldrb	r3, [r5, #2]
1fffa1ae:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
1fffa1b2:	70ab      	strb	r3, [r5, #2]
}
1fffa1b4:	4648      	mov	r0, r9
1fffa1b6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
1fffa1ba:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 10;
1fffa1be:	2b70      	cmp	r3, #112	; 0x70
1fffa1c0:	e7d7      	b.n	1fffa172 <encode_uint+0x1a>
	switch (specifier) {
1fffa1c2:	2608      	movs	r6, #8
1fffa1c4:	e7d8      	b.n	1fffa178 <encode_uint+0x20>
		value /= radix;
1fffa1c6:	4680      	mov	r8, r0
1fffa1c8:	460f      	mov	r7, r1
1fffa1ca:	e7d7      	b.n	1fffa17c <encode_uint+0x24>
		*--bp = (lsv <= 9) ? ('0' + lsv)
1fffa1cc:	f1bb 0f19 	cmp.w	fp, #25
1fffa1d0:	bf94      	ite	ls
1fffa1d2:	3437      	addls	r4, #55	; 0x37
1fffa1d4:	3457      	addhi	r4, #87	; 0x57
1fffa1d6:	e7db      	b.n	1fffa190 <encode_uint+0x38>
		} else if (radix == 16) {
1fffa1d8:	2e10      	cmp	r6, #16
1fffa1da:	d1eb      	bne.n	1fffa1b4 <encode_uint+0x5c>
			conv->altform_0c = true;
1fffa1dc:	78ab      	ldrb	r3, [r5, #2]
1fffa1de:	f043 0310 	orr.w	r3, r3, #16
1fffa1e2:	e7e6      	b.n	1fffa1b2 <encode_uint+0x5a>

1fffa1e4 <outs>:
{
1fffa1e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
1fffa1e8:	4607      	mov	r7, r0
1fffa1ea:	4688      	mov	r8, r1
1fffa1ec:	4615      	mov	r5, r2
1fffa1ee:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
1fffa1f0:	4614      	mov	r4, r2
1fffa1f2:	42b4      	cmp	r4, r6
1fffa1f4:	d305      	bcc.n	1fffa202 <outs+0x1e>
1fffa1f6:	b10e      	cbz	r6, 1fffa1fc <outs+0x18>
	return (int)count;
1fffa1f8:	1b60      	subs	r0, r4, r5
1fffa1fa:	e008      	b.n	1fffa20e <outs+0x2a>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
1fffa1fc:	7823      	ldrb	r3, [r4, #0]
1fffa1fe:	2b00      	cmp	r3, #0
1fffa200:	d0fa      	beq.n	1fffa1f8 <outs+0x14>
		int rc = out((int)*sp++, ctx);
1fffa202:	f814 0b01 	ldrb.w	r0, [r4], #1
1fffa206:	4641      	mov	r1, r8
1fffa208:	47b8      	blx	r7
		if (rc < 0) {
1fffa20a:	2800      	cmp	r0, #0
1fffa20c:	daf1      	bge.n	1fffa1f2 <outs+0xe>
}
1fffa20e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

1fffa212 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_ENFORCE_ZEPHYR_STDINT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
1fffa212:	4770      	bx	lr

1fffa214 <z_arm_fatal_error>:
{

	if (esf != NULL) {
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
1fffa214:	f000 b99c 	b.w	1fffa550 <z_fatal_error>

1fffa218 <z_do_kernel_oops>:
 *
 * @param esf exception frame
 * @param callee_regs Callee-saved registers (R4-R11)
 */
void z_do_kernel_oops(const z_arch_esf_t *esf, _callee_saved_t *callee_regs)
{
1fffa218:	4601      	mov	r1, r0
	z_fatal_error(reason, esf);
1fffa21a:	6800      	ldr	r0, [r0, #0]
1fffa21c:	f000 b998 	b.w	1fffa550 <z_fatal_error>

1fffa220 <z_irq_spurious>:
 */
void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
1fffa220:	2100      	movs	r1, #0
1fffa222:	2001      	movs	r0, #1
1fffa224:	f7ff bff6 	b.w	1fffa214 <z_arm_fatal_error>

1fffa228 <z_arm_nmi>:
 * Simply call what is installed in 'static void(*handler)(void)'.
 *
 */

void z_arm_nmi(void)
{
1fffa228:	b508      	push	{r3, lr}
	handler();
1fffa22a:	f7fe fddd 	bl	1fff8de8 <z_SysNmiOnReset>
	z_arm_int_exit();
}
1fffa22e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
1fffa232:	f7fe be91 	b.w	1fff8f58 <z_arm_exc_exit>

1fffa236 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
1fffa236:	4603      	mov	r3, r0
	size_t n = 0;
1fffa238:	2000      	movs	r0, #0

	while (*s != '\0') {
1fffa23a:	5c1a      	ldrb	r2, [r3, r0]
1fffa23c:	b902      	cbnz	r2, 1fffa240 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
1fffa23e:	4770      	bx	lr
		n++;
1fffa240:	3001      	adds	r0, #1
1fffa242:	e7fa      	b.n	1fffa23a <strlen+0x4>

1fffa244 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
1fffa244:	4603      	mov	r3, r0
	size_t n = 0;
1fffa246:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
1fffa248:	5c1a      	ldrb	r2, [r3, r0]
1fffa24a:	b10a      	cbz	r2, 1fffa250 <strnlen+0xc>
1fffa24c:	4288      	cmp	r0, r1
1fffa24e:	d100      	bne.n	1fffa252 <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
1fffa250:	4770      	bx	lr
		n++;
1fffa252:	3001      	adds	r0, #1
1fffa254:	e7f8      	b.n	1fffa248 <strnlen+0x4>

1fffa256 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
1fffa256:	b510      	push	{r4, lr}
1fffa258:	1e43      	subs	r3, r0, #1
1fffa25a:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
1fffa25c:	4291      	cmp	r1, r2
1fffa25e:	d100      	bne.n	1fffa262 <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
1fffa260:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
1fffa262:	f811 4b01 	ldrb.w	r4, [r1], #1
1fffa266:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
1fffa26a:	e7f7      	b.n	1fffa25c <memcpy+0x6>

1fffa26c <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
1fffa26c:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
1fffa26e:	4402      	add	r2, r0
	unsigned char *d_byte = (unsigned char *)buf;
1fffa270:	4603      	mov	r3, r0
	while (n > 0) {
1fffa272:	4293      	cmp	r3, r2
1fffa274:	d100      	bne.n	1fffa278 <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
1fffa276:	4770      	bx	lr
		*(d_byte++) = c_byte;
1fffa278:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
1fffa27c:	e7f9      	b.n	1fffa272 <memset+0x6>

1fffa27e <_stdout_hook_default>:
}
1fffa27e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
1fffa282:	4770      	bx	lr

1fffa284 <pinctrl_lookup_state>:

#include <zephyr/drivers/pinctrl.h>

int pinctrl_lookup_state(const struct pinctrl_dev_config *config, uint8_t id,
			 const struct pinctrl_state **state)
{
1fffa284:	b530      	push	{r4, r5, lr}
	*state = &config->states[0];
1fffa286:	6803      	ldr	r3, [r0, #0]
1fffa288:	6013      	str	r3, [r2, #0]
	while (*state < &config->states[config->state_cnt]) {
1fffa28a:	7905      	ldrb	r5, [r0, #4]
1fffa28c:	6804      	ldr	r4, [r0, #0]
1fffa28e:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
1fffa292:	42a3      	cmp	r3, r4
1fffa294:	d302      	bcc.n	1fffa29c <pinctrl_lookup_state+0x18>
		}

		(*state)++;
	}

	return -ENOENT;
1fffa296:	f06f 0001 	mvn.w	r0, #1
}
1fffa29a:	bd30      	pop	{r4, r5, pc}
		if (id == (*state)->id) {
1fffa29c:	795c      	ldrb	r4, [r3, #5]
1fffa29e:	428c      	cmp	r4, r1
1fffa2a0:	d001      	beq.n	1fffa2a6 <pinctrl_lookup_state+0x22>
		(*state)++;
1fffa2a2:	3308      	adds	r3, #8
1fffa2a4:	e7f0      	b.n	1fffa288 <pinctrl_lookup_state+0x4>
			return 0;
1fffa2a6:	2000      	movs	r0, #0
1fffa2a8:	e7f7      	b.n	1fffa29a <pinctrl_lookup_state+0x16>

1fffa2aa <imx_pinctrl_init>:
#elif defined(CONFIG_SOC_MIMX8MQ6)
	CLOCK_EnableClock(kCLOCK_Iomux);
#endif /* CONFIG_SOC_SERIES_IMX_RT */

	return 0;
}
1fffa2aa:	2000      	movs	r0, #0
1fffa2ac:	4770      	bx	lr

1fffa2ae <pinctrl_configure_pins>:
{
1fffa2ae:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (uint8_t i = 0U; i < pin_cnt; i++) {
1fffa2b0:	2400      	movs	r4, #0
1fffa2b2:	b2e3      	uxtb	r3, r4
1fffa2b4:	4299      	cmp	r1, r3
1fffa2b6:	d801      	bhi.n	1fffa2bc <pinctrl_configure_pins+0xe>
}
1fffa2b8:	2000      	movs	r0, #0
1fffa2ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uint32_t input_daisy = pins[i].pinmux.input_daisy;
1fffa2bc:	7b03      	ldrb	r3, [r0, #12]
		uint32_t pin_ctrl_flags = pins[i].pin_ctrl_flags;
1fffa2be:	6902      	ldr	r2, [r0, #16]
		uint32_t input_register = pins[i].pinmux.input_register;
1fffa2c0:	6885      	ldr	r5, [r0, #8]
		*((volatile uint32_t *)((uintptr_t)mux_register)) =
1fffa2c2:	f8d0 c000 	ldr.w	ip, [r0]
		uint32_t config_register = pins[i].pinmux.config_register;
1fffa2c6:	6847      	ldr	r7, [r0, #4]
		uint32_t input_daisy = pins[i].pinmux.input_daisy;
1fffa2c8:	091e      	lsrs	r6, r3, #4
			IOMUXC_SW_MUX_CTL_PAD_SION(MCUX_IMX_INPUT_ENABLE(pin_ctrl_flags));
1fffa2ca:	ea4f 7ed2 	mov.w	lr, r2, lsr #31
		uint32_t mux_mode = pins[i].pinmux.mux_mode;
1fffa2ce:	f003 030f 	and.w	r3, r3, #15
			IOMUXC_SW_MUX_CTL_PAD_MUX_MODE(mux_mode) |
1fffa2d2:	ea43 130e 	orr.w	r3, r3, lr, lsl #4
		*((volatile uint32_t *)((uintptr_t)mux_register)) =
1fffa2d6:	f8cc 3000 	str.w	r3, [ip]
		if (input_register) {
1fffa2da:	b115      	cbz	r5, 1fffa2e2 <pinctrl_configure_pins+0x34>
				IOMUXC_SELECT_INPUT_DAISY(input_daisy);
1fffa2dc:	f006 0607 	and.w	r6, r6, #7
			*((volatile uint32_t *)((uintptr_t)input_register)) =
1fffa2e0:	602e      	str	r6, [r5, #0]
		if (config_register) {
1fffa2e2:	b117      	cbz	r7, 1fffa2ea <pinctrl_configure_pins+0x3c>
				pin_ctrl_flags & (~(0x1 << MCUX_IMX_INPUT_ENABLE_SHIFT));
1fffa2e4:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
			*((volatile uint32_t *)((uintptr_t)config_register)) =
1fffa2e8:	603a      	str	r2, [r7, #0]
	for (uint8_t i = 0U; i < pin_cnt; i++) {
1fffa2ea:	3401      	adds	r4, #1
1fffa2ec:	3014      	adds	r0, #20
1fffa2ee:	e7e0      	b.n	1fffa2b2 <pinctrl_configure_pins+0x4>

1fffa2f0 <uart_imx_poll_out>:
	UART_Type *uart = UART_STRUCT(dev);
1fffa2f0:	6843      	ldr	r3, [r0, #4]
1fffa2f2:	681b      	ldr	r3, [r3, #0]
1fffa2f4:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
	while (!UART_GetStatusFlag(uart, uartStatusTxReady)) {
1fffa2f8:	0492      	lsls	r2, r2, #18
1fffa2fa:	d5fb      	bpl.n	1fffa2f4 <uart_imx_poll_out+0x4>
    UART_UTXD_REG(base) = (data & UART_UTXD_TX_DATA_MASK);
1fffa2fc:	6419      	str	r1, [r3, #64]	; 0x40
}
1fffa2fe:	4770      	bx	lr

1fffa300 <uart_imx_fifo_fill>:
{
1fffa300:	b510      	push	{r4, lr}
	UART_Type *uart = UART_STRUCT(dev);
1fffa302:	6843      	ldr	r3, [r0, #4]
1fffa304:	681b      	ldr	r3, [r3, #0]
	unsigned int num_tx = 0U;
1fffa306:	2000      	movs	r0, #0
	while (((size - num_tx) > 0) &&
1fffa308:	4290      	cmp	r0, r2
1fffa30a:	d003      	beq.n	1fffa314 <uart_imx_fifo_fill+0x14>
    return (bool)((*uart_reg >> (flag & 0x0000FFFF)) & 0x1);
1fffa30c:	f8d3 4094 	ldr.w	r4, [r3, #148]	; 0x94
1fffa310:	04a4      	lsls	r4, r4, #18
1fffa312:	d400      	bmi.n	1fffa316 <uart_imx_fifo_fill+0x16>
}
1fffa314:	bd10      	pop	{r4, pc}
    UART_UTXD_REG(base) = (data & UART_UTXD_TX_DATA_MASK);
1fffa316:	5c0c      	ldrb	r4, [r1, r0]
1fffa318:	641c      	str	r4, [r3, #64]	; 0x40
		num_tx++;
1fffa31a:	3001      	adds	r0, #1
1fffa31c:	e7f4      	b.n	1fffa308 <uart_imx_fifo_fill+0x8>

1fffa31e <uart_imx_irq_tx_ready>:
	UART_Type *uart = UART_STRUCT(dev);
1fffa31e:	6843      	ldr	r3, [r0, #4]
    uart_reg = (uint32_t *)((uint32_t)base + (flag >> 16));
1fffa320:	681b      	ldr	r3, [r3, #0]
    return (bool)((*uart_reg >> (flag & 0x0000FFFF)) & 0x1);
1fffa322:	f8d3 0094 	ldr.w	r0, [r3, #148]	; 0x94
}
1fffa326:	f3c0 3040 	ubfx	r0, r0, #13, #1
1fffa32a:	4770      	bx	lr

1fffa32c <uart_imx_irq_rx_ready>:
	UART_Type *uart = UART_STRUCT(dev);
1fffa32c:	6843      	ldr	r3, [r0, #4]
    uart_reg = (uint32_t *)((uint32_t)base + (flag >> 16));
1fffa32e:	681b      	ldr	r3, [r3, #0]
    return (bool)((*uart_reg >> (flag & 0x0000FFFF)) & 0x1);
1fffa330:	f8d3 0094 	ldr.w	r0, [r3, #148]	; 0x94
}
1fffa334:	f3c0 2040 	ubfx	r0, r0, #9, #1
1fffa338:	4770      	bx	lr

1fffa33a <uart_imx_irq_is_pending>:

static int uart_imx_irq_is_pending(const struct device *dev)
{
	UART_Type *uart = UART_STRUCT(dev);
1fffa33a:	6843      	ldr	r3, [r0, #4]
    uart_reg = (uint32_t *)((uint32_t)base + (flag >> 16));
1fffa33c:	681b      	ldr	r3, [r3, #0]
    return (bool)((*uart_reg >> (flag & 0x0000FFFF)) & 0x1);
1fffa33e:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94

	return UART_GetStatusFlag(uart, uartStatusRxReady) ||
1fffa342:	0592      	lsls	r2, r2, #22
1fffa344:	bf5a      	itte	pl
1fffa346:	f8d3 0094 	ldrpl.w	r0, [r3, #148]	; 0x94
1fffa34a:	f3c0 3040 	ubfxpl	r0, r0, #13, #1
1fffa34e:	2001      	movmi	r0, #1
		UART_GetStatusFlag(uart, uartStatusTxReady);
}
1fffa350:	4770      	bx	lr

1fffa352 <uart_imx_irq_update>:

static int uart_imx_irq_update(const struct device *dev)
{
	return 1;
}
1fffa352:	2001      	movs	r0, #1
1fffa354:	4770      	bx	lr

1fffa356 <uart_imx_irq_callback_set>:

static void uart_imx_irq_callback_set(const struct device *dev,
				      uart_irq_callback_user_data_t cb,
				      void *cb_data)
{
	struct imx_uart_data *data = dev->data;
1fffa356:	6903      	ldr	r3, [r0, #16]

	data->callback = cb;
	data->cb_data = cb_data;
1fffa358:	e9c3 1200 	strd	r1, r2, [r3]
}
1fffa35c:	4770      	bx	lr

1fffa35e <uart_imx_isr>:
 *
 * @param arg Argument to ISR.
 */
void uart_imx_isr(const struct device *dev)
{
	struct imx_uart_data *data = dev->data;
1fffa35e:	6902      	ldr	r2, [r0, #16]

	if (data->callback) {
1fffa360:	6813      	ldr	r3, [r2, #0]
1fffa362:	b10b      	cbz	r3, 1fffa368 <uart_imx_isr+0xa>
		data->callback(dev, data->cb_data);
1fffa364:	6851      	ldr	r1, [r2, #4]
1fffa366:	4718      	bx	r3
	}
}
1fffa368:	4770      	bx	lr

1fffa36a <irq_config_func_0>:
									\
	UART_IMX_CONFIG_FUNC(n)						\
									\
	UART_IMX_INIT_CFG(n);

DT_INST_FOREACH_STATUS_OKAY(UART_IMX_INIT)
1fffa36a:	b508      	push	{r3, lr}
1fffa36c:	2010      	movs	r0, #16
1fffa36e:	2200      	movs	r2, #0
1fffa370:	2103      	movs	r1, #3
1fffa372:	f7fe fd21 	bl	1fff8db8 <z_arm_irq_priority_set>
1fffa376:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
1fffa37a:	2010      	movs	r0, #16
1fffa37c:	f7fe bd0e 	b.w	1fff8d9c <arch_irq_enable>

1fffa380 <uart_imx_init>:
{
1fffa380:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	UART_Type *uart = UART_STRUCT(dev);
1fffa384:	6846      	ldr	r6, [r0, #4]
{
1fffa386:	b088      	sub	sp, #32
	UART_Type *uart = UART_STRUCT(dev);
1fffa388:	6834      	ldr	r4, [r6, #0]
{
1fffa38a:	4607      	mov	r7, r0
	__asm__ volatile(
1fffa38c:	f04f 0310 	mov.w	r3, #16
1fffa390:	f3ef 8811 	mrs	r8, BASEPRI
1fffa394:	f383 8812 	msr	BASEPRI_MAX, r3
1fffa398:	f3bf 8f6f 	isb	sy
	uart_init_config_t initConfig = {
1fffa39c:	2218      	movs	r2, #24
1fffa39e:	2100      	movs	r1, #0
1fffa3a0:	a802      	add	r0, sp, #8
1fffa3a2:	f7ff ff63 	bl	1fffa26c <memset>
		.baudRate	= config->baud_rate,
1fffa3a6:	6873      	ldr	r3, [r6, #4]
	uart_init_config_t initConfig = {
1fffa3a8:	9303      	str	r3, [sp, #12]
1fffa3aa:	2320      	movs	r3, #32
1fffa3ac:	9304      	str	r3, [sp, #16]
1fffa3ae:	2306      	movs	r3, #6
1fffa3b0:	9307      	str	r3, [sp, #28]
				      uint8_t id)
{
	int ret;
	const struct pinctrl_state *state;

	ret = pinctrl_lookup_state(config, id, &state);
1fffa3b2:	68f0      	ldr	r0, [r6, #12]
1fffa3b4:	aa01      	add	r2, sp, #4
1fffa3b6:	2100      	movs	r1, #0
1fffa3b8:	f7ff ff64 	bl	1fffa284 <pinctrl_lookup_state>
	if (ret < 0) {
1fffa3bc:	1e05      	subs	r5, r0, #0
1fffa3be:	db30      	blt.n	1fffa422 <uart_imx_init+0xa2>
		return ret;
	}

	return pinctrl_apply_state_direct(config, state);
1fffa3c0:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
1fffa3c2:	2200      	movs	r2, #0
1fffa3c4:	7919      	ldrb	r1, [r3, #4]
1fffa3c6:	6818      	ldr	r0, [r3, #0]
1fffa3c8:	f7ff ff71 	bl	1fffa2ae <pinctrl_configure_pins>
	if (err) {
1fffa3cc:	4605      	mov	r5, r0
1fffa3ce:	bb40      	cbnz	r0, 1fffa422 <uart_imx_init+0xa2>
	initConfig.clockRate  = get_uart_clock_freq(uart);
1fffa3d0:	4620      	mov	r0, r4
1fffa3d2:	f7ff f96d 	bl	1fff96b0 <get_uart_clock_freq>
	UART_Init(uart, &initConfig);
1fffa3d6:	a902      	add	r1, sp, #8
	initConfig.clockRate  = get_uart_clock_freq(uart);
1fffa3d8:	9002      	str	r0, [sp, #8]
	UART_Init(uart, &initConfig);
1fffa3da:	4620      	mov	r0, r4
1fffa3dc:	f000 f85d 	bl	1fffa49a <UART_Init>
 * @param watermark The Tx FIFO watermark.
 */
static inline void UART_SetTxFifoWatermark(UART_Type* base, uint8_t watermark)
{
    assert((watermark >= 2) && (watermark <= 32));
    UART_UFCR_REG(base) = (UART_UFCR_REG(base) & ~UART_UFCR_TXTL_MASK) | UART_UFCR_TXTL(watermark);
1fffa3e0:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
1fffa3e4:	f423 437c 	bic.w	r3, r3, #64512	; 0xfc00
1fffa3e8:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
1fffa3ec:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
 * @param watermark The Rx FIFO watermark.
 */
static inline void UART_SetRxFifoWatermark(UART_Type* base, uint8_t watermark)
{
    assert(watermark <= 32);
    UART_UFCR_REG(base) = (UART_UFCR_REG(base) & ~UART_UFCR_RXTL_MASK) | UART_UFCR_RXTL(watermark);
1fffa3f0:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
1fffa3f4:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
1fffa3f8:	f043 0301 	orr.w	r3, r3, #1
1fffa3fc:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
	__asm__ volatile(
1fffa400:	f388 8811 	msr	BASEPRI, r8
1fffa404:	f3bf 8f6f 	isb	sy
	config->irq_config_func(dev);
1fffa408:	6933      	ldr	r3, [r6, #16]
1fffa40a:	4638      	mov	r0, r7
1fffa40c:	4798      	blx	r3
	UART_SetModemMode(uart, config->modem_mode);
1fffa40e:	7a31      	ldrb	r1, [r6, #8]
1fffa410:	4620      	mov	r0, r4
1fffa412:	f000 f87a 	bl	1fffa50a <UART_SetModemMode>
    UART_UCR1_REG(base) |= UART_UCR1_UARTEN_MASK;
1fffa416:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
1fffa41a:	f043 0301 	orr.w	r3, r3, #1
1fffa41e:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
}
1fffa422:	4628      	mov	r0, r5
1fffa424:	b008      	add	sp, #32
1fffa426:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

1fffa42a <CCM_GetRootDivider>:
    *pre = (CCM_REG(ccmRoot) & CCM_TARGET_ROOT_PRE_PODF_MASK) >> CCM_TARGET_ROOT_PRE_PODF_SHIFT;
1fffa42a:	6808      	ldr	r0, [r1, #0]
1fffa42c:	f3c0 4002 	ubfx	r0, r0, #16, #3
1fffa430:	6010      	str	r0, [r2, #0]
    *post = (CCM_REG(ccmRoot) & CCM_TARGET_ROOT_POST_PODF_MASK) >> CCM_TARGET_ROOT_POST_PODF_SHIFT;
1fffa432:	680a      	ldr	r2, [r1, #0]
1fffa434:	f002 023f 	and.w	r2, r2, #63	; 0x3f
1fffa438:	601a      	str	r2, [r3, #0]
}
1fffa43a:	4770      	bx	lr

1fffa43c <UART_Deinit>:
    UART_UCR1_REG(base) &= ~UART_UCR1_UARTEN_MASK;
1fffa43c:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
1fffa440:	f023 0301 	bic.w	r3, r3, #1
1fffa444:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
    UART_UCR2_REG(base)  = UART_UCR2_SRST_MASK;
1fffa448:	2201      	movs	r2, #1
    UART_UCR1_REG(base)  = 0x0;
1fffa44a:	2300      	movs	r3, #0
1fffa44c:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
    UART_UCR2_REG(base)  = UART_UCR2_SRST_MASK;
1fffa450:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
    UART_UCR3_REG(base)  = UART_UCR3_DSR_MASK |
1fffa454:	f44f 62e0 	mov.w	r2, #1792	; 0x700
1fffa458:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
    UART_UCR4_REG(base)  = UART_UCR4_CTSTL(32);
1fffa45c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
1fffa460:	f8c0 208c 	str.w	r2, [r0, #140]	; 0x8c
    UART_UFCR_REG(base)  = UART_UFCR_TXTL(2) | UART_UFCR_RXTL(1);
1fffa464:	f640 0201 	movw	r2, #2049	; 0x801
1fffa468:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
    UART_UESC_REG(base)  = UART_UESC_ESC_CHAR(0x2B);
1fffa46c:	222b      	movs	r2, #43	; 0x2b
1fffa46e:	f8c0 209c 	str.w	r2, [r0, #156]	; 0x9c
    UART_UTS_REG(base)   = UART_UTS_TXEMPTY_MASK | UART_UTS_RXEMPTY_MASK;
1fffa472:	2260      	movs	r2, #96	; 0x60
    UART_UTIM_REG(base)  = 0x0;
1fffa474:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
    UART_ONEMS_REG(base) = 0x0;
1fffa478:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
    UART_UTS_REG(base)   = UART_UTS_TXEMPTY_MASK | UART_UTS_RXEMPTY_MASK;
1fffa47c:	f8c0 20b4 	str.w	r2, [r0, #180]	; 0xb4
    UART_UMCR_REG(base)  = 0x0;
1fffa480:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
    UART_UCR2_REG(base) &= ~UART_UCR2_SRST_MASK;
1fffa484:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
1fffa488:	f023 0301 	bic.w	r3, r3, #1
1fffa48c:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    while (!(UART_UCR2_REG(base) & UART_UCR2_SRST_MASK));
1fffa490:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
1fffa494:	07db      	lsls	r3, r3, #31
1fffa496:	d5fb      	bpl.n	1fffa490 <UART_Deinit+0x54>
}
1fffa498:	4770      	bx	lr

1fffa49a <UART_Init>:
{
1fffa49a:	b538      	push	{r3, r4, r5, lr}
    UART_UCR1_REG(base) &= ~UART_UCR1_UARTEN_MASK;
1fffa49c:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
1fffa4a0:	f023 0301 	bic.w	r3, r3, #1
1fffa4a4:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
    UART_Deinit(base);
1fffa4a8:	f7ff ffc8 	bl	1fffa43c <UART_Deinit>
    UART_UCR2_REG(base) |= (initConfig->wordLength |
1fffa4ac:	e9d1 3502 	ldrd	r3, r5, [r1, #8]
1fffa4b0:	f8d0 2084 	ldr.w	r2, [r0, #132]	; 0x84
1fffa4b4:	432b      	orrs	r3, r5
1fffa4b6:	4313      	orrs	r3, r2
1fffa4b8:	690a      	ldr	r2, [r1, #16]
1fffa4ba:	4313      	orrs	r3, r2
1fffa4bc:	694a      	ldr	r2, [r1, #20]
1fffa4be:	4313      	orrs	r3, r2
1fffa4c0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
1fffa4c4:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    UART_UCR3_REG(base) |= UART_UCR3_RXDMUXSEL_MASK;
1fffa4c8:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
1fffa4cc:	f043 0304 	orr.w	r3, r3, #4
1fffa4d0:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
    UART_SetBaudRate(base, initConfig->clockRate, initConfig->baudRate);
1fffa4d4:	e9d1 1200 	ldrd	r1, r2, [r1]
}
1fffa4d8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    UART_SetBaudRate(base, initConfig->clockRate, initConfig->baudRate);
1fffa4dc:	f7ff b87a 	b.w	1fff95d4 <UART_SetBaudRate>

1fffa4e0 <UART_SetIntCmd>:
 *                 specific UART interrupt source. The available interrupt
 *                 source can be select from uart_int_source enumeration.
 *
 *END**************************************************************************/
void UART_SetIntCmd(UART_Type* base, uint32_t intSource, bool enable)
{
1fffa4e0:	b510      	push	{r4, lr}
    volatile uint32_t* uart_reg = 0;
    uint32_t uart_mask = 0;

    uart_reg = (uint32_t *)((uint32_t)base + (intSource >> 16));
1fffa4e2:	0c0b      	lsrs	r3, r1, #16
    uart_mask = (1 << (intSource & 0x0000FFFF));
1fffa4e4:	2401      	movs	r4, #1
1fffa4e6:	b289      	uxth	r1, r1
1fffa4e8:	fa04 f101 	lsl.w	r1, r4, r1

    if (enable)
1fffa4ec:	b11a      	cbz	r2, 1fffa4f6 <UART_SetIntCmd+0x16>
        *uart_reg |= uart_mask;
1fffa4ee:	58c2      	ldr	r2, [r0, r3]
1fffa4f0:	430a      	orrs	r2, r1
    else
        *uart_reg &= ~uart_mask;
1fffa4f2:	50c2      	str	r2, [r0, r3]
}
1fffa4f4:	bd10      	pop	{r4, pc}
        *uart_reg &= ~uart_mask;
1fffa4f6:	58c2      	ldr	r2, [r0, r3]
1fffa4f8:	ea22 0201 	bic.w	r2, r2, r1
1fffa4fc:	e7f9      	b.n	1fffa4f2 <UART_SetIntCmd+0x12>

1fffa4fe <UART_ClearStatusFlag>:
void UART_ClearStatusFlag(UART_Type* base, uint32_t flag)
{
    volatile uint32_t* uart_reg = 0;
    uint32_t uart_mask = 0;

    uart_reg = (uint32_t *)((uint32_t)base + (flag >> 16));
1fffa4fe:	0c0a      	lsrs	r2, r1, #16
    uart_mask = (1 << (flag & 0x0000FFFF));
1fffa500:	2301      	movs	r3, #1
1fffa502:	b289      	uxth	r1, r1
1fffa504:	408b      	lsls	r3, r1

    /* write 1 to clear. */
    *uart_reg = uart_mask;
1fffa506:	5083      	str	r3, [r0, r2]
}
1fffa508:	4770      	bx	lr

1fffa50a <UART_SetModemMode>:
void UART_SetModemMode(UART_Type* base, uint32_t mode)
{
    assert((mode == uartModemModeDce) || (mode == uartModemModeDte));

    if (uartModemModeDce == mode)
        UART_UFCR_REG(base) &= ~UART_UFCR_DCEDTE_MASK;
1fffa50a:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
    if (uartModemModeDce == mode)
1fffa50e:	b921      	cbnz	r1, 1fffa51a <UART_SetModemMode+0x10>
        UART_UFCR_REG(base) &= ~UART_UFCR_DCEDTE_MASK;
1fffa510:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    else
        UART_UFCR_REG(base) |= UART_UFCR_DCEDTE_MASK;
1fffa514:	f8c0 3090 	str.w	r3, [r0, #144]	; 0x90
}
1fffa518:	4770      	bx	lr
        UART_UFCR_REG(base) |= UART_UFCR_DCEDTE_MASK;
1fffa51a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
1fffa51e:	e7f9      	b.n	1fffa514 <UART_SetModemMode+0xa>

1fffa520 <z_device_state_init>:

	while (dev < __device_end) {
		z_object_init(dev);
		++dev;
	}
}
1fffa520:	4770      	bx	lr

1fffa522 <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
1fffa522:	b140      	cbz	r0, 1fffa536 <z_device_is_ready+0x14>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
1fffa524:	68c3      	ldr	r3, [r0, #12]
1fffa526:	7858      	ldrb	r0, [r3, #1]
1fffa528:	f010 0001 	ands.w	r0, r0, #1
1fffa52c:	bf1e      	ittt	ne
1fffa52e:	7818      	ldrbne	r0, [r3, #0]
1fffa530:	fab0 f080 	clzne	r0, r0
1fffa534:	0940      	lsrne	r0, r0, #5
}
1fffa536:	4770      	bx	lr

1fffa538 <arch_system_halt>:
	__asm__ volatile(
1fffa538:	f04f 0210 	mov.w	r2, #16
1fffa53c:	f3ef 8311 	mrs	r3, BASEPRI
1fffa540:	f382 8812 	msr	BASEPRI_MAX, r2
1fffa544:	f3bf 8f6f 	isb	sy
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
1fffa548:	e7fe      	b.n	1fffa548 <arch_system_halt+0x10>

1fffa54a <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
1fffa54a:	b508      	push	{r3, lr}
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
1fffa54c:	f7ff fff4 	bl	1fffa538 <arch_system_halt>

1fffa550 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
1fffa550:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1fffa552:	4605      	mov	r5, r0
1fffa554:	460e      	mov	r6, r1
1fffa556:	f04f 0310 	mov.w	r3, #16
1fffa55a:	f3ef 8711 	mrs	r7, BASEPRI
1fffa55e:	f383 8812 	msr	BASEPRI_MAX, r3
1fffa562:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
1fffa566:	f7ff fc2f 	bl	1fff9dc8 <z_impl_z_current_get>

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
#endif

	k_sys_fatal_error_handler(reason, esf);
1fffa56a:	4631      	mov	r1, r6
1fffa56c:	4604      	mov	r4, r0
1fffa56e:	4628      	mov	r0, r5
1fffa570:	f7ff ffeb 	bl	1fffa54a <k_sys_fatal_error_handler>
	__asm__ volatile(
1fffa574:	f387 8811 	msr	BASEPRI, r7
1fffa578:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
1fffa57c:	4620      	mov	r0, r4
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
1fffa57e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
1fffa582:	f7fe be53 	b.w	1fff922c <z_impl_k_thread_abort>

1fffa586 <z_early_memset>:
	(void) memset(dst, c, n);
1fffa586:	f7ff be71 	b.w	1fffa26c <memset>

1fffa58a <z_early_memcpy>:
	(void) memcpy(dst, src, n);
1fffa58a:	f7ff be64 	b.w	1fffa256 <memcpy>

1fffa58e <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
1fffa58e:	b508      	push	{r3, lr}
	__asm__ volatile(
1fffa590:	f04f 0210 	mov.w	r2, #16
1fffa594:	f3ef 8311 	mrs	r3, BASEPRI
1fffa598:	f382 8812 	msr	BASEPRI_MAX, r2
1fffa59c:	f3bf 8f6f 	isb	sy
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
1fffa5a0:	f7fe fbee 	bl	1fff8d80 <arch_cpu_idle>
1fffa5a4:	e7f4      	b.n	1fffa590 <idle+0x2>

1fffa5a6 <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
1fffa5a6:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
1fffa5aa:	6013      	str	r3, [r2, #0]
	next->prev = prev;
1fffa5ac:	605a      	str	r2, [r3, #4]
	node->next = NULL;
1fffa5ae:	2300      	movs	r3, #0
	node->prev = NULL;
1fffa5b0:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dnode_init(node);
}
1fffa5b4:	4770      	bx	lr

1fffa5b6 <unpend_thread_no_timeout>:
{
1fffa5b6:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
1fffa5b8:	f7ff fff5 	bl	1fffa5a6 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
1fffa5bc:	7b43      	ldrb	r3, [r0, #13]
1fffa5be:	f023 0302 	bic.w	r3, r3, #2
1fffa5c2:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
1fffa5c4:	2300      	movs	r3, #0
1fffa5c6:	6083      	str	r3, [r0, #8]
}
1fffa5c8:	bd08      	pop	{r3, pc}

1fffa5ca <z_ready_thread>:
{
1fffa5ca:	b510      	push	{r4, lr}
1fffa5cc:	f04f 0310 	mov.w	r3, #16
1fffa5d0:	f3ef 8411 	mrs	r4, BASEPRI
1fffa5d4:	f383 8812 	msr	BASEPRI_MAX, r3
1fffa5d8:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
1fffa5dc:	f7ff fb00 	bl	1fff9be0 <ready_thread>
	__asm__ volatile(
1fffa5e0:	f384 8811 	msr	BASEPRI, r4
1fffa5e4:	f3bf 8f6f 	isb	sy
}
1fffa5e8:	bd10      	pop	{r4, pc}

1fffa5ea <z_sched_wake_thread>:
{
1fffa5ea:	b538      	push	{r3, r4, r5, lr}
1fffa5ec:	4604      	mov	r4, r0
	__asm__ volatile(
1fffa5ee:	f04f 0310 	mov.w	r3, #16
1fffa5f2:	f3ef 8511 	mrs	r5, BASEPRI
1fffa5f6:	f383 8812 	msr	BASEPRI_MAX, r3
1fffa5fa:	f3bf 8f6f 	isb	sy
		if (!killed) {
1fffa5fe:	7b43      	ldrb	r3, [r0, #13]
1fffa600:	f013 0f28 	tst.w	r3, #40	; 0x28
1fffa604:	d10b      	bne.n	1fffa61e <z_sched_wake_thread+0x34>
			if (thread->base.pended_on != NULL) {
1fffa606:	6883      	ldr	r3, [r0, #8]
1fffa608:	b10b      	cbz	r3, 1fffa60e <z_sched_wake_thread+0x24>
				unpend_thread_no_timeout(thread);
1fffa60a:	f7ff ffd4 	bl	1fffa5b6 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_PRESTART;
1fffa60e:	7b63      	ldrb	r3, [r4, #13]
			if (is_timeout) {
1fffa610:	b951      	cbnz	r1, 1fffa628 <z_sched_wake_thread+0x3e>
1fffa612:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
1fffa616:	7363      	strb	r3, [r4, #13]
			ready_thread(thread);
1fffa618:	4620      	mov	r0, r4
1fffa61a:	f7ff fae1 	bl	1fff9be0 <ready_thread>
	__asm__ volatile(
1fffa61e:	f385 8811 	msr	BASEPRI, r5
1fffa622:	f3bf 8f6f 	isb	sy
}
1fffa626:	bd38      	pop	{r3, r4, r5, pc}
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
1fffa628:	f003 03eb 	and.w	r3, r3, #235	; 0xeb
}
1fffa62c:	e7f3      	b.n	1fffa616 <z_sched_wake_thread+0x2c>

1fffa62e <z_thread_timeout>:
	z_sched_wake_thread(thread, true);
1fffa62e:	2101      	movs	r1, #1
1fffa630:	3818      	subs	r0, #24
1fffa632:	f7ff bfda 	b.w	1fffa5ea <z_sched_wake_thread>

1fffa636 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
1fffa636:	4603      	mov	r3, r0
1fffa638:	b920      	cbnz	r0, 1fffa644 <z_reschedule_irqlock+0xe>
1fffa63a:	f3ef 8205 	mrs	r2, IPSR
1fffa63e:	b90a      	cbnz	r2, 1fffa644 <z_reschedule_irqlock+0xe>
	ret = arch_swap(key);
1fffa640:	f7fe bbfa 	b.w	1fff8e38 <arch_swap>
1fffa644:	f383 8811 	msr	BASEPRI, r3
1fffa648:	f3bf 8f6f 	isb	sy
}
1fffa64c:	4770      	bx	lr

1fffa64e <z_reschedule_unlocked>:
	__asm__ volatile(
1fffa64e:	f04f 0310 	mov.w	r3, #16
1fffa652:	f3ef 8011 	mrs	r0, BASEPRI
1fffa656:	f383 8812 	msr	BASEPRI_MAX, r3
1fffa65a:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
1fffa65e:	f7ff bfea 	b.w	1fffa636 <z_reschedule_irqlock>

1fffa662 <z_abort_timeout>:
{
1fffa662:	b510      	push	{r4, lr}
1fffa664:	f04f 0210 	mov.w	r2, #16
1fffa668:	f3ef 8411 	mrs	r4, BASEPRI
1fffa66c:	f382 8812 	msr	BASEPRI_MAX, r2
1fffa670:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
1fffa674:	6803      	ldr	r3, [r0, #0]
1fffa676:	b13b      	cbz	r3, 1fffa688 <z_abort_timeout+0x26>
			remove_timeout(to);
1fffa678:	f7ff fc50 	bl	1fff9f1c <remove_timeout>
			ret = 0;
1fffa67c:	2000      	movs	r0, #0
	__asm__ volatile(
1fffa67e:	f384 8811 	msr	BASEPRI, r4
1fffa682:	f3bf 8f6f 	isb	sy
}
1fffa686:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
1fffa688:	f06f 0015 	mvn.w	r0, #21
1fffa68c:	e7f7      	b.n	1fffa67e <z_abort_timeout+0x1c>
	...
