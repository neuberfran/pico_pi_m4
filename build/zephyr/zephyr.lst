
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

1fff8000 <_vector_table>:
1fff8000:	30 1f 00 20 b9 96 ff 1f e9 b4 ff 1f 8d 96 ff 1f     0.. ............
1fff8010:	8d 96 ff 1f 8d 96 ff 1f 8d 96 ff 1f 00 00 00 00     ................
	...
1fff802c:	6d 93 ff 1f 8d 96 ff 1f 00 00 00 00 25 93 ff 1f     m...........%...
1fff803c:	41 99 ff 1f                                         A...

1fff8040 <_irq_vector_table>:
1fff8040:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff8050:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff8060:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff8070:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff8080:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff8090:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff80a0:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff80b0:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff80c0:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff80d0:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff80e0:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff80f0:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff8100:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff8110:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff8120:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff8130:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff8140:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff8150:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff8160:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff8170:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff8180:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff8190:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff81a0:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff81b0:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff81c0:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff81d0:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff81e0:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff81f0:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff8200:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff8210:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff8220:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f     ................
1fff8230:	e9 93 ff 1f e9 93 ff 1f e9 93 ff 1f                 ............

Disassembly of section text:

1fff823c <__aeabi_uldivmod>:
1fff823c:	b953      	cbnz	r3, 1fff8254 <__aeabi_uldivmod+0x18>
1fff823e:	b94a      	cbnz	r2, 1fff8254 <__aeabi_uldivmod+0x18>
1fff8240:	2900      	cmp	r1, #0
1fff8242:	bf08      	it	eq
1fff8244:	2800      	cmpeq	r0, #0
1fff8246:	bf1c      	itt	ne
1fff8248:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
1fff824c:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
1fff8250:	f000 b80c 	b.w	1fff826c <__aeabi_idiv0>
1fff8254:	f1ad 0c08 	sub.w	ip, sp, #8
1fff8258:	e96d ce04 	strd	ip, lr, [sp, #-16]!
1fff825c:	f000 f808 	bl	1fff8270 <__udivmoddi4>
1fff8260:	f8dd e004 	ldr.w	lr, [sp, #4]
1fff8264:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
1fff8268:	b004      	add	sp, #16
1fff826a:	4770      	bx	lr

1fff826c <__aeabi_idiv0>:
1fff826c:	4770      	bx	lr
1fff826e:	bf00      	nop

1fff8270 <__udivmoddi4>:
1fff8270:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
1fff8274:	4686      	mov	lr, r0
1fff8276:	468c      	mov	ip, r1
1fff8278:	4608      	mov	r0, r1
1fff827a:	9e08      	ldr	r6, [sp, #32]
1fff827c:	4615      	mov	r5, r2
1fff827e:	4674      	mov	r4, lr
1fff8280:	4619      	mov	r1, r3
1fff8282:	2b00      	cmp	r3, #0
1fff8284:	f040 80c2 	bne.w	1fff840c <__udivmoddi4+0x19c>
1fff8288:	4285      	cmp	r5, r0
1fff828a:	fab2 f282 	clz	r2, r2
1fff828e:	d945      	bls.n	1fff831c <__udivmoddi4+0xac>
1fff8290:	b14a      	cbz	r2, 1fff82a6 <__udivmoddi4+0x36>
1fff8292:	f1c2 0320 	rsb	r3, r2, #32
1fff8296:	fa00 fc02 	lsl.w	ip, r0, r2
1fff829a:	fa2e f303 	lsr.w	r3, lr, r3
1fff829e:	4095      	lsls	r5, r2
1fff82a0:	ea43 0c0c 	orr.w	ip, r3, ip
1fff82a4:	4094      	lsls	r4, r2
1fff82a6:	ea4f 4e15 	mov.w	lr, r5, lsr #16
1fff82aa:	b2a8      	uxth	r0, r5
1fff82ac:	fbbc f8fe 	udiv	r8, ip, lr
1fff82b0:	0c23      	lsrs	r3, r4, #16
1fff82b2:	fb0e cc18 	mls	ip, lr, r8, ip
1fff82b6:	fb08 f900 	mul.w	r9, r8, r0
1fff82ba:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
1fff82be:	4599      	cmp	r9, r3
1fff82c0:	d928      	bls.n	1fff8314 <__udivmoddi4+0xa4>
1fff82c2:	18eb      	adds	r3, r5, r3
1fff82c4:	f108 37ff 	add.w	r7, r8, #4294967295	; 0xffffffff
1fff82c8:	d204      	bcs.n	1fff82d4 <__udivmoddi4+0x64>
1fff82ca:	4599      	cmp	r9, r3
1fff82cc:	d902      	bls.n	1fff82d4 <__udivmoddi4+0x64>
1fff82ce:	f1a8 0702 	sub.w	r7, r8, #2
1fff82d2:	442b      	add	r3, r5
1fff82d4:	eba3 0309 	sub.w	r3, r3, r9
1fff82d8:	b2a4      	uxth	r4, r4
1fff82da:	fbb3 fcfe 	udiv	ip, r3, lr
1fff82de:	fb0e 331c 	mls	r3, lr, ip, r3
1fff82e2:	fb0c f000 	mul.w	r0, ip, r0
1fff82e6:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
1fff82ea:	42a0      	cmp	r0, r4
1fff82ec:	d914      	bls.n	1fff8318 <__udivmoddi4+0xa8>
1fff82ee:	192c      	adds	r4, r5, r4
1fff82f0:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
1fff82f4:	d204      	bcs.n	1fff8300 <__udivmoddi4+0x90>
1fff82f6:	42a0      	cmp	r0, r4
1fff82f8:	d902      	bls.n	1fff8300 <__udivmoddi4+0x90>
1fff82fa:	f1ac 0302 	sub.w	r3, ip, #2
1fff82fe:	442c      	add	r4, r5
1fff8300:	1a24      	subs	r4, r4, r0
1fff8302:	ea43 4007 	orr.w	r0, r3, r7, lsl #16
1fff8306:	b11e      	cbz	r6, 1fff8310 <__udivmoddi4+0xa0>
1fff8308:	40d4      	lsrs	r4, r2
1fff830a:	2300      	movs	r3, #0
1fff830c:	6034      	str	r4, [r6, #0]
1fff830e:	6073      	str	r3, [r6, #4]
1fff8310:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
1fff8314:	4647      	mov	r7, r8
1fff8316:	e7dd      	b.n	1fff82d4 <__udivmoddi4+0x64>
1fff8318:	4663      	mov	r3, ip
1fff831a:	e7f1      	b.n	1fff8300 <__udivmoddi4+0x90>
1fff831c:	bb92      	cbnz	r2, 1fff8384 <__udivmoddi4+0x114>
1fff831e:	1b43      	subs	r3, r0, r5
1fff8320:	2101      	movs	r1, #1
1fff8322:	ea4f 4e15 	mov.w	lr, r5, lsr #16
1fff8326:	b2af      	uxth	r7, r5
1fff8328:	fbb3 fcfe 	udiv	ip, r3, lr
1fff832c:	0c20      	lsrs	r0, r4, #16
1fff832e:	fb0e 331c 	mls	r3, lr, ip, r3
1fff8332:	fb0c f807 	mul.w	r8, ip, r7
1fff8336:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
1fff833a:	4598      	cmp	r8, r3
1fff833c:	d962      	bls.n	1fff8404 <__udivmoddi4+0x194>
1fff833e:	18eb      	adds	r3, r5, r3
1fff8340:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
1fff8344:	d204      	bcs.n	1fff8350 <__udivmoddi4+0xe0>
1fff8346:	4598      	cmp	r8, r3
1fff8348:	d902      	bls.n	1fff8350 <__udivmoddi4+0xe0>
1fff834a:	f1ac 0002 	sub.w	r0, ip, #2
1fff834e:	442b      	add	r3, r5
1fff8350:	eba3 0308 	sub.w	r3, r3, r8
1fff8354:	b2a4      	uxth	r4, r4
1fff8356:	fbb3 fcfe 	udiv	ip, r3, lr
1fff835a:	fb0e 331c 	mls	r3, lr, ip, r3
1fff835e:	fb0c f707 	mul.w	r7, ip, r7
1fff8362:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
1fff8366:	42a7      	cmp	r7, r4
1fff8368:	d94e      	bls.n	1fff8408 <__udivmoddi4+0x198>
1fff836a:	192c      	adds	r4, r5, r4
1fff836c:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
1fff8370:	d204      	bcs.n	1fff837c <__udivmoddi4+0x10c>
1fff8372:	42a7      	cmp	r7, r4
1fff8374:	d902      	bls.n	1fff837c <__udivmoddi4+0x10c>
1fff8376:	f1ac 0302 	sub.w	r3, ip, #2
1fff837a:	442c      	add	r4, r5
1fff837c:	1be4      	subs	r4, r4, r7
1fff837e:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
1fff8382:	e7c0      	b.n	1fff8306 <__udivmoddi4+0x96>
1fff8384:	f1c2 0320 	rsb	r3, r2, #32
1fff8388:	fa20 f103 	lsr.w	r1, r0, r3
1fff838c:	4095      	lsls	r5, r2
1fff838e:	4090      	lsls	r0, r2
1fff8390:	fa2e f303 	lsr.w	r3, lr, r3
1fff8394:	4303      	orrs	r3, r0
1fff8396:	ea4f 4e15 	mov.w	lr, r5, lsr #16
1fff839a:	b2af      	uxth	r7, r5
1fff839c:	fbb1 fcfe 	udiv	ip, r1, lr
1fff83a0:	fb0e 101c 	mls	r0, lr, ip, r1
1fff83a4:	0c19      	lsrs	r1, r3, #16
1fff83a6:	fb0c f807 	mul.w	r8, ip, r7
1fff83aa:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
1fff83ae:	4588      	cmp	r8, r1
1fff83b0:	fa04 f402 	lsl.w	r4, r4, r2
1fff83b4:	d922      	bls.n	1fff83fc <__udivmoddi4+0x18c>
1fff83b6:	1869      	adds	r1, r5, r1
1fff83b8:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
1fff83bc:	d204      	bcs.n	1fff83c8 <__udivmoddi4+0x158>
1fff83be:	4588      	cmp	r8, r1
1fff83c0:	d902      	bls.n	1fff83c8 <__udivmoddi4+0x158>
1fff83c2:	f1ac 0002 	sub.w	r0, ip, #2
1fff83c6:	4429      	add	r1, r5
1fff83c8:	eba1 0108 	sub.w	r1, r1, r8
1fff83cc:	b29b      	uxth	r3, r3
1fff83ce:	fbb1 fcfe 	udiv	ip, r1, lr
1fff83d2:	fb0e 111c 	mls	r1, lr, ip, r1
1fff83d6:	fb0c f707 	mul.w	r7, ip, r7
1fff83da:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
1fff83de:	429f      	cmp	r7, r3
1fff83e0:	d90e      	bls.n	1fff8400 <__udivmoddi4+0x190>
1fff83e2:	18eb      	adds	r3, r5, r3
1fff83e4:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
1fff83e8:	d204      	bcs.n	1fff83f4 <__udivmoddi4+0x184>
1fff83ea:	429f      	cmp	r7, r3
1fff83ec:	d902      	bls.n	1fff83f4 <__udivmoddi4+0x184>
1fff83ee:	f1ac 0102 	sub.w	r1, ip, #2
1fff83f2:	442b      	add	r3, r5
1fff83f4:	1bdb      	subs	r3, r3, r7
1fff83f6:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
1fff83fa:	e792      	b.n	1fff8322 <__udivmoddi4+0xb2>
1fff83fc:	4660      	mov	r0, ip
1fff83fe:	e7e3      	b.n	1fff83c8 <__udivmoddi4+0x158>
1fff8400:	4661      	mov	r1, ip
1fff8402:	e7f7      	b.n	1fff83f4 <__udivmoddi4+0x184>
1fff8404:	4660      	mov	r0, ip
1fff8406:	e7a3      	b.n	1fff8350 <__udivmoddi4+0xe0>
1fff8408:	4663      	mov	r3, ip
1fff840a:	e7b7      	b.n	1fff837c <__udivmoddi4+0x10c>
1fff840c:	4283      	cmp	r3, r0
1fff840e:	d906      	bls.n	1fff841e <__udivmoddi4+0x1ae>
1fff8410:	b916      	cbnz	r6, 1fff8418 <__udivmoddi4+0x1a8>
1fff8412:	2100      	movs	r1, #0
1fff8414:	4608      	mov	r0, r1
1fff8416:	e77b      	b.n	1fff8310 <__udivmoddi4+0xa0>
1fff8418:	e9c6 e000 	strd	lr, r0, [r6]
1fff841c:	e7f9      	b.n	1fff8412 <__udivmoddi4+0x1a2>
1fff841e:	fab3 f783 	clz	r7, r3
1fff8422:	b98f      	cbnz	r7, 1fff8448 <__udivmoddi4+0x1d8>
1fff8424:	4283      	cmp	r3, r0
1fff8426:	d301      	bcc.n	1fff842c <__udivmoddi4+0x1bc>
1fff8428:	4572      	cmp	r2, lr
1fff842a:	d808      	bhi.n	1fff843e <__udivmoddi4+0x1ce>
1fff842c:	ebbe 0402 	subs.w	r4, lr, r2
1fff8430:	eb60 0303 	sbc.w	r3, r0, r3
1fff8434:	2001      	movs	r0, #1
1fff8436:	469c      	mov	ip, r3
1fff8438:	b91e      	cbnz	r6, 1fff8442 <__udivmoddi4+0x1d2>
1fff843a:	2100      	movs	r1, #0
1fff843c:	e768      	b.n	1fff8310 <__udivmoddi4+0xa0>
1fff843e:	4638      	mov	r0, r7
1fff8440:	e7fa      	b.n	1fff8438 <__udivmoddi4+0x1c8>
1fff8442:	e9c6 4c00 	strd	r4, ip, [r6]
1fff8446:	e7f8      	b.n	1fff843a <__udivmoddi4+0x1ca>
1fff8448:	f1c7 0c20 	rsb	ip, r7, #32
1fff844c:	40bb      	lsls	r3, r7
1fff844e:	fa22 f40c 	lsr.w	r4, r2, ip
1fff8452:	431c      	orrs	r4, r3
1fff8454:	fa2e f10c 	lsr.w	r1, lr, ip
1fff8458:	fa20 f30c 	lsr.w	r3, r0, ip
1fff845c:	40b8      	lsls	r0, r7
1fff845e:	4301      	orrs	r1, r0
1fff8460:	ea4f 4914 	mov.w	r9, r4, lsr #16
1fff8464:	fa0e f507 	lsl.w	r5, lr, r7
1fff8468:	fbb3 f8f9 	udiv	r8, r3, r9
1fff846c:	fa1f fe84 	uxth.w	lr, r4
1fff8470:	fb09 3018 	mls	r0, r9, r8, r3
1fff8474:	0c0b      	lsrs	r3, r1, #16
1fff8476:	fb08 fa0e 	mul.w	sl, r8, lr
1fff847a:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
1fff847e:	459a      	cmp	sl, r3
1fff8480:	fa02 f207 	lsl.w	r2, r2, r7
1fff8484:	d940      	bls.n	1fff8508 <__udivmoddi4+0x298>
1fff8486:	18e3      	adds	r3, r4, r3
1fff8488:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
1fff848c:	d204      	bcs.n	1fff8498 <__udivmoddi4+0x228>
1fff848e:	459a      	cmp	sl, r3
1fff8490:	d902      	bls.n	1fff8498 <__udivmoddi4+0x228>
1fff8492:	f1a8 0002 	sub.w	r0, r8, #2
1fff8496:	4423      	add	r3, r4
1fff8498:	eba3 030a 	sub.w	r3, r3, sl
1fff849c:	b289      	uxth	r1, r1
1fff849e:	fbb3 f8f9 	udiv	r8, r3, r9
1fff84a2:	fb09 3318 	mls	r3, r9, r8, r3
1fff84a6:	fb08 fe0e 	mul.w	lr, r8, lr
1fff84aa:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
1fff84ae:	458e      	cmp	lr, r1
1fff84b0:	d92c      	bls.n	1fff850c <__udivmoddi4+0x29c>
1fff84b2:	1861      	adds	r1, r4, r1
1fff84b4:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
1fff84b8:	d204      	bcs.n	1fff84c4 <__udivmoddi4+0x254>
1fff84ba:	458e      	cmp	lr, r1
1fff84bc:	d902      	bls.n	1fff84c4 <__udivmoddi4+0x254>
1fff84be:	f1a8 0302 	sub.w	r3, r8, #2
1fff84c2:	4421      	add	r1, r4
1fff84c4:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
1fff84c8:	fba0 9802 	umull	r9, r8, r0, r2
1fff84cc:	eba1 010e 	sub.w	r1, r1, lr
1fff84d0:	4541      	cmp	r1, r8
1fff84d2:	46ce      	mov	lr, r9
1fff84d4:	4643      	mov	r3, r8
1fff84d6:	d302      	bcc.n	1fff84de <__udivmoddi4+0x26e>
1fff84d8:	d106      	bne.n	1fff84e8 <__udivmoddi4+0x278>
1fff84da:	454d      	cmp	r5, r9
1fff84dc:	d204      	bcs.n	1fff84e8 <__udivmoddi4+0x278>
1fff84de:	ebb9 0e02 	subs.w	lr, r9, r2
1fff84e2:	eb68 0304 	sbc.w	r3, r8, r4
1fff84e6:	3801      	subs	r0, #1
1fff84e8:	2e00      	cmp	r6, #0
1fff84ea:	d0a6      	beq.n	1fff843a <__udivmoddi4+0x1ca>
1fff84ec:	ebb5 020e 	subs.w	r2, r5, lr
1fff84f0:	eb61 0103 	sbc.w	r1, r1, r3
1fff84f4:	fa01 fc0c 	lsl.w	ip, r1, ip
1fff84f8:	fa22 f307 	lsr.w	r3, r2, r7
1fff84fc:	ea4c 0303 	orr.w	r3, ip, r3
1fff8500:	40f9      	lsrs	r1, r7
1fff8502:	e9c6 3100 	strd	r3, r1, [r6]
1fff8506:	e798      	b.n	1fff843a <__udivmoddi4+0x1ca>
1fff8508:	4640      	mov	r0, r8
1fff850a:	e7c5      	b.n	1fff8498 <__udivmoddi4+0x228>
1fff850c:	4643      	mov	r3, r8
1fff850e:	e7d9      	b.n	1fff84c4 <__udivmoddi4+0x254>

1fff8510 <platform_ipm_callback>:
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
1fff8510:	4801      	ldr	r0, [pc, #4]	; (1fff8518 <platform_ipm_callback+0x8>)
1fff8512:	f002 b8b7 	b.w	1fffa684 <z_impl_k_sem_give>
1fff8516:	bf00      	nop
1fff8518:	20000100 	.word	0x20000100

1fff851c <mailbox_notify>:
	LOG_ERR("%s: unexpected ns service receive for name %s\n",
		__func__, name);
}

int mailbox_notify(void *priv, uint32_t id)
{
1fff851c:	b537      	push	{r0, r1, r2, r4, r5, lr}
1fff851e:	460a      	mov	r2, r1
				  const void *data, int size)
{
	const struct ipm_driver_api *api =
		(const struct ipm_driver_api *)ipmdev->api;

	return api->send(ipmdev, wait, id, data, size);
1fff8520:	4805      	ldr	r0, [pc, #20]	; (1fff8538 <mailbox_notify+0x1c>)
1fff8522:	2400      	movs	r4, #0
1fff8524:	6883      	ldr	r3, [r0, #8]
1fff8526:	9400      	str	r4, [sp, #0]
1fff8528:	681d      	ldr	r5, [r3, #0]
1fff852a:	4621      	mov	r1, r4
1fff852c:	4623      	mov	r3, r4
1fff852e:	47a8      	blx	r5

	LOG_DBG("%s: msg received\n", __func__);
	ipm_send(ipm_handle, 0, id, NULL, 0);

	return 0;
}
1fff8530:	4620      	mov	r0, r4
1fff8532:	b003      	add	sp, #12
1fff8534:	bd30      	pop	{r4, r5, pc}
1fff8536:	bf00      	nop
1fff8538:	1fffcb34 	.word	0x1fffcb34

1fff853c <app_rpmsg_tty>:

	printk("OpenAMP Linux sample client responder ended\n");
}

void app_rpmsg_tty(void *arg1, void *arg2, void *arg3)
{
1fff853c:	b5f0      	push	{r4, r5, r6, r7, lr}
1fff853e:	f5ad 7d05 	sub.w	sp, sp, #532	; 0x214
	return z_impl_k_sem_take(sem, timeout);
1fff8542:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
1fff8546:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
1fff854a:	4825      	ldr	r0, [pc, #148]	; (1fff85e0 <app_rpmsg_tty+0xa4>)

	k_sem_take(&data_tty_sem,  K_FOREVER);

	printk("\r\nOpenAMP[remote] Linux tty responder started\r\n");

	tty_ept.priv = &tty_msg;
1fff854c:	4c25      	ldr	r4, [pc, #148]	; (1fff85e4 <app_rpmsg_tty+0xa8>)
1fff854e:	4d26      	ldr	r5, [pc, #152]	; (1fff85e8 <app_rpmsg_tty+0xac>)
1fff8550:	4e23      	ldr	r6, [pc, #140]	; (1fff85e0 <app_rpmsg_tty+0xa4>)
			       rpmsg_recv_tty_callback, NULL);

	while (tty_ept.addr !=  RPMSG_ADDR_ANY) {
		k_sem_take(&data_tty_sem,  K_FOREVER);
		if (tty_msg.len) {
			snprintf(tx_buff, 13, "TTY 0x%04x: ", tty_ept.addr);
1fff8552:	4f26      	ldr	r7, [pc, #152]	; (1fff85ec <app_rpmsg_tty+0xb0>)
1fff8554:	f002 f8b6 	bl	1fffa6c4 <z_impl_k_sem_take>
	printk("\r\nOpenAMP[remote] Linux tty responder started\r\n");
1fff8558:	4825      	ldr	r0, [pc, #148]	; (1fff85f0 <app_rpmsg_tty+0xb4>)
1fff855a:	f002 fd81 	bl	1fffb060 <printk>
	ret = rpmsg_create_ept(&tty_ept, rpdev, "rpmsg-tty",
1fff855e:	2300      	movs	r3, #0
	tty_ept.priv = &tty_msg;
1fff8560:	63e5      	str	r5, [r4, #60]	; 0x3c
	ret = rpmsg_create_ept(&tty_ept, rpdev, "rpmsg-tty",
1fff8562:	9302      	str	r3, [sp, #8]
1fff8564:	4b23      	ldr	r3, [pc, #140]	; (1fff85f4 <app_rpmsg_tty+0xb8>)
1fff8566:	9301      	str	r3, [sp, #4]
1fff8568:	4923      	ldr	r1, [pc, #140]	; (1fff85f8 <app_rpmsg_tty+0xbc>)
1fff856a:	4a24      	ldr	r2, [pc, #144]	; (1fff85fc <app_rpmsg_tty+0xc0>)
1fff856c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
1fff8570:	9300      	str	r3, [sp, #0]
1fff8572:	6809      	ldr	r1, [r1, #0]
1fff8574:	4620      	mov	r0, r4
1fff8576:	f001 fd4d 	bl	1fffa014 <rpmsg_create_ept>
	while (tty_ept.addr !=  RPMSG_ADDR_ANY) {
1fff857a:	6a63      	ldr	r3, [r4, #36]	; 0x24
1fff857c:	3301      	adds	r3, #1
1fff857e:	d108      	bne.n	1fff8592 <app_rpmsg_tty+0x56>
			rpmsg_release_rx_buffer(&tty_ept, tty_msg.data);
		}
		tty_msg.len = 0;
		tty_msg.data = NULL;
	}
	rpmsg_destroy_ept(&tty_ept);
1fff8580:	4818      	ldr	r0, [pc, #96]	; (1fff85e4 <app_rpmsg_tty+0xa8>)
1fff8582:	f003 fdf6 	bl	1fffc172 <rpmsg_destroy_ept>

	printk("OpenAMP Linux TTY responder ended\n");
1fff8586:	481e      	ldr	r0, [pc, #120]	; (1fff8600 <app_rpmsg_tty+0xc4>)
1fff8588:	f002 fd6a 	bl	1fffb060 <printk>
}
1fff858c:	f50d 7d05 	add.w	sp, sp, #532	; 0x214
1fff8590:	bdf0      	pop	{r4, r5, r6, r7, pc}
1fff8592:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
1fff8596:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
1fff859a:	4630      	mov	r0, r6
1fff859c:	f002 f892 	bl	1fffa6c4 <z_impl_k_sem_take>
		if (tty_msg.len) {
1fff85a0:	686b      	ldr	r3, [r5, #4]
1fff85a2:	b1cb      	cbz	r3, 1fff85d8 <app_rpmsg_tty+0x9c>
			snprintf(tx_buff, 13, "TTY 0x%04x: ", tty_ept.addr);
1fff85a4:	6a63      	ldr	r3, [r4, #36]	; 0x24
1fff85a6:	463a      	mov	r2, r7
1fff85a8:	210d      	movs	r1, #13
1fff85aa:	a804      	add	r0, sp, #16
1fff85ac:	f001 f8b6 	bl	1fff971c <snprintf>
			memcpy(&tx_buff[12], tty_msg.data, tty_msg.len);
1fff85b0:	e9d5 1200 	ldrd	r1, r2, [r5]
1fff85b4:	a807      	add	r0, sp, #28
1fff85b6:	f002 ffe2 	bl	1fffb57e <memcpy>
			     int len)
{
	if (!ept)
		return RPMSG_ERR_PARAM;

	return rpmsg_send_offchannel_raw(ept, ept->addr, ept->dest_addr, data,
1fff85ba:	2301      	movs	r3, #1
1fff85bc:	9301      	str	r3, [sp, #4]
			rpmsg_send(&tty_ept, tx_buff, tty_msg.len + 13);
1fff85be:	686b      	ldr	r3, [r5, #4]
1fff85c0:	330d      	adds	r3, #13
1fff85c2:	9300      	str	r3, [sp, #0]
1fff85c4:	e9d4 1209 	ldrd	r1, r2, [r4, #36]	; 0x24
1fff85c8:	ab04      	add	r3, sp, #16
1fff85ca:	4620      	mov	r0, r4
1fff85cc:	f001 fcec 	bl	1fff9fa8 <rpmsg_send_offchannel_raw>
			rpmsg_release_rx_buffer(&tty_ept, tty_msg.data);
1fff85d0:	6829      	ldr	r1, [r5, #0]
1fff85d2:	4620      	mov	r0, r4
1fff85d4:	f003 fd8a 	bl	1fffc0ec <rpmsg_release_rx_buffer>
		tty_msg.len = 0;
1fff85d8:	2300      	movs	r3, #0
		tty_msg.data = NULL;
1fff85da:	e9c5 3300 	strd	r3, r3, [r5]
1fff85de:	e7cc      	b.n	1fff857a <app_rpmsg_tty+0x3e>
1fff85e0:	20000110 	.word	0x20000110
1fff85e4:	20000408 	.word	0x20000408
1fff85e8:	20000400 	.word	0x20000400
1fff85ec:	1fffd362 	.word	0x1fffd362
1fff85f0:	1fffd328 	.word	0x1fffd328
1fff85f4:	1fff8699 	.word	0x1fff8699
1fff85f8:	20000488 	.word	0x20000488
1fff85fc:	1fffd358 	.word	0x1fffd358
1fff8600:	1fffd36f 	.word	0x1fffd36f

1fff8604 <app_rpmsg_client_sample>:
{
1fff8604:	b5f0      	push	{r4, r5, r6, r7, lr}
1fff8606:	b085      	sub	sp, #20
1fff8608:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
1fff860c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
1fff8610:	4819      	ldr	r0, [pc, #100]	; (1fff8678 <app_rpmsg_client_sample+0x74>)
1fff8612:	4f19      	ldr	r7, [pc, #100]	; (1fff8678 <app_rpmsg_client_sample+0x74>)
		rpmsg_send(&sc_ept, sc_msg.data, sc_msg.len);
1fff8614:	4e19      	ldr	r6, [pc, #100]	; (1fff867c <app_rpmsg_client_sample+0x78>)
1fff8616:	4d1a      	ldr	r5, [pc, #104]	; (1fff8680 <app_rpmsg_client_sample+0x7c>)
1fff8618:	f002 f854 	bl	1fffa6c4 <z_impl_k_sem_take>
	printk("\r\nOpenAMP[remote] Linux sample client responder started\r\n");
1fff861c:	4819      	ldr	r0, [pc, #100]	; (1fff8684 <app_rpmsg_client_sample+0x80>)
1fff861e:	f002 fd1f 	bl	1fffb060 <printk>
	ret = rpmsg_create_ept(&sc_ept, rpdev, "rpmsg-client-sample",
1fff8622:	2300      	movs	r3, #0
1fff8624:	9302      	str	r3, [sp, #8]
1fff8626:	4b18      	ldr	r3, [pc, #96]	; (1fff8688 <app_rpmsg_client_sample+0x84>)
1fff8628:	9301      	str	r3, [sp, #4]
1fff862a:	4918      	ldr	r1, [pc, #96]	; (1fff868c <app_rpmsg_client_sample+0x88>)
1fff862c:	4a18      	ldr	r2, [pc, #96]	; (1fff8690 <app_rpmsg_client_sample+0x8c>)
1fff862e:	4814      	ldr	r0, [pc, #80]	; (1fff8680 <app_rpmsg_client_sample+0x7c>)
1fff8630:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
1fff8634:	9300      	str	r3, [sp, #0]
1fff8636:	6809      	ldr	r1, [r1, #0]
1fff8638:	f001 fcec 	bl	1fffa014 <rpmsg_create_ept>
1fff863c:	2464      	movs	r4, #100	; 0x64
1fff863e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
1fff8642:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
1fff8646:	4638      	mov	r0, r7
1fff8648:	f002 f83c 	bl	1fffa6c4 <z_impl_k_sem_take>
1fff864c:	2301      	movs	r3, #1
1fff864e:	9301      	str	r3, [sp, #4]
1fff8650:	6873      	ldr	r3, [r6, #4]
1fff8652:	9300      	str	r3, [sp, #0]
1fff8654:	e9d5 1209 	ldrd	r1, r2, [r5, #36]	; 0x24
1fff8658:	6833      	ldr	r3, [r6, #0]
1fff865a:	4809      	ldr	r0, [pc, #36]	; (1fff8680 <app_rpmsg_client_sample+0x7c>)
1fff865c:	f001 fca4 	bl	1fff9fa8 <rpmsg_send_offchannel_raw>
	while (msg_cnt < 100) {
1fff8660:	3c01      	subs	r4, #1
1fff8662:	d1ec      	bne.n	1fff863e <app_rpmsg_client_sample+0x3a>
	rpmsg_destroy_ept(&sc_ept);
1fff8664:	4806      	ldr	r0, [pc, #24]	; (1fff8680 <app_rpmsg_client_sample+0x7c>)
1fff8666:	f003 fd84 	bl	1fffc172 <rpmsg_destroy_ept>
	printk("OpenAMP Linux sample client responder ended\n");
1fff866a:	480a      	ldr	r0, [pc, #40]	; (1fff8694 <app_rpmsg_client_sample+0x90>)
}
1fff866c:	b005      	add	sp, #20
1fff866e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	printk("OpenAMP Linux sample client responder ended\n");
1fff8672:	f002 bcf5 	b.w	1fffb060 <printk>
1fff8676:	bf00      	nop
1fff8678:	200000f0 	.word	0x200000f0
1fff867c:	20000000 	.word	0x20000000
1fff8680:	20000448 	.word	0x20000448
1fff8684:	1fffd392 	.word	0x1fffd392
1fff8688:	1fff86b9 	.word	0x1fff86b9
1fff868c:	20000488 	.word	0x20000488
1fff8690:	1fffd3cc 	.word	0x1fffd3cc
1fff8694:	1fffd3e0 	.word	0x1fffd3e0

1fff8698 <rpmsg_recv_tty_callback>:
{
1fff8698:	b570      	push	{r4, r5, r6, lr}
1fff869a:	9e04      	ldr	r6, [sp, #16]
1fff869c:	460d      	mov	r5, r1
1fff869e:	4614      	mov	r4, r2
	rpmsg_hold_rx_buffer(ept, data);
1fff86a0:	f003 fd1c 	bl	1fffc0dc <rpmsg_hold_rx_buffer>
	tty_msg->len = len;
1fff86a4:	e9c6 5400 	strd	r5, r4, [r6]
	z_impl_k_sem_give(sem);
1fff86a8:	4802      	ldr	r0, [pc, #8]	; (1fff86b4 <rpmsg_recv_tty_callback+0x1c>)
1fff86aa:	f001 ffeb 	bl	1fffa684 <z_impl_k_sem_give>
}
1fff86ae:	2000      	movs	r0, #0
1fff86b0:	bd70      	pop	{r4, r5, r6, pc}
1fff86b2:	bf00      	nop
1fff86b4:	20000110 	.word	0x20000110

1fff86b8 <rpmsg_recv_cs_callback>:
{
1fff86b8:	b538      	push	{r3, r4, r5, lr}
	memcpy(sc_msg.data, data, len);
1fff86ba:	4d05      	ldr	r5, [pc, #20]	; (1fff86d0 <rpmsg_recv_cs_callback+0x18>)
{
1fff86bc:	4614      	mov	r4, r2
	memcpy(sc_msg.data, data, len);
1fff86be:	6828      	ldr	r0, [r5, #0]
1fff86c0:	f002 ff5d 	bl	1fffb57e <memcpy>
	sc_msg.len = len;
1fff86c4:	606c      	str	r4, [r5, #4]
1fff86c6:	4803      	ldr	r0, [pc, #12]	; (1fff86d4 <rpmsg_recv_cs_callback+0x1c>)
1fff86c8:	f001 ffdc 	bl	1fffa684 <z_impl_k_sem_give>
}
1fff86cc:	2000      	movs	r0, #0
1fff86ce:	bd38      	pop	{r3, r4, r5, pc}
1fff86d0:	20000000 	.word	0x20000000
1fff86d4:	200000f0 	.word	0x200000f0

1fff86d8 <platform_init>:
{
1fff86d8:	b570      	push	{r4, r5, r6, lr}
	struct metal_init_params metal_params = METAL_INIT_DEFAULTS;
1fff86da:	4a2e      	ldr	r2, [pc, #184]	; (1fff8794 <platform_init+0xbc>)
1fff86dc:	e892 0003 	ldmia.w	r2, {r0, r1}
{
1fff86e0:	b08a      	sub	sp, #40	; 0x28
	struct metal_init_params metal_params = METAL_INIT_DEFAULTS;
1fff86e2:	ab08      	add	r3, sp, #32
1fff86e4:	e883 0003 	stmia.w	r3, {r0, r1}
	status = metal_init(&metal_params);
1fff86e8:	4618      	mov	r0, r3
1fff86ea:	f001 fbb9 	bl	1fff9e60 <metal_init>
	if (status) {
1fff86ee:	b9e0      	cbnz	r0, 1fff872a <platform_init+0x52>
	status = metal_register_generic_device(&shm_device);
1fff86f0:	4829      	ldr	r0, [pc, #164]	; (1fff8798 <platform_init+0xc0>)
1fff86f2:	f001 fb93 	bl	1fff9e1c <metal_register_generic_device>
	if (status) {
1fff86f6:	b9c0      	cbnz	r0, 1fff872a <platform_init+0x52>
	status = metal_device_open("generic", SHM_DEVICE_NAME, &device);
1fff86f8:	4928      	ldr	r1, [pc, #160]	; (1fff879c <platform_init+0xc4>)
1fff86fa:	4829      	ldr	r0, [pc, #164]	; (1fff87a0 <platform_init+0xc8>)
1fff86fc:	aa07      	add	r2, sp, #28
1fff86fe:	f003 fb0e 	bl	1fffbd1e <metal_device_open>
	if (status) {
1fff8702:	4604      	mov	r4, r0
1fff8704:	b988      	cbnz	r0, 1fff872a <platform_init+0x52>
	metal_io_init(&device->regions[0], (void *)SHM_START_ADDR, &shm_physmap,
1fff8706:	e9cd 0001 	strd	r0, r0, [sp, #4]
1fff870a:	9807      	ldr	r0, [sp, #28]
1fff870c:	4a25      	ldr	r2, [pc, #148]	; (1fff87a4 <platform_init+0xcc>)
1fff870e:	4926      	ldr	r1, [pc, #152]	; (1fff87a8 <platform_init+0xd0>)
1fff8710:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
1fff8714:	f44f 4300 	mov.w	r3, #32768	; 0x8000
1fff8718:	9500      	str	r5, [sp, #0]
1fff871a:	300c      	adds	r0, #12
1fff871c:	f003 fb27 	bl	1fffbd6e <metal_io_init>
	shm_io = metal_device_io_region(device, 0);
1fff8720:	9b07      	ldr	r3, [sp, #28]
 * @return I/O accessor handle, or NULL on failure.
 */
static inline struct metal_io_region *
metal_device_io_region(struct metal_device *device, unsigned int index)
{
	return (index < device->num_regions
1fff8722:	4a22      	ldr	r2, [pc, #136]	; (1fff87ac <platform_init+0xd4>)
		? &device->regions[index]
		: NULL);
1fff8724:	6899      	ldr	r1, [r3, #8]
1fff8726:	b921      	cbnz	r1, 1fff8732 <platform_init+0x5a>
1fff8728:	6011      	str	r1, [r2, #0]
		return -1;
1fff872a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
1fff872e:	b00a      	add	sp, #40	; 0x28
1fff8730:	bd70      	pop	{r4, r5, r6, pc}
1fff8732:	330c      	adds	r3, #12
	rsc_table_get(&rsc_tab_addr, &rsc_size);
1fff8734:	a906      	add	r1, sp, #24
1fff8736:	a805      	add	r0, sp, #20
	shm_io = metal_device_io_region(device, 0);
1fff8738:	6013      	str	r3, [r2, #0]
	rsc_table_get(&rsc_tab_addr, &rsc_size);
1fff873a:	f000 fcfb 	bl	1fff9134 <rsc_table_get>
	rsc_table = (struct st_resource_table *)rsc_tab_addr;
1fff873e:	9a05      	ldr	r2, [sp, #20]
1fff8740:	4b1b      	ldr	r3, [pc, #108]	; (1fff87b0 <platform_init+0xd8>)
	metal_io_init(&device->regions[1], rsc_table,
1fff8742:	9807      	ldr	r0, [sp, #28]
	rsc_table = (struct st_resource_table *)rsc_tab_addr;
1fff8744:	601a      	str	r2, [r3, #0]
	metal_io_init(&device->regions[1], rsc_table,
1fff8746:	4611      	mov	r1, r2
1fff8748:	9b06      	ldr	r3, [sp, #24]
1fff874a:	9500      	str	r5, [sp, #0]
1fff874c:	e9cd 4401 	strd	r4, r4, [sp, #4]
1fff8750:	3044      	adds	r0, #68	; 0x44
1fff8752:	f003 fb0c 	bl	1fffbd6e <metal_io_init>
	rsc_io = metal_device_io_region(device, 1);
1fff8756:	9b07      	ldr	r3, [sp, #28]
1fff8758:	689a      	ldr	r2, [r3, #8]
1fff875a:	2a01      	cmp	r2, #1
1fff875c:	4a15      	ldr	r2, [pc, #84]	; (1fff87b4 <platform_init+0xdc>)
1fff875e:	d916      	bls.n	1fff878e <platform_init+0xb6>
1fff8760:	3344      	adds	r3, #68	; 0x44
1fff8762:	6013      	str	r3, [r2, #0]
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
1fff8764:	4d14      	ldr	r5, [pc, #80]	; (1fff87b8 <platform_init+0xe0>)
1fff8766:	4628      	mov	r0, r5
1fff8768:	f003 ffc8 	bl	1fffc6fc <z_device_is_ready>
	if (!device_is_ready(ipm_handle)) {
1fff876c:	2800      	cmp	r0, #0
1fff876e:	d0dc      	beq.n	1fff872a <platform_init+0x52>
					 ipm_callback_t cb, void *user_data)
{
	const struct ipm_driver_api *api =
		(const struct ipm_driver_api *)ipmdev->api;

	api->register_callback(ipmdev, cb, user_data);
1fff8770:	68ae      	ldr	r6, [r5, #8]
1fff8772:	4912      	ldr	r1, [pc, #72]	; (1fff87bc <platform_init+0xe4>)
1fff8774:	6873      	ldr	r3, [r6, #4]
1fff8776:	4622      	mov	r2, r4
1fff8778:	4628      	mov	r0, r5
1fff877a:	4798      	blx	r3
					 int enable)
{
	const struct ipm_driver_api *api =
		(const struct ipm_driver_api *)ipmdev->api;

	return api->set_enabled(ipmdev, enable);
1fff877c:	2101      	movs	r1, #1
1fff877e:	6933      	ldr	r3, [r6, #16]
1fff8780:	4628      	mov	r0, r5
1fff8782:	4798      	blx	r3
	if (status) {
1fff8784:	3800      	subs	r0, #0
1fff8786:	bf18      	it	ne
1fff8788:	2001      	movne	r0, #1
1fff878a:	4240      	negs	r0, r0
1fff878c:	e7cf      	b.n	1fff872e <platform_init+0x56>
	rsc_io = metal_device_io_region(device, 1);
1fff878e:	6014      	str	r4, [r2, #0]
	if (!rsc_io) {
1fff8790:	e7cb      	b.n	1fff872a <platform_init+0x52>
1fff8792:	bf00      	nop
1fff8794:	1fffcfac 	.word	0x1fffcfac
1fff8798:	20000008 	.word	0x20000008
1fff879c:	1fffd40d 	.word	0x1fffd40d
1fff87a0:	1fffd411 	.word	0x1fffd411
1fff87a4:	20000094 	.word	0x20000094
1fff87a8:	1fff8000 	.word	0x1fff8000
1fff87ac:	20000554 	.word	0x20000554
1fff87b0:	2000048c 	.word	0x2000048c
1fff87b4:	20000544 	.word	0x20000544
1fff87b8:	1fffcb34 	.word	0x1fffcb34
1fff87bc:	1fff8511 	.word	0x1fff8511

1fff87c0 <platform_create_rpmsg_vdev>:
{
1fff87c0:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	vdev = rproc_virtio_create_vdev(VIRTIO_DEV_DEVICE, VDEV_ID,
1fff87c4:	4f25      	ldr	r7, [pc, #148]	; (1fff885c <platform_create_rpmsg_vdev+0x9c>)
1fff87c6:	4e26      	ldr	r6, [pc, #152]	; (1fff8860 <platform_create_rpmsg_vdev+0xa0>)

#if (CONFIG_OPENAMP_RSC_TABLE_NUM_RPMSG_BUFF > 0)

inline struct fw_rsc_vdev *rsc_table_to_vdev(void *rsc_table)
{
	return &((struct fw_resource_table *)rsc_table)->vdev;
1fff87c8:	683a      	ldr	r2, [r7, #0]
{
1fff87ca:	461d      	mov	r5, r3
	vdev = rproc_virtio_create_vdev(VIRTIO_DEV_DEVICE, VDEV_ID,
1fff87cc:	4b25      	ldr	r3, [pc, #148]	; (1fff8864 <platform_create_rpmsg_vdev+0xa4>)
1fff87ce:	f04f 0800 	mov.w	r8, #0
1fff87d2:	e9cd 8300 	strd	r8, r3, [sp]
1fff87d6:	f8cd 8008 	str.w	r8, [sp, #8]
1fff87da:	6833      	ldr	r3, [r6, #0]
1fff87dc:	3218      	adds	r2, #24
1fff87de:	21ff      	movs	r1, #255	; 0xff
1fff87e0:	2001      	movs	r0, #1
1fff87e2:	f001 fd6b 	bl	1fffa2bc <rproc_virtio_create_vdev>
	if (!vdev) {
1fff87e6:	4604      	mov	r4, r0
1fff87e8:	b190      	cbz	r0, 1fff8810 <platform_create_rpmsg_vdev+0x50>
	rproc_virtio_wait_remote_ready(vdev);
1fff87ea:	f003 ff7e 	bl	1fffc6ea <rproc_virtio_wait_remote_ready>
	vring_rsc = rsc_table_get_vring0(rsc_table);
1fff87ee:	6839      	ldr	r1, [r7, #0]
	ret = rproc_virtio_init_vring(vdev, 0, vring_rsc->notifyid,
1fff87f0:	6b88      	ldr	r0, [r1, #56]	; 0x38
				      (void *)vring_rsc->da, rsc_io,
1fff87f2:	6b4b      	ldr	r3, [r1, #52]	; 0x34
	ret = rproc_virtio_init_vring(vdev, 0, vring_rsc->notifyid,
1fff87f4:	6c0a      	ldr	r2, [r1, #64]	; 0x40
1fff87f6:	9002      	str	r0, [sp, #8]
1fff87f8:	6bc9      	ldr	r1, [r1, #60]	; 0x3c
1fff87fa:	9101      	str	r1, [sp, #4]
1fff87fc:	6831      	ldr	r1, [r6, #0]
1fff87fe:	9100      	str	r1, [sp, #0]
1fff8800:	4620      	mov	r0, r4
1fff8802:	4641      	mov	r1, r8
1fff8804:	f003 ff37 	bl	1fffc676 <rproc_virtio_init_vring>
	if (ret) {
1fff8808:	b130      	cbz	r0, 1fff8818 <platform_create_rpmsg_vdev+0x58>
	rproc_virtio_remove_vdev(vdev);
1fff880a:	4620      	mov	r0, r4
1fff880c:	f003 ff17 	bl	1fffc63e <rproc_virtio_remove_vdev>
		return NULL;
1fff8810:	2000      	movs	r0, #0
}
1fff8812:	b004      	add	sp, #16
1fff8814:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	vring_rsc = rsc_table_get_vring1(rsc_table);
1fff8818:	6839      	ldr	r1, [r7, #0]
	ret = rproc_virtio_init_vring(vdev, 1, vring_rsc->notifyid,
1fff881a:	6cc8      	ldr	r0, [r1, #76]	; 0x4c
				      (void *)vring_rsc->da, rsc_io,
1fff881c:	6c8b      	ldr	r3, [r1, #72]	; 0x48
	ret = rproc_virtio_init_vring(vdev, 1, vring_rsc->notifyid,
1fff881e:	6d4a      	ldr	r2, [r1, #84]	; 0x54
1fff8820:	9002      	str	r0, [sp, #8]
1fff8822:	6d09      	ldr	r1, [r1, #80]	; 0x50
1fff8824:	9101      	str	r1, [sp, #4]
1fff8826:	6831      	ldr	r1, [r6, #0]
1fff8828:	9100      	str	r1, [sp, #0]
1fff882a:	4620      	mov	r0, r4
1fff882c:	2101      	movs	r1, #1
1fff882e:	f003 ff22 	bl	1fffc676 <rproc_virtio_init_vring>
	if (ret) {
1fff8832:	4601      	mov	r1, r0
1fff8834:	2800      	cmp	r0, #0
1fff8836:	d1e8      	bne.n	1fff880a <platform_create_rpmsg_vdev+0x4a>
	rpmsg_virtio_init_shm_pool(&shpool, NULL, SHM_SIZE);
1fff8838:	4e0b      	ldr	r6, [pc, #44]	; (1fff8868 <platform_create_rpmsg_vdev+0xa8>)
1fff883a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
1fff883e:	4630      	mov	r0, r6
1fff8840:	f003 fe58 	bl	1fffc4f4 <rpmsg_virtio_init_shm_pool>
	ret =  rpmsg_init_vdev(&rvdev, vdev, ns_cb, shm_io, &shpool);
1fff8844:	4b09      	ldr	r3, [pc, #36]	; (1fff886c <platform_create_rpmsg_vdev+0xac>)
1fff8846:	9600      	str	r6, [sp, #0]
1fff8848:	681b      	ldr	r3, [r3, #0]
1fff884a:	4809      	ldr	r0, [pc, #36]	; (1fff8870 <platform_create_rpmsg_vdev+0xb0>)
1fff884c:	462a      	mov	r2, r5
1fff884e:	4621      	mov	r1, r4
1fff8850:	f003 fe57 	bl	1fffc502 <rpmsg_init_vdev>
	if (ret) {
1fff8854:	2800      	cmp	r0, #0
1fff8856:	d1d8      	bne.n	1fff880a <platform_create_rpmsg_vdev+0x4a>
	return rpmsg_virtio_get_rpmsg_device(&rvdev);
1fff8858:	4805      	ldr	r0, [pc, #20]	; (1fff8870 <platform_create_rpmsg_vdev+0xb0>)
1fff885a:	e7da      	b.n	1fff8812 <platform_create_rpmsg_vdev+0x52>
1fff885c:	2000048c 	.word	0x2000048c
1fff8860:	20000544 	.word	0x20000544
1fff8864:	1fff851d 	.word	0x1fff851d
1fff8868:	20000548 	.word	0x20000548
1fff886c:	20000554 	.word	0x20000554
1fff8870:	20000490 	.word	0x20000490

1fff8874 <rpmsg_mng_task>:

void rpmsg_mng_task(void *arg1, void *arg2, void *arg3)
{
1fff8874:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(arg3);
	unsigned char *msg;
	unsigned int len;
	int ret = 0;

	printk("\r\nOpenAMP[remote]  linux responder demo started\r\n");
1fff8876:	481a      	ldr	r0, [pc, #104]	; (1fff88e0 <rpmsg_mng_task+0x6c>)
1fff8878:	f002 fbf2 	bl	1fffb060 <printk>

	/* Initialize platform */
	ret = platform_init();
1fff887c:	f7ff ff2c 	bl	1fff86d8 <platform_init>
1fff8880:	4602      	mov	r2, r0
	if (ret) {
1fff8882:	b9e8      	cbnz	r0, 1fff88c0 <rpmsg_mng_task+0x4c>
		LOG_ERR("Failed to initialize platform\n");
		ret = -1;
		goto task_end;
	}

	rpdev = platform_create_rpmsg_vdev(0, VIRTIO_DEV_DEVICE, NULL,
1fff8884:	4b17      	ldr	r3, [pc, #92]	; (1fff88e4 <rpmsg_mng_task+0x70>)
1fff8886:	2101      	movs	r1, #1
1fff8888:	f7ff ff9a 	bl	1fff87c0 <platform_create_rpmsg_vdev>
1fff888c:	4b16      	ldr	r3, [pc, #88]	; (1fff88e8 <rpmsg_mng_task+0x74>)
1fff888e:	6018      	str	r0, [r3, #0]
					   new_service_cb);
	if (!rpdev) {
1fff8890:	b1b0      	cbz	r0, 1fff88c0 <rpmsg_mng_task+0x4c>
1fff8892:	4816      	ldr	r0, [pc, #88]	; (1fff88ec <rpmsg_mng_task+0x78>)
1fff8894:	f001 fef6 	bl	1fffa684 <z_impl_k_sem_give>
1fff8898:	4815      	ldr	r0, [pc, #84]	; (1fff88f0 <rpmsg_mng_task+0x7c>)
	return z_impl_k_sem_take(sem, timeout);
1fff889a:	4d16      	ldr	r5, [pc, #88]	; (1fff88f4 <rpmsg_mng_task+0x80>)
		rproc_virtio_notified(rvdev.vdev, VRING1_ID);
1fff889c:	4c16      	ldr	r4, [pc, #88]	; (1fff88f8 <rpmsg_mng_task+0x84>)
	z_impl_k_sem_give(sem);
1fff889e:	f001 fef1 	bl	1fffa684 <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
1fff88a2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
1fff88a6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
1fff88aa:	4628      	mov	r0, r5
1fff88ac:	f001 ff0a 	bl	1fffa6c4 <z_impl_k_sem_take>
	if (status == 0) {
1fff88b0:	2800      	cmp	r0, #0
1fff88b2:	d1f6      	bne.n	1fff88a2 <rpmsg_mng_task+0x2e>
		rproc_virtio_notified(rvdev.vdev, VRING1_ID);
1fff88b4:	f8d4 0098 	ldr.w	r0, [r4, #152]	; 0x98
1fff88b8:	2101      	movs	r1, #1
1fff88ba:	f003 fef4 	bl	1fffc6a6 <rproc_virtio_notified>
}
1fff88be:	e7f0      	b.n	1fff88a2 <rpmsg_mng_task+0x2e>
1fff88c0:	480e      	ldr	r0, [pc, #56]	; (1fff88fc <rpmsg_mng_task+0x88>)
1fff88c2:	6883      	ldr	r3, [r0, #8]
1fff88c4:	2100      	movs	r1, #0
1fff88c6:	691b      	ldr	r3, [r3, #16]
1fff88c8:	4798      	blx	r3
	rpmsg_deinit_vdev(&rvdev);
1fff88ca:	480b      	ldr	r0, [pc, #44]	; (1fff88f8 <rpmsg_mng_task+0x84>)
1fff88cc:	f003 fe22 	bl	1fffc514 <rpmsg_deinit_vdev>
	metal_finish();
1fff88d0:	f001 fae6 	bl	1fff9ea0 <metal_finish>

task_end:
	cleanup_system();

	printk("OpenAMP demo ended\n");
}
1fff88d4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	printk("OpenAMP demo ended\n");
1fff88d8:	4809      	ldr	r0, [pc, #36]	; (1fff8900 <rpmsg_mng_task+0x8c>)
1fff88da:	f002 bbc1 	b.w	1fffb060 <printk>
1fff88de:	bf00      	nop
1fff88e0:	1fffd419 	.word	0x1fffd419
1fff88e4:	1fffb05b 	.word	0x1fffb05b
1fff88e8:	20000488 	.word	0x20000488
1fff88ec:	200000f0 	.word	0x200000f0
1fff88f0:	20000110 	.word	0x20000110
1fff88f4:	20000100 	.word	0x20000100
1fff88f8:	20000490 	.word	0x20000490
1fff88fc:	1fffcb34 	.word	0x1fffcb34
1fff8900:	1fffd44b 	.word	0x1fffd44b

1fff8904 <main>:

void main(void)
{
1fff8904:	b5f0      	push	{r4, r5, r6, r7, lr}
	printk("Starting application threads!\n");
1fff8906:	481b      	ldr	r0, [pc, #108]	; (1fff8974 <main+0x70>)
{
1fff8908:	b089      	sub	sp, #36	; 0x24
	printk("Starting application threads!\n");
1fff890a:	f002 fba9 	bl	1fffb060 <printk>
	k_thread_create(&thread_mng_data, thread_mng_stack, APP_TASK_STACK_SIZE,
1fff890e:	2600      	movs	r6, #0
1fff8910:	2700      	movs	r7, #0
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
1fff8912:	2400      	movs	r4, #0
1fff8914:	f06f 0307 	mvn.w	r3, #7
1fff8918:	e9cd 3403 	strd	r3, r4, [sp, #12]
1fff891c:	e9cd 6706 	strd	r6, r7, [sp, #24]
1fff8920:	e9cd 4401 	strd	r4, r4, [sp, #4]
1fff8924:	4b14      	ldr	r3, [pc, #80]	; (1fff8978 <main+0x74>)
1fff8926:	4915      	ldr	r1, [pc, #84]	; (1fff897c <main+0x78>)
1fff8928:	9400      	str	r4, [sp, #0]
1fff892a:	f44f 7200 	mov.w	r2, #512	; 0x200
1fff892e:	4814      	ldr	r0, [pc, #80]	; (1fff8980 <main+0x7c>)
1fff8930:	f001 fe30 	bl	1fffa594 <z_impl_k_thread_create>
1fff8934:	f06f 0508 	mvn.w	r5, #8
1fff8938:	e9cd 6706 	strd	r6, r7, [sp, #24]
1fff893c:	e9cd 4502 	strd	r4, r5, [sp, #8]
1fff8940:	e9cd 4400 	strd	r4, r4, [sp]
1fff8944:	4b0f      	ldr	r3, [pc, #60]	; (1fff8984 <main+0x80>)
1fff8946:	4910      	ldr	r1, [pc, #64]	; (1fff8988 <main+0x84>)
1fff8948:	9404      	str	r4, [sp, #16]
1fff894a:	f44f 7200 	mov.w	r2, #512	; 0x200
1fff894e:	480f      	ldr	r0, [pc, #60]	; (1fff898c <main+0x88>)
1fff8950:	f001 fe20 	bl	1fffa594 <z_impl_k_thread_create>
1fff8954:	4b0e      	ldr	r3, [pc, #56]	; (1fff8990 <main+0x8c>)
1fff8956:	490f      	ldr	r1, [pc, #60]	; (1fff8994 <main+0x90>)
1fff8958:	9400      	str	r4, [sp, #0]
1fff895a:	e9cd 6706 	strd	r6, r7, [sp, #24]
1fff895e:	e9cd 5403 	strd	r5, r4, [sp, #12]
1fff8962:	e9cd 4401 	strd	r4, r4, [sp, #4]
1fff8966:	f44f 6280 	mov.w	r2, #1024	; 0x400
1fff896a:	480b      	ldr	r0, [pc, #44]	; (1fff8998 <main+0x94>)
1fff896c:	f001 fe12 	bl	1fffa594 <z_impl_k_thread_create>
			(k_thread_entry_t)app_rpmsg_client_sample,
			NULL, NULL, NULL, K_PRIO_COOP(7), 0, K_NO_WAIT);
	k_thread_create(&thread_tty_data, thread_tty_stack, APP_TTY_TASK_STACK_SIZE,
			(k_thread_entry_t)app_rpmsg_tty,
			NULL, NULL, NULL, K_PRIO_COOP(7), 0, K_NO_WAIT);
}
1fff8970:	b009      	add	sp, #36	; 0x24
1fff8972:	bdf0      	pop	{r4, r5, r6, r7, pc}
1fff8974:	1fffd45f 	.word	0x1fffd45f
1fff8978:	1fff8875 	.word	0x1fff8875
1fff897c:	20000ff0 	.word	0x20000ff0
1fff8980:	20000290 	.word	0x20000290
1fff8984:	1fff8605 	.word	0x1fff8605
1fff8988:	20000df0 	.word	0x20000df0
1fff898c:	20000220 	.word	0x20000220
1fff8990:	1fff853d 	.word	0x1fff853d
1fff8994:	200009f0 	.word	0x200009f0
1fff8998:	200001b0 	.word	0x200001b0

1fff899c <char_out>:
}

static int char_out(int c, void *ctx_p)
{
	(void) ctx_p;
	return _char_out(c);
1fff899c:	4b01      	ldr	r3, [pc, #4]	; (1fff89a4 <char_out+0x8>)
1fff899e:	681b      	ldr	r3, [r3, #0]
1fff89a0:	4718      	bx	r3
1fff89a2:	bf00      	nop
1fff89a4:	20000098 	.word	0x20000098

1fff89a8 <__printk_hook_install>:
	_char_out = fn;
1fff89a8:	4b01      	ldr	r3, [pc, #4]	; (1fff89b0 <__printk_hook_install+0x8>)
1fff89aa:	6018      	str	r0, [r3, #0]
}
1fff89ac:	4770      	bx	lr
1fff89ae:	bf00      	nop
1fff89b0:	20000098 	.word	0x20000098

1fff89b4 <vprintk>:
}

void vprintk(const char *fmt, va_list ap)
{
1fff89b4:	b507      	push	{r0, r1, r2, lr}
1fff89b6:	460b      	mov	r3, r1
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
1fff89b8:	2100      	movs	r1, #0
1fff89ba:	4602      	mov	r2, r0
1fff89bc:	9100      	str	r1, [sp, #0]
1fff89be:	4803      	ldr	r0, [pc, #12]	; (1fff89cc <vprintk+0x18>)
1fff89c0:	f000 f806 	bl	1fff89d0 <z_cbvprintf_impl>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
1fff89c4:	b003      	add	sp, #12
1fff89c6:	f85d fb04 	ldr.w	pc, [sp], #4
1fff89ca:	bf00      	nop
1fff89cc:	1fff899d 	.word	0x1fff899d

1fff89d0 <z_cbvprintf_impl>:
	return (int)count;
}

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
1fff89d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1fff89d4:	4681      	mov	r9, r0
1fff89d6:	b095      	sub	sp, #84	; 0x54
1fff89d8:	468b      	mov	fp, r1
1fff89da:	4617      	mov	r7, r2
1fff89dc:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
1fff89de:	2500      	movs	r5, #0
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
1fff89e0:	7838      	ldrb	r0, [r7, #0]
1fff89e2:	b908      	cbnz	r0, 1fff89e8 <z_cbvprintf_impl+0x18>
			OUTC(' ');
			--width;
		}
	}

	return count;
1fff89e4:	4628      	mov	r0, r5
1fff89e6:	e358      	b.n	1fff909a <z_cbvprintf_impl+0x6ca>
			OUTC(*fp++);
1fff89e8:	1c7b      	adds	r3, r7, #1
		if (*fp != '%') {
1fff89ea:	2825      	cmp	r0, #37	; 0x25
			OUTC(*fp++);
1fff89ec:	9303      	str	r3, [sp, #12]
		if (*fp != '%') {
1fff89ee:	d006      	beq.n	1fff89fe <z_cbvprintf_impl+0x2e>
			OUTC('%');
1fff89f0:	4659      	mov	r1, fp
1fff89f2:	47c8      	blx	r9
1fff89f4:	2800      	cmp	r0, #0
1fff89f6:	f2c0 8350 	blt.w	1fff909a <z_cbvprintf_impl+0x6ca>
1fff89fa:	3501      	adds	r5, #1
		if (bps == NULL) {
1fff89fc:	e1fb      	b.n	1fff8df6 <z_cbvprintf_impl+0x426>
		} state = {
1fff89fe:	2218      	movs	r2, #24
1fff8a00:	2100      	movs	r1, #0
1fff8a02:	a80e      	add	r0, sp, #56	; 0x38
1fff8a04:	f002 fdc6 	bl	1fffb594 <memset>
	if (*sp == '%') {
1fff8a08:	787b      	ldrb	r3, [r7, #1]
1fff8a0a:	2b25      	cmp	r3, #37	; 0x25
1fff8a0c:	d07d      	beq.n	1fff8b0a <z_cbvprintf_impl+0x13a>
1fff8a0e:	2300      	movs	r3, #0
1fff8a10:	1c78      	adds	r0, r7, #1
1fff8a12:	4698      	mov	r8, r3
1fff8a14:	469e      	mov	lr, r3
1fff8a16:	469c      	mov	ip, r3
1fff8a18:	461e      	mov	r6, r3
1fff8a1a:	4601      	mov	r1, r0
		switch (*sp) {
1fff8a1c:	f810 2b01 	ldrb.w	r2, [r0], #1
1fff8a20:	2a2b      	cmp	r2, #43	; 0x2b
1fff8a22:	f000 80a1 	beq.w	1fff8b68 <z_cbvprintf_impl+0x198>
1fff8a26:	f200 8098 	bhi.w	1fff8b5a <z_cbvprintf_impl+0x18a>
1fff8a2a:	2a20      	cmp	r2, #32
1fff8a2c:	f000 809f 	beq.w	1fff8b6e <z_cbvprintf_impl+0x19e>
1fff8a30:	2a23      	cmp	r2, #35	; 0x23
1fff8a32:	f000 809f 	beq.w	1fff8b74 <z_cbvprintf_impl+0x1a4>
1fff8a36:	b12b      	cbz	r3, 1fff8a44 <z_cbvprintf_impl+0x74>
1fff8a38:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
1fff8a3c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
1fff8a40:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
1fff8a44:	f1b8 0f00 	cmp.w	r8, #0
1fff8a48:	d005      	beq.n	1fff8a56 <z_cbvprintf_impl+0x86>
1fff8a4a:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
1fff8a4e:	f043 0320 	orr.w	r3, r3, #32
1fff8a52:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
1fff8a56:	f1be 0f00 	cmp.w	lr, #0
1fff8a5a:	d005      	beq.n	1fff8a68 <z_cbvprintf_impl+0x98>
1fff8a5c:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
1fff8a60:	f043 0310 	orr.w	r3, r3, #16
1fff8a64:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
1fff8a68:	f1bc 0f00 	cmp.w	ip, #0
1fff8a6c:	d005      	beq.n	1fff8a7a <z_cbvprintf_impl+0xaa>
1fff8a6e:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
1fff8a72:	f043 0308 	orr.w	r3, r3, #8
1fff8a76:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
1fff8a7a:	b12e      	cbz	r6, 1fff8a88 <z_cbvprintf_impl+0xb8>
1fff8a7c:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
1fff8a80:	f043 0304 	orr.w	r3, r3, #4
1fff8a84:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	if (conv->flag_zero && conv->flag_dash) {
1fff8a88:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
1fff8a8c:	f003 0044 	and.w	r0, r3, #68	; 0x44
1fff8a90:	2844      	cmp	r0, #68	; 0x44
1fff8a92:	d103      	bne.n	1fff8a9c <z_cbvprintf_impl+0xcc>
		conv->flag_zero = false;
1fff8a94:	f36f 1386 	bfc	r3, #6, #1
1fff8a98:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	conv->width_present = true;
1fff8a9c:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
	if (*sp == '*') {
1fff8aa0:	2a2a      	cmp	r2, #42	; 0x2a
	conv->width_present = true;
1fff8aa2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
1fff8aa6:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	if (*sp == '*') {
1fff8aaa:	d17f      	bne.n	1fff8bac <z_cbvprintf_impl+0x1dc>
		conv->width_star = true;
1fff8aac:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
1fff8ab0:	f042 0201 	orr.w	r2, r2, #1
		return ++sp;
1fff8ab4:	1c4b      	adds	r3, r1, #1
		conv->width_star = true;
1fff8ab6:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	conv->prec_present = (*sp == '.');
1fff8aba:	781a      	ldrb	r2, [r3, #0]
1fff8abc:	2a2e      	cmp	r2, #46	; 0x2e
1fff8abe:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
1fff8ac2:	bf0c      	ite	eq
1fff8ac4:	2101      	moveq	r1, #1
1fff8ac6:	2100      	movne	r1, #0
1fff8ac8:	f361 0241 	bfi	r2, r1, #1, #1
1fff8acc:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	if (!conv->prec_present) {
1fff8ad0:	d178      	bne.n	1fff8bc4 <z_cbvprintf_impl+0x1f4>
	if (*sp == '*') {
1fff8ad2:	785a      	ldrb	r2, [r3, #1]
1fff8ad4:	2a2a      	cmp	r2, #42	; 0x2a
1fff8ad6:	d06e      	beq.n	1fff8bb6 <z_cbvprintf_impl+0x1e6>
	++sp;
1fff8ad8:	3301      	adds	r3, #1
	size_t val = 0;
1fff8ada:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
1fff8adc:	f04f 0c0a 	mov.w	ip, #10
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
1fff8ae0:	4619      	mov	r1, r3
1fff8ae2:	f811 0b01 	ldrb.w	r0, [r1], #1
1fff8ae6:	f1a0 0630 	sub.w	r6, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
1fff8aea:	2e09      	cmp	r6, #9
1fff8aec:	f240 8095 	bls.w	1fff8c1a <z_cbvprintf_impl+0x24a>
	conv->unsupported |= ((conv->prec_value < 0)
1fff8af0:	f89d 1040 	ldrb.w	r1, [sp, #64]	; 0x40
	conv->prec_value = prec;
1fff8af4:	9212      	str	r2, [sp, #72]	; 0x48
	conv->unsupported |= ((conv->prec_value < 0)
1fff8af6:	f3c1 0040 	ubfx	r0, r1, #1, #1
1fff8afa:	ea40 70d2 	orr.w	r0, r0, r2, lsr #31
1fff8afe:	460a      	mov	r2, r1
1fff8b00:	f360 0241 	bfi	r2, r0, #1, #1
1fff8b04:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
	return sp;
1fff8b08:	e05c      	b.n	1fff8bc4 <z_cbvprintf_impl+0x1f4>
		conv->specifier = *sp++;
1fff8b0a:	1cba      	adds	r2, r7, #2
1fff8b0c:	9203      	str	r2, [sp, #12]
1fff8b0e:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
		if (conv->width_star) {
1fff8b12:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
1fff8b16:	07da      	lsls	r2, r3, #31
1fff8b18:	f140 812e 	bpl.w	1fff8d78 <z_cbvprintf_impl+0x3a8>
			width = va_arg(ap, int);
1fff8b1c:	f854 8b04 	ldr.w	r8, [r4], #4
			if (width < 0) {
1fff8b20:	f1b8 0f00 	cmp.w	r8, #0
1fff8b24:	da07      	bge.n	1fff8b36 <z_cbvprintf_impl+0x166>
				conv->flag_dash = true;
1fff8b26:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
1fff8b2a:	f042 0204 	orr.w	r2, r2, #4
1fff8b2e:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
				width = -width;
1fff8b32:	f1c8 0800 	rsb	r8, r8, #0
		if (conv->prec_star) {
1fff8b36:	075e      	lsls	r6, r3, #29
1fff8b38:	f140 8127 	bpl.w	1fff8d8a <z_cbvprintf_impl+0x3ba>
			int arg = va_arg(ap, int);
1fff8b3c:	f854 ab04 	ldr.w	sl, [r4], #4
			if (arg < 0) {
1fff8b40:	f1ba 0f00 	cmp.w	sl, #0
1fff8b44:	f280 8126 	bge.w	1fff8d94 <z_cbvprintf_impl+0x3c4>
				conv->prec_present = false;
1fff8b48:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
1fff8b4c:	f36f 0341 	bfc	r3, #1, #1
1fff8b50:	f88d 3041 	strb.w	r3, [sp, #65]	; 0x41
		int precision = -1;
1fff8b54:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
1fff8b58:	e11c      	b.n	1fff8d94 <z_cbvprintf_impl+0x3c4>
		switch (*sp) {
1fff8b5a:	2a2d      	cmp	r2, #45	; 0x2d
1fff8b5c:	d00d      	beq.n	1fff8b7a <z_cbvprintf_impl+0x1aa>
1fff8b5e:	2a30      	cmp	r2, #48	; 0x30
1fff8b60:	f47f af69 	bne.w	1fff8a36 <z_cbvprintf_impl+0x66>
1fff8b64:	2301      	movs	r3, #1
	} while (loop);
1fff8b66:	e758      	b.n	1fff8a1a <z_cbvprintf_impl+0x4a>
		switch (*sp) {
1fff8b68:	f04f 0c01 	mov.w	ip, #1
1fff8b6c:	e755      	b.n	1fff8a1a <z_cbvprintf_impl+0x4a>
1fff8b6e:	f04f 0e01 	mov.w	lr, #1
1fff8b72:	e752      	b.n	1fff8a1a <z_cbvprintf_impl+0x4a>
1fff8b74:	f04f 0801 	mov.w	r8, #1
1fff8b78:	e74f      	b.n	1fff8a1a <z_cbvprintf_impl+0x4a>
1fff8b7a:	2601      	movs	r6, #1
1fff8b7c:	e74d      	b.n	1fff8a1a <z_cbvprintf_impl+0x4a>
		val = 10U * val + *sp++ - '0';
1fff8b7e:	fb0e 6202 	mla	r2, lr, r2, r6
1fff8b82:	3a30      	subs	r2, #48	; 0x30
1fff8b84:	4603      	mov	r3, r0
1fff8b86:	4618      	mov	r0, r3
1fff8b88:	f810 6b01 	ldrb.w	r6, [r0], #1
1fff8b8c:	f1a6 0c30 	sub.w	ip, r6, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
1fff8b90:	f1bc 0f09 	cmp.w	ip, #9
1fff8b94:	d9f3      	bls.n	1fff8b7e <z_cbvprintf_impl+0x1ae>
	if (sp != wp) {
1fff8b96:	4299      	cmp	r1, r3
1fff8b98:	d08f      	beq.n	1fff8aba <z_cbvprintf_impl+0xea>
		conv->unsupported |= ((conv->width_value < 0)
1fff8b9a:	f89d 1040 	ldrb.w	r1, [sp, #64]	; 0x40
		conv->width_value = width;
1fff8b9e:	9211      	str	r2, [sp, #68]	; 0x44
				      || (width != (size_t)conv->width_value));
1fff8ba0:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
1fff8ba2:	f362 0141 	bfi	r1, r2, #1, #1
1fff8ba6:	f88d 1040 	strb.w	r1, [sp, #64]	; 0x40
1fff8baa:	e786      	b.n	1fff8aba <z_cbvprintf_impl+0xea>
1fff8bac:	460b      	mov	r3, r1
	size_t val = 0;
1fff8bae:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
1fff8bb0:	f04f 0e0a 	mov.w	lr, #10
1fff8bb4:	e7e7      	b.n	1fff8b86 <z_cbvprintf_impl+0x1b6>
		conv->prec_star = true;
1fff8bb6:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
1fff8bba:	f042 0204 	orr.w	r2, r2, #4
1fff8bbe:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
		return ++sp;
1fff8bc2:	3302      	adds	r3, #2
	switch (*sp) {
1fff8bc4:	781a      	ldrb	r2, [r3, #0]
1fff8bc6:	2a6c      	cmp	r2, #108	; 0x6c
1fff8bc8:	d047      	beq.n	1fff8c5a <z_cbvprintf_impl+0x28a>
1fff8bca:	d82b      	bhi.n	1fff8c24 <z_cbvprintf_impl+0x254>
1fff8bcc:	2a68      	cmp	r2, #104	; 0x68
1fff8bce:	d031      	beq.n	1fff8c34 <z_cbvprintf_impl+0x264>
1fff8bd0:	2a6a      	cmp	r2, #106	; 0x6a
1fff8bd2:	d04b      	beq.n	1fff8c6c <z_cbvprintf_impl+0x29c>
1fff8bd4:	2a4c      	cmp	r2, #76	; 0x4c
1fff8bd6:	d051      	beq.n	1fff8c7c <z_cbvprintf_impl+0x2ac>
	conv->specifier = *sp++;
1fff8bd8:	461a      	mov	r2, r3
1fff8bda:	f812 3b01 	ldrb.w	r3, [r2], #1
1fff8bde:	9203      	str	r2, [sp, #12]
	switch (conv->specifier) {
1fff8be0:	2b78      	cmp	r3, #120	; 0x78
		if (conv->length_mod == LENGTH_UPPER_L) {
1fff8be2:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
	conv->specifier = *sp++;
1fff8be6:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
	switch (conv->specifier) {
1fff8bea:	f200 80be 	bhi.w	1fff8d6a <z_cbvprintf_impl+0x39a>
1fff8bee:	2b6d      	cmp	r3, #109	; 0x6d
1fff8bf0:	d851      	bhi.n	1fff8c96 <z_cbvprintf_impl+0x2c6>
1fff8bf2:	2b69      	cmp	r3, #105	; 0x69
1fff8bf4:	f200 80b9 	bhi.w	1fff8d6a <z_cbvprintf_impl+0x39a>
1fff8bf8:	2b57      	cmp	r3, #87	; 0x57
1fff8bfa:	d867      	bhi.n	1fff8ccc <z_cbvprintf_impl+0x2fc>
1fff8bfc:	2b41      	cmp	r3, #65	; 0x41
1fff8bfe:	d003      	beq.n	1fff8c08 <z_cbvprintf_impl+0x238>
1fff8c00:	3b45      	subs	r3, #69	; 0x45
1fff8c02:	2b02      	cmp	r3, #2
1fff8c04:	f200 80b1 	bhi.w	1fff8d6a <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_FP;
1fff8c08:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
1fff8c0c:	2204      	movs	r2, #4
1fff8c0e:	f362 0302 	bfi	r3, r2, #0, #3
1fff8c12:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
			unsupported = true;
1fff8c16:	2301      	movs	r3, #1
			break;
1fff8c18:	e073      	b.n	1fff8d02 <z_cbvprintf_impl+0x332>
		val = 10U * val + *sp++ - '0';
1fff8c1a:	fb0c 0202 	mla	r2, ip, r2, r0
1fff8c1e:	3a30      	subs	r2, #48	; 0x30
1fff8c20:	460b      	mov	r3, r1
1fff8c22:	e75d      	b.n	1fff8ae0 <z_cbvprintf_impl+0x110>
	switch (*sp) {
1fff8c24:	2a74      	cmp	r2, #116	; 0x74
1fff8c26:	d025      	beq.n	1fff8c74 <z_cbvprintf_impl+0x2a4>
1fff8c28:	2a7a      	cmp	r2, #122	; 0x7a
1fff8c2a:	d1d5      	bne.n	1fff8bd8 <z_cbvprintf_impl+0x208>
		conv->length_mod = LENGTH_Z;
1fff8c2c:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
1fff8c30:	2106      	movs	r1, #6
1fff8c32:	e00c      	b.n	1fff8c4e <z_cbvprintf_impl+0x27e>
		if (*++sp == 'h') {
1fff8c34:	785a      	ldrb	r2, [r3, #1]
1fff8c36:	2a68      	cmp	r2, #104	; 0x68
1fff8c38:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
1fff8c3c:	d106      	bne.n	1fff8c4c <z_cbvprintf_impl+0x27c>
			conv->length_mod = LENGTH_HH;
1fff8c3e:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
1fff8c40:	f361 02c6 	bfi	r2, r1, #3, #4
1fff8c44:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
			++sp;
1fff8c48:	3302      	adds	r3, #2
1fff8c4a:	e7c5      	b.n	1fff8bd8 <z_cbvprintf_impl+0x208>
			conv->length_mod = LENGTH_H;
1fff8c4c:	2102      	movs	r1, #2
1fff8c4e:	f361 02c6 	bfi	r2, r1, #3, #4
1fff8c52:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
		if (*++sp == 'h') {
1fff8c56:	3301      	adds	r3, #1
1fff8c58:	e7be      	b.n	1fff8bd8 <z_cbvprintf_impl+0x208>
		if (*++sp == 'l') {
1fff8c5a:	785a      	ldrb	r2, [r3, #1]
1fff8c5c:	2a6c      	cmp	r2, #108	; 0x6c
1fff8c5e:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
1fff8c62:	d101      	bne.n	1fff8c68 <z_cbvprintf_impl+0x298>
			conv->length_mod = LENGTH_LL;
1fff8c64:	2104      	movs	r1, #4
1fff8c66:	e7eb      	b.n	1fff8c40 <z_cbvprintf_impl+0x270>
			conv->length_mod = LENGTH_L;
1fff8c68:	2103      	movs	r1, #3
1fff8c6a:	e7f0      	b.n	1fff8c4e <z_cbvprintf_impl+0x27e>
		conv->length_mod = LENGTH_J;
1fff8c6c:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
1fff8c70:	2105      	movs	r1, #5
1fff8c72:	e7ec      	b.n	1fff8c4e <z_cbvprintf_impl+0x27e>
		conv->length_mod = LENGTH_T;
1fff8c74:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
1fff8c78:	2107      	movs	r1, #7
1fff8c7a:	e7e8      	b.n	1fff8c4e <z_cbvprintf_impl+0x27e>
		conv->unsupported = true;
1fff8c7c:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
1fff8c80:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
1fff8c84:	f022 0202 	bic.w	r2, r2, #2
1fff8c88:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
1fff8c8c:	f042 0202 	orr.w	r2, r2, #2
1fff8c90:	f8ad 2040 	strh.w	r2, [sp, #64]	; 0x40
		break;
1fff8c94:	e7df      	b.n	1fff8c56 <z_cbvprintf_impl+0x286>
	switch (conv->specifier) {
1fff8c96:	3b6e      	subs	r3, #110	; 0x6e
1fff8c98:	b2d9      	uxtb	r1, r3
1fff8c9a:	2301      	movs	r3, #1
1fff8c9c:	408b      	lsls	r3, r1
1fff8c9e:	f240 4182 	movw	r1, #1154	; 0x482
1fff8ca2:	420b      	tst	r3, r1
1fff8ca4:	d137      	bne.n	1fff8d16 <z_cbvprintf_impl+0x346>
1fff8ca6:	f013 0f24 	tst.w	r3, #36	; 0x24
1fff8caa:	d151      	bne.n	1fff8d50 <z_cbvprintf_impl+0x380>
1fff8cac:	07d8      	lsls	r0, r3, #31
1fff8cae:	d55c      	bpl.n	1fff8d6a <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_PTR;
1fff8cb0:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
1fff8cb4:	2103      	movs	r1, #3
1fff8cb6:	f361 0302 	bfi	r3, r1, #0, #3
1fff8cba:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
1fff8cbe:	f002 0378 	and.w	r3, r2, #120	; 0x78
1fff8cc2:	f1a3 0140 	sub.w	r1, r3, #64	; 0x40
1fff8cc6:	424b      	negs	r3, r1
1fff8cc8:	414b      	adcs	r3, r1
1fff8cca:	e01a      	b.n	1fff8d02 <z_cbvprintf_impl+0x332>
	switch (conv->specifier) {
1fff8ccc:	f1a3 0158 	sub.w	r1, r3, #88	; 0x58
1fff8cd0:	b2c9      	uxtb	r1, r1
1fff8cd2:	2001      	movs	r0, #1
1fff8cd4:	fa00 f101 	lsl.w	r1, r0, r1
1fff8cd8:	f411 4f62 	tst.w	r1, #57856	; 0xe200
1fff8cdc:	d194      	bne.n	1fff8c08 <z_cbvprintf_impl+0x238>
1fff8cde:	f640 0601 	movw	r6, #2049	; 0x801
1fff8ce2:	4231      	tst	r1, r6
1fff8ce4:	d11d      	bne.n	1fff8d22 <z_cbvprintf_impl+0x352>
1fff8ce6:	f411 3f04 	tst.w	r1, #135168	; 0x21000
1fff8cea:	d03e      	beq.n	1fff8d6a <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_SINT;
1fff8cec:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
1fff8cf0:	f360 0302 	bfi	r3, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
1fff8cf4:	f002 0278 	and.w	r2, r2, #120	; 0x78
1fff8cf8:	2a40      	cmp	r2, #64	; 0x40
		conv->specifier_cat = SPECIFIER_SINT;
1fff8cfa:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
1fff8cfe:	d034      	beq.n	1fff8d6a <z_cbvprintf_impl+0x39a>
	bool unsupported = false;
1fff8d00:	2300      	movs	r3, #0
	conv->unsupported |= unsupported;
1fff8d02:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
1fff8d06:	f3c2 0140 	ubfx	r1, r2, #1, #1
1fff8d0a:	430b      	orrs	r3, r1
1fff8d0c:	f363 0241 	bfi	r2, r3, #1, #1
1fff8d10:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
	return sp;
1fff8d14:	e6fd      	b.n	1fff8b12 <z_cbvprintf_impl+0x142>
		conv->specifier_cat = SPECIFIER_UINT;
1fff8d16:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
1fff8d1a:	2102      	movs	r1, #2
1fff8d1c:	f361 0302 	bfi	r3, r1, #0, #3
1fff8d20:	e7e8      	b.n	1fff8cf4 <z_cbvprintf_impl+0x324>
1fff8d22:	f89d 1042 	ldrb.w	r1, [sp, #66]	; 0x42
1fff8d26:	2002      	movs	r0, #2
		if (conv->length_mod == LENGTH_UPPER_L) {
1fff8d28:	f002 0278 	and.w	r2, r2, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
1fff8d2c:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
1fff8d30:	2a40      	cmp	r2, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
1fff8d32:	f88d 1042 	strb.w	r1, [sp, #66]	; 0x42
			conv->invalid = true;
1fff8d36:	bf02      	ittt	eq
1fff8d38:	f89d 1040 	ldrbeq.w	r1, [sp, #64]	; 0x40
1fff8d3c:	f041 0101 	orreq.w	r1, r1, #1
1fff8d40:	f88d 1040 	strbeq.w	r1, [sp, #64]	; 0x40
		if (conv->specifier == 'c') {
1fff8d44:	2b63      	cmp	r3, #99	; 0x63
1fff8d46:	d1db      	bne.n	1fff8d00 <z_cbvprintf_impl+0x330>
			unsupported = (conv->length_mod != LENGTH_NONE);
1fff8d48:	1e13      	subs	r3, r2, #0
1fff8d4a:	bf18      	it	ne
1fff8d4c:	2301      	movne	r3, #1
1fff8d4e:	e7d8      	b.n	1fff8d02 <z_cbvprintf_impl+0x332>
		conv->specifier_cat = SPECIFIER_PTR;
1fff8d50:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
1fff8d54:	2103      	movs	r1, #3
1fff8d56:	f361 0302 	bfi	r3, r1, #0, #3
		if (conv->length_mod != LENGTH_NONE) {
1fff8d5a:	f012 0f78 	tst.w	r2, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
1fff8d5e:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod != LENGTH_NONE) {
1fff8d62:	bf14      	ite	ne
1fff8d64:	2301      	movne	r3, #1
1fff8d66:	2300      	moveq	r3, #0
1fff8d68:	e7cb      	b.n	1fff8d02 <z_cbvprintf_impl+0x332>
		conv->invalid = true;
1fff8d6a:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
1fff8d6e:	f043 0301 	orr.w	r3, r3, #1
1fff8d72:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
		break;
1fff8d76:	e7c3      	b.n	1fff8d00 <z_cbvprintf_impl+0x330>
		} else if (conv->width_present) {
1fff8d78:	f99d 2040 	ldrsb.w	r2, [sp, #64]	; 0x40
1fff8d7c:	2a00      	cmp	r2, #0
			width = conv->width_value;
1fff8d7e:	bfb4      	ite	lt
1fff8d80:	f8dd 8044 	ldrlt.w	r8, [sp, #68]	; 0x44
		int width = -1;
1fff8d84:	f04f 38ff 	movge.w	r8, #4294967295	; 0xffffffff
1fff8d88:	e6d5      	b.n	1fff8b36 <z_cbvprintf_impl+0x166>
		} else if (conv->prec_present) {
1fff8d8a:	0798      	lsls	r0, r3, #30
1fff8d8c:	f57f aee2 	bpl.w	1fff8b54 <z_cbvprintf_impl+0x184>
			precision = conv->prec_value;
1fff8d90:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
			= (enum length_mod_enum)conv->length_mod;
1fff8d94:	f89d 1041 	ldrb.w	r1, [sp, #65]	; 0x41
		conv->pad0_value = 0;
1fff8d98:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
1fff8d9a:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
			= (enum specifier_cat_enum)conv->specifier_cat;
1fff8d9e:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
		enum specifier_cat_enum specifier_cat
1fff8da2:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
1fff8da6:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
1fff8da8:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
1fff8dac:	d133      	bne.n	1fff8e16 <z_cbvprintf_impl+0x446>
			switch (length_mod) {
1fff8dae:	1ecb      	subs	r3, r1, #3
1fff8db0:	2b04      	cmp	r3, #4
1fff8db2:	d804      	bhi.n	1fff8dbe <z_cbvprintf_impl+0x3ee>
1fff8db4:	e8df f003 	tbb	[pc, r3]
1fff8db8:	21464621 	.word	0x21464621
1fff8dbc:	21          	.byte	0x21
1fff8dbd:	00          	.byte	0x00
				value->sint = va_arg(ap, int);
1fff8dbe:	6823      	ldr	r3, [r4, #0]
			if (length_mod == LENGTH_HH) {
1fff8dc0:	2901      	cmp	r1, #1
				value->sint = va_arg(ap, int);
1fff8dc2:	ea4f 72e3 	mov.w	r2, r3, asr #31
1fff8dc6:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
			if (length_mod == LENGTH_HH) {
1fff8dca:	d11c      	bne.n	1fff8e06 <z_cbvprintf_impl+0x436>
				value->sint = (signed char)value->sint;
1fff8dcc:	f99d 3038 	ldrsb.w	r3, [sp, #56]	; 0x38
1fff8dd0:	17da      	asrs	r2, r3, #31
1fff8dd2:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
				value->sint = va_arg(ap, int);
1fff8dd6:	3404      	adds	r4, #4
		if (conv->invalid || conv->unsupported) {
1fff8dd8:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
1fff8ddc:	f013 0603 	ands.w	r6, r3, #3
1fff8de0:	d050      	beq.n	1fff8e84 <z_cbvprintf_impl+0x4b4>
			OUTS(sp, fp);
1fff8de2:	9b03      	ldr	r3, [sp, #12]
1fff8de4:	463a      	mov	r2, r7
1fff8de6:	4659      	mov	r1, fp
1fff8de8:	4648      	mov	r0, r9
1fff8dea:	f002 fb5b 	bl	1fffb4a4 <outs>
1fff8dee:	2800      	cmp	r0, #0
1fff8df0:	f2c0 8153 	blt.w	1fff909a <z_cbvprintf_impl+0x6ca>
1fff8df4:	4405      	add	r5, r0
			continue;
1fff8df6:	9f03      	ldr	r7, [sp, #12]
1fff8df8:	e5f2      	b.n	1fff89e0 <z_cbvprintf_impl+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
1fff8dfa:	f854 3b04 	ldr.w	r3, [r4], #4
1fff8dfe:	17da      	asrs	r2, r3, #31
				value->uint = (unsigned char)value->uint;
1fff8e00:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
1fff8e04:	e7e8      	b.n	1fff8dd8 <z_cbvprintf_impl+0x408>
			} else if (length_mod == LENGTH_H) {
1fff8e06:	2902      	cmp	r1, #2
1fff8e08:	d1e5      	bne.n	1fff8dd6 <z_cbvprintf_impl+0x406>
				value->sint = (short)value->sint;
1fff8e0a:	b21a      	sxth	r2, r3
1fff8e0c:	f343 33c0 	sbfx	r3, r3, #15, #1
1fff8e10:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
1fff8e14:	e7df      	b.n	1fff8dd6 <z_cbvprintf_impl+0x406>
		} else if (specifier_cat == SPECIFIER_UINT) {
1fff8e16:	2b02      	cmp	r3, #2
1fff8e18:	d124      	bne.n	1fff8e64 <z_cbvprintf_impl+0x494>
			switch (length_mod) {
1fff8e1a:	1ecb      	subs	r3, r1, #3
1fff8e1c:	2b04      	cmp	r3, #4
1fff8e1e:	d804      	bhi.n	1fff8e2a <z_cbvprintf_impl+0x45a>
1fff8e20:	e8df f003 	tbb	[pc, r3]
1fff8e24:	18101018 	.word	0x18101018
1fff8e28:	18          	.byte	0x18
1fff8e29:	00          	.byte	0x00
			if (length_mod == LENGTH_HH) {
1fff8e2a:	2901      	cmp	r1, #1
				value->uint = va_arg(ap, unsigned int);
1fff8e2c:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
1fff8e30:	f04f 0200 	mov.w	r2, #0
1fff8e34:	d014      	beq.n	1fff8e60 <z_cbvprintf_impl+0x490>
			} else if (length_mod == LENGTH_H) {
1fff8e36:	2902      	cmp	r1, #2
				value->uint = va_arg(ap, unsigned int);
1fff8e38:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
			} else if (length_mod == LENGTH_H) {
1fff8e3c:	d1cc      	bne.n	1fff8dd8 <z_cbvprintf_impl+0x408>
				value->uint = (unsigned short)value->uint;
1fff8e3e:	b29b      	uxth	r3, r3
			value->ptr = va_arg(ap, void *);
1fff8e40:	930e      	str	r3, [sp, #56]	; 0x38
1fff8e42:	e7c9      	b.n	1fff8dd8 <z_cbvprintf_impl+0x408>
					(uint_value_type)va_arg(ap,
1fff8e44:	3407      	adds	r4, #7
1fff8e46:	f024 0407 	bic.w	r4, r4, #7
				value->uint =
1fff8e4a:	e8f4 2302 	ldrd	r2, r3, [r4], #8
1fff8e4e:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
			if (length_mod == LENGTH_HH) {
1fff8e52:	e7c1      	b.n	1fff8dd8 <z_cbvprintf_impl+0x408>
					(uint_value_type)va_arg(ap, size_t);
1fff8e54:	f854 3b04 	ldr.w	r3, [r4], #4
1fff8e58:	930e      	str	r3, [sp, #56]	; 0x38
1fff8e5a:	2300      	movs	r3, #0
1fff8e5c:	930f      	str	r3, [sp, #60]	; 0x3c
			} else if (length_mod == LENGTH_H) {
1fff8e5e:	e7bb      	b.n	1fff8dd8 <z_cbvprintf_impl+0x408>
				value->uint = (unsigned char)value->uint;
1fff8e60:	b2db      	uxtb	r3, r3
1fff8e62:	e7cd      	b.n	1fff8e00 <z_cbvprintf_impl+0x430>
		} else if (specifier_cat == SPECIFIER_FP) {
1fff8e64:	2b04      	cmp	r3, #4
1fff8e66:	d108      	bne.n	1fff8e7a <z_cbvprintf_impl+0x4aa>
					(sint_value_type)va_arg(ap, long long);
1fff8e68:	3407      	adds	r4, #7
				value->ldbl = va_arg(ap, long double);
1fff8e6a:	f024 0407 	bic.w	r4, r4, #7
1fff8e6e:	e9d4 2300 	ldrd	r2, r3, [r4]
1fff8e72:	3408      	adds	r4, #8
1fff8e74:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
1fff8e78:	e7ae      	b.n	1fff8dd8 <z_cbvprintf_impl+0x408>
		} else if (specifier_cat == SPECIFIER_PTR) {
1fff8e7a:	2b03      	cmp	r3, #3
1fff8e7c:	d1ac      	bne.n	1fff8dd8 <z_cbvprintf_impl+0x408>
			value->ptr = va_arg(ap, void *);
1fff8e7e:	f854 3b04 	ldr.w	r3, [r4], #4
1fff8e82:	e7dd      	b.n	1fff8e40 <z_cbvprintf_impl+0x470>
		switch (conv->specifier) {
1fff8e84:	f89d 0043 	ldrb.w	r0, [sp, #67]	; 0x43
1fff8e88:	2878      	cmp	r0, #120	; 0x78
1fff8e8a:	d8b4      	bhi.n	1fff8df6 <z_cbvprintf_impl+0x426>
1fff8e8c:	2862      	cmp	r0, #98	; 0x62
1fff8e8e:	d81c      	bhi.n	1fff8eca <z_cbvprintf_impl+0x4fa>
1fff8e90:	2825      	cmp	r0, #37	; 0x25
1fff8e92:	f43f adad 	beq.w	1fff89f0 <z_cbvprintf_impl+0x20>
1fff8e96:	2858      	cmp	r0, #88	; 0x58
1fff8e98:	d1ad      	bne.n	1fff8df6 <z_cbvprintf_impl+0x426>
			bps = encode_uint(value->uint, conv, buf, bpe);
1fff8e9a:	f10d 0336 	add.w	r3, sp, #54	; 0x36
1fff8e9e:	9300      	str	r3, [sp, #0]
1fff8ea0:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
1fff8ea4:	ab08      	add	r3, sp, #32
1fff8ea6:	aa10      	add	r2, sp, #64	; 0x40
1fff8ea8:	f002 fab6 	bl	1fffb418 <encode_uint>
			if (precision >= 0) {
1fff8eac:	f1ba 0f00 	cmp.w	sl, #0
			bps = encode_uint(value->uint, conv, buf, bpe);
1fff8eb0:	4607      	mov	r7, r0
			if (precision >= 0) {
1fff8eb2:	f280 809a 	bge.w	1fff8fea <z_cbvprintf_impl+0x61a>
		if (bps == NULL) {
1fff8eb6:	2f00      	cmp	r7, #0
1fff8eb8:	d09d      	beq.n	1fff8df6 <z_cbvprintf_impl+0x426>
		size_t nj_len = (bpe - bps);
1fff8eba:	f10d 0336 	add.w	r3, sp, #54	; 0x36
1fff8ebe:	1bd8      	subs	r0, r3, r7
		if (sign != 0) {
1fff8ec0:	2e00      	cmp	r6, #0
1fff8ec2:	f000 80c1 	beq.w	1fff9048 <z_cbvprintf_impl+0x678>
			nj_len += 1U;
1fff8ec6:	3001      	adds	r0, #1
1fff8ec8:	e0be      	b.n	1fff9048 <z_cbvprintf_impl+0x678>
		switch (conv->specifier) {
1fff8eca:	3863      	subs	r0, #99	; 0x63
1fff8ecc:	2815      	cmp	r0, #21
1fff8ece:	d892      	bhi.n	1fff8df6 <z_cbvprintf_impl+0x426>
1fff8ed0:	a201      	add	r2, pc, #4	; (adr r2, 1fff8ed8 <z_cbvprintf_impl+0x508>)
1fff8ed2:	f852 f020 	ldr.w	pc, [r2, r0, lsl #2]
1fff8ed6:	bf00      	nop
1fff8ed8:	1fff8fad 	.word	0x1fff8fad
1fff8edc:	1fff8fbf 	.word	0x1fff8fbf
1fff8ee0:	1fff8df7 	.word	0x1fff8df7
1fff8ee4:	1fff8df7 	.word	0x1fff8df7
1fff8ee8:	1fff8df7 	.word	0x1fff8df7
1fff8eec:	1fff8df7 	.word	0x1fff8df7
1fff8ef0:	1fff8fbf 	.word	0x1fff8fbf
1fff8ef4:	1fff8df7 	.word	0x1fff8df7
1fff8ef8:	1fff8df7 	.word	0x1fff8df7
1fff8efc:	1fff8df7 	.word	0x1fff8df7
1fff8f00:	1fff8df7 	.word	0x1fff8df7
1fff8f04:	1fff904d 	.word	0x1fff904d
1fff8f08:	1fff8fe5 	.word	0x1fff8fe5
1fff8f0c:	1fff900b 	.word	0x1fff900b
1fff8f10:	1fff8df7 	.word	0x1fff8df7
1fff8f14:	1fff8df7 	.word	0x1fff8df7
1fff8f18:	1fff8f31 	.word	0x1fff8f31
1fff8f1c:	1fff8df7 	.word	0x1fff8df7
1fff8f20:	1fff8fe5 	.word	0x1fff8fe5
1fff8f24:	1fff8df7 	.word	0x1fff8df7
1fff8f28:	1fff8df7 	.word	0x1fff8df7
1fff8f2c:	1fff8fe5 	.word	0x1fff8fe5
			if (precision >= 0) {
1fff8f30:	f1ba 0f00 	cmp.w	sl, #0
			bps = (const char *)value->ptr;
1fff8f34:	9f0e      	ldr	r7, [sp, #56]	; 0x38
			if (precision >= 0) {
1fff8f36:	db35      	blt.n	1fff8fa4 <z_cbvprintf_impl+0x5d4>
				len = strnlen(bps, precision);
1fff8f38:	4651      	mov	r1, sl
1fff8f3a:	4638      	mov	r0, r7
1fff8f3c:	f002 faf6 	bl	1fffb52c <strnlen>
			bpe = bps + len;
1fff8f40:	eb07 0a00 	add.w	sl, r7, r0
		if (bps == NULL) {
1fff8f44:	2f00      	cmp	r7, #0
1fff8f46:	f43f af56 	beq.w	1fff8df6 <z_cbvprintf_impl+0x426>
		char sign = 0;
1fff8f4a:	2600      	movs	r6, #0
		if (conv->altform_0c) {
1fff8f4c:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
1fff8f50:	f013 0210 	ands.w	r2, r3, #16
1fff8f54:	9205      	str	r2, [sp, #20]
1fff8f56:	f000 8093 	beq.w	1fff9080 <z_cbvprintf_impl+0x6b0>
			nj_len += 2U;
1fff8f5a:	3002      	adds	r0, #2
		if (conv->pad_fp) {
1fff8f5c:	065b      	lsls	r3, r3, #25
		nj_len += conv->pad0_value;
1fff8f5e:	9a11      	ldr	r2, [sp, #68]	; 0x44
			nj_len += conv->pad0_pre_exp;
1fff8f60:	bf48      	it	mi
1fff8f62:	9b12      	ldrmi	r3, [sp, #72]	; 0x48
		nj_len += conv->pad0_value;
1fff8f64:	9204      	str	r2, [sp, #16]
1fff8f66:	4410      	add	r0, r2
			nj_len += conv->pad0_pre_exp;
1fff8f68:	bf48      	it	mi
1fff8f6a:	18c0      	addmi	r0, r0, r3
		if (width > 0) {
1fff8f6c:	f1b8 0f00 	cmp.w	r8, #0
1fff8f70:	f340 80a0 	ble.w	1fff90b4 <z_cbvprintf_impl+0x6e4>
			if (!conv->flag_dash) {
1fff8f74:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
			width -= (int)nj_len;
1fff8f78:	eba8 0800 	sub.w	r8, r8, r0
			if (!conv->flag_dash) {
1fff8f7c:	f3c2 0380 	ubfx	r3, r2, #2, #1
1fff8f80:	0750      	lsls	r0, r2, #29
1fff8f82:	9306      	str	r3, [sp, #24]
1fff8f84:	f100 8096 	bmi.w	1fff90b4 <z_cbvprintf_impl+0x6e4>
				if (conv->flag_zero) {
1fff8f88:	0651      	lsls	r1, r2, #25
1fff8f8a:	f140 8089 	bpl.w	1fff90a0 <z_cbvprintf_impl+0x6d0>
					if (sign != 0) {
1fff8f8e:	b13e      	cbz	r6, 1fff8fa0 <z_cbvprintf_impl+0x5d0>
						OUTC(sign);
1fff8f90:	4659      	mov	r1, fp
1fff8f92:	4630      	mov	r0, r6
1fff8f94:	47c8      	blx	r9
1fff8f96:	2800      	cmp	r0, #0
1fff8f98:	db7f      	blt.n	1fff909a <z_cbvprintf_impl+0x6ca>
1fff8f9a:	9b06      	ldr	r3, [sp, #24]
1fff8f9c:	3501      	adds	r5, #1
1fff8f9e:	461e      	mov	r6, r3
					pad = '0';
1fff8fa0:	2230      	movs	r2, #48	; 0x30
1fff8fa2:	e07e      	b.n	1fff90a2 <z_cbvprintf_impl+0x6d2>
				len = strlen(bps);
1fff8fa4:	4638      	mov	r0, r7
1fff8fa6:	f002 faba 	bl	1fffb51e <strlen>
1fff8faa:	e7c9      	b.n	1fff8f40 <z_cbvprintf_impl+0x570>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
1fff8fac:	9b0e      	ldr	r3, [sp, #56]	; 0x38
1fff8fae:	f88d 3020 	strb.w	r3, [sp, #32]
		char sign = 0;
1fff8fb2:	2600      	movs	r6, #0
			bps = buf;
1fff8fb4:	af08      	add	r7, sp, #32
			bpe = buf + 1;
1fff8fb6:	f10d 0a21 	add.w	sl, sp, #33	; 0x21
		size_t nj_len = (bpe - bps);
1fff8fba:	2001      	movs	r0, #1
1fff8fbc:	e7c6      	b.n	1fff8f4c <z_cbvprintf_impl+0x57c>
			if (conv->flag_plus) {
1fff8fbe:	0719      	lsls	r1, r3, #28
			} else if (conv->flag_space) {
1fff8fc0:	bf5c      	itt	pl
1fff8fc2:	f3c3 1300 	ubfxpl	r3, r3, #4, #1
1fff8fc6:	015e      	lslpl	r6, r3, #5
			sint = value->sint;
1fff8fc8:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
				sign = '+';
1fff8fcc:	bf48      	it	mi
1fff8fce:	262b      	movmi	r6, #43	; 0x2b
			if (sint < 0) {
1fff8fd0:	2b00      	cmp	r3, #0
1fff8fd2:	f6bf af62 	bge.w	1fff8e9a <z_cbvprintf_impl+0x4ca>
				value->uint = (uint_value_type)-sint;
1fff8fd6:	4252      	negs	r2, r2
1fff8fd8:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
1fff8fdc:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
				sign = '-';
1fff8fe0:	262d      	movs	r6, #45	; 0x2d
1fff8fe2:	e75a      	b.n	1fff8e9a <z_cbvprintf_impl+0x4ca>
		switch (conv->specifier) {
1fff8fe4:	2600      	movs	r6, #0
1fff8fe6:	e758      	b.n	1fff8e9a <z_cbvprintf_impl+0x4ca>
		char sign = 0;
1fff8fe8:	2600      	movs	r6, #0
				conv->flag_zero = false;
1fff8fea:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
				size_t len = bpe - bps;
1fff8fee:	f10d 0336 	add.w	r3, sp, #54	; 0x36
1fff8ff2:	1bdb      	subs	r3, r3, r7
				conv->flag_zero = false;
1fff8ff4:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
1fff8ff8:	459a      	cmp	sl, r3
				conv->flag_zero = false;
1fff8ffa:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
				if (len < (size_t)precision) {
1fff8ffe:	f67f af5a 	bls.w	1fff8eb6 <z_cbvprintf_impl+0x4e6>
					conv->pad0_value = precision - (int)len;
1fff9002:	ebaa 0303 	sub.w	r3, sl, r3
1fff9006:	9311      	str	r3, [sp, #68]	; 0x44
1fff9008:	e755      	b.n	1fff8eb6 <z_cbvprintf_impl+0x4e6>
			if (value->ptr != NULL) {
1fff900a:	980e      	ldr	r0, [sp, #56]	; 0x38
1fff900c:	b390      	cbz	r0, 1fff9074 <z_cbvprintf_impl+0x6a4>
				bps = encode_uint((uintptr_t)value->ptr, conv,
1fff900e:	f10d 0336 	add.w	r3, sp, #54	; 0x36
1fff9012:	9300      	str	r3, [sp, #0]
1fff9014:	aa10      	add	r2, sp, #64	; 0x40
1fff9016:	ab08      	add	r3, sp, #32
1fff9018:	2100      	movs	r1, #0
1fff901a:	f002 f9fd 	bl	1fffb418 <encode_uint>
				conv->altform_0c = true;
1fff901e:	f8bd 3042 	ldrh.w	r3, [sp, #66]	; 0x42
1fff9022:	f003 03ef 	and.w	r3, r3, #239	; 0xef
1fff9026:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
1fff902a:	f043 0310 	orr.w	r3, r3, #16
			if (precision >= 0) {
1fff902e:	f1ba 0f00 	cmp.w	sl, #0
				bps = encode_uint((uintptr_t)value->ptr, conv,
1fff9032:	4607      	mov	r7, r0
				conv->altform_0c = true;
1fff9034:	f8ad 3042 	strh.w	r3, [sp, #66]	; 0x42
			if (precision >= 0) {
1fff9038:	dad6      	bge.n	1fff8fe8 <z_cbvprintf_impl+0x618>
		if (bps == NULL) {
1fff903a:	2800      	cmp	r0, #0
1fff903c:	f43f aedb 	beq.w	1fff8df6 <z_cbvprintf_impl+0x426>
		size_t nj_len = (bpe - bps);
1fff9040:	f10d 0336 	add.w	r3, sp, #54	; 0x36
1fff9044:	1a18      	subs	r0, r3, r0
		char sign = 0;
1fff9046:	2600      	movs	r6, #0
1fff9048:	469a      	mov	sl, r3
1fff904a:	e77f      	b.n	1fff8f4c <z_cbvprintf_impl+0x57c>
				store_count(conv, value->ptr, count);
1fff904c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	switch ((enum length_mod_enum)conv->length_mod) {
1fff904e:	2907      	cmp	r1, #7
1fff9050:	f63f aed1 	bhi.w	1fff8df6 <z_cbvprintf_impl+0x426>
1fff9054:	e8df f001 	tbb	[pc, r1]
1fff9058:	0c06040c 	.word	0x0c06040c
1fff905c:	0c0c0808 	.word	0x0c0c0808
		*(signed char *)dp = (signed char)count;
1fff9060:	701d      	strb	r5, [r3, #0]
		if (bps == NULL) {
1fff9062:	e6c8      	b.n	1fff8df6 <z_cbvprintf_impl+0x426>
		*(short *)dp = (short)count;
1fff9064:	801d      	strh	r5, [r3, #0]
		if (bps == NULL) {
1fff9066:	e6c6      	b.n	1fff8df6 <z_cbvprintf_impl+0x426>
		*(intmax_t *)dp = (intmax_t)count;
1fff9068:	17ea      	asrs	r2, r5, #31
1fff906a:	e9c3 5200 	strd	r5, r2, [r3]
		if (bps == NULL) {
1fff906e:	e6c2      	b.n	1fff8df6 <z_cbvprintf_impl+0x426>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
1fff9070:	601d      	str	r5, [r3, #0]
		if (bps == NULL) {
1fff9072:	e6c0      	b.n	1fff8df6 <z_cbvprintf_impl+0x426>
1fff9074:	4f2e      	ldr	r7, [pc, #184]	; (1fff9130 <z_cbvprintf_impl+0x760>)
		char sign = 0;
1fff9076:	4606      	mov	r6, r0
			bpe = bps + 5;
1fff9078:	f107 0a05 	add.w	sl, r7, #5
		size_t nj_len = (bpe - bps);
1fff907c:	2005      	movs	r0, #5
1fff907e:	e765      	b.n	1fff8f4c <z_cbvprintf_impl+0x57c>
		} else if (conv->altform_0) {
1fff9080:	071a      	lsls	r2, r3, #28
			nj_len += 1U;
1fff9082:	bf48      	it	mi
1fff9084:	3001      	addmi	r0, #1
1fff9086:	e769      	b.n	1fff8f5c <z_cbvprintf_impl+0x58c>
1fff9088:	9307      	str	r3, [sp, #28]
					OUTC(pad);
1fff908a:	4610      	mov	r0, r2
1fff908c:	9206      	str	r2, [sp, #24]
1fff908e:	4659      	mov	r1, fp
1fff9090:	47c8      	blx	r9
1fff9092:	2800      	cmp	r0, #0
1fff9094:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
1fff9098:	da04      	bge.n	1fff90a4 <z_cbvprintf_impl+0x6d4>
#undef OUTS
#undef OUTC
}
1fff909a:	b015      	add	sp, #84	; 0x54
1fff909c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
1fff90a0:	2220      	movs	r2, #32
					pad = '0';
1fff90a2:	4643      	mov	r3, r8
				while (width-- > 0) {
1fff90a4:	4619      	mov	r1, r3
1fff90a6:	2900      	cmp	r1, #0
1fff90a8:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
1fff90ac:	dcec      	bgt.n	1fff9088 <z_cbvprintf_impl+0x6b8>
1fff90ae:	4445      	add	r5, r8
1fff90b0:	1a6d      	subs	r5, r5, r1
1fff90b2:	4698      	mov	r8, r3
		if (sign != 0) {
1fff90b4:	b12e      	cbz	r6, 1fff90c2 <z_cbvprintf_impl+0x6f2>
			OUTC(sign);
1fff90b6:	4659      	mov	r1, fp
1fff90b8:	4630      	mov	r0, r6
1fff90ba:	47c8      	blx	r9
1fff90bc:	2800      	cmp	r0, #0
1fff90be:	dbec      	blt.n	1fff909a <z_cbvprintf_impl+0x6ca>
1fff90c0:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
1fff90c2:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
1fff90c6:	06da      	lsls	r2, r3, #27
1fff90c8:	d401      	bmi.n	1fff90ce <z_cbvprintf_impl+0x6fe>
1fff90ca:	071b      	lsls	r3, r3, #28
1fff90cc:	d505      	bpl.n	1fff90da <z_cbvprintf_impl+0x70a>
				OUTC('0');
1fff90ce:	4659      	mov	r1, fp
1fff90d0:	2030      	movs	r0, #48	; 0x30
1fff90d2:	47c8      	blx	r9
1fff90d4:	2800      	cmp	r0, #0
1fff90d6:	dbe0      	blt.n	1fff909a <z_cbvprintf_impl+0x6ca>
1fff90d8:	3501      	adds	r5, #1
			if (conv->altform_0c) {
1fff90da:	9b05      	ldr	r3, [sp, #20]
1fff90dc:	b133      	cbz	r3, 1fff90ec <z_cbvprintf_impl+0x71c>
				OUTC(conv->specifier);
1fff90de:	f89d 0043 	ldrb.w	r0, [sp, #67]	; 0x43
1fff90e2:	4659      	mov	r1, fp
1fff90e4:	47c8      	blx	r9
1fff90e6:	2800      	cmp	r0, #0
1fff90e8:	dbd7      	blt.n	1fff909a <z_cbvprintf_impl+0x6ca>
1fff90ea:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
1fff90ec:	9e04      	ldr	r6, [sp, #16]
1fff90ee:	442e      	add	r6, r5
1fff90f0:	e005      	b.n	1fff90fe <z_cbvprintf_impl+0x72e>
				OUTC('0');
1fff90f2:	4659      	mov	r1, fp
1fff90f4:	2030      	movs	r0, #48	; 0x30
1fff90f6:	47c8      	blx	r9
1fff90f8:	2800      	cmp	r0, #0
1fff90fa:	dbce      	blt.n	1fff909a <z_cbvprintf_impl+0x6ca>
1fff90fc:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
1fff90fe:	1b73      	subs	r3, r6, r5
1fff9100:	2b00      	cmp	r3, #0
1fff9102:	dcf6      	bgt.n	1fff90f2 <z_cbvprintf_impl+0x722>
			OUTS(bps, bpe);
1fff9104:	4653      	mov	r3, sl
1fff9106:	463a      	mov	r2, r7
1fff9108:	4659      	mov	r1, fp
1fff910a:	4648      	mov	r0, r9
1fff910c:	f002 f9ca 	bl	1fffb4a4 <outs>
1fff9110:	2800      	cmp	r0, #0
1fff9112:	dbc2      	blt.n	1fff909a <z_cbvprintf_impl+0x6ca>
1fff9114:	4405      	add	r5, r0
		while (width > 0) {
1fff9116:	44a8      	add	r8, r5
1fff9118:	eba8 0305 	sub.w	r3, r8, r5
1fff911c:	2b00      	cmp	r3, #0
1fff911e:	f77f ae6a 	ble.w	1fff8df6 <z_cbvprintf_impl+0x426>
			OUTC(' ');
1fff9122:	4659      	mov	r1, fp
1fff9124:	2020      	movs	r0, #32
1fff9126:	47c8      	blx	r9
1fff9128:	2800      	cmp	r0, #0
1fff912a:	dbb6      	blt.n	1fff909a <z_cbvprintf_impl+0x6ca>
1fff912c:	3501      	adds	r5, #1
			--width;
1fff912e:	e7f3      	b.n	1fff9118 <z_cbvprintf_impl+0x748>
1fff9130:	1fffd4a1 	.word	0x1fffd4a1

1fff9134 <rsc_table_get>:
#endif
};

void rsc_table_get(void **table_ptr, int *length)
{
	*table_ptr = (void *)&resource_table;
1fff9134:	4b02      	ldr	r3, [pc, #8]	; (1fff9140 <rsc_table_get+0xc>)
1fff9136:	6003      	str	r3, [r0, #0]
	*length = sizeof(resource_table);
1fff9138:	238c      	movs	r3, #140	; 0x8c
1fff913a:	600b      	str	r3, [r1, #0]
}
1fff913c:	4770      	bx	lr
1fff913e:	bf00      	nop
1fff9140:	20000120 	.word	0x20000120

1fff9144 <SOC_ClockInit>:
#include <zephyr/devicetree.h>
#include "wdog_imx.h"

/* Initialize clock. */
void SOC_ClockInit(void)
{
1fff9144:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	/*
	 * Disable WDOG3
	 *	Note : The WDOG clock Root is shared by all the 4 WDOGs,
	 *	so Zephyr code should avoid closing it
	 */
	CCM_UpdateRoot(CCM, ccmRootWdog, ccmRootmuxWdogOsc24m, 0, 0);
1fff9146:	4f1a      	ldr	r7, [pc, #104]	; (1fff91b0 <SOC_ClockInit+0x6c>)
1fff9148:	491a      	ldr	r1, [pc, #104]	; (1fff91b4 <SOC_ClockInit+0x70>)
 * @param ccmGate Gate control (see @ref _ccm_pll_gate and @ref _ccm_ccgr_gate enumeration)
 * @param control Gate control value (see @ref _ccm_gate_value)
 */
static inline void CCM_ControlGate(CCM_Type * base, uint32_t ccmGate, uint32_t control)
{
    CCM_REG(ccmGate) = control;
1fff914a:	4c1b      	ldr	r4, [pc, #108]	; (1fff91b8 <SOC_ClockInit+0x74>)
1fff914c:	2600      	movs	r6, #0
1fff914e:	4633      	mov	r3, r6
1fff9150:	4632      	mov	r2, r6
1fff9152:	9600      	str	r6, [sp, #0]
1fff9154:	4638      	mov	r0, r7
1fff9156:	f000 fca5 	bl	1fff9aa4 <CCM_UpdateRoot>
    CCM_REG_SET(ccmRoot) = CCM_TARGET_ROOT_SET_ENABLE_MASK;
1fff915a:	4b18      	ldr	r3, [pc, #96]	; (1fff91bc <SOC_ClockInit+0x78>)
1fff915c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
1fff9160:	f8c3 2b84 	str.w	r2, [r3, #2948]	; 0xb84
 * @param sreq Force acquiring SEMA42 to access this peripheral or not
 * @param lock Whether to lock this setting or not. Once locked, no one can change the RDC setting until reset
 */
static inline void RDC_SetPdapAccess(RDC_Type * base, uint32_t pdap, uint8_t perm, bool sreq, bool lock)
{
    base->PDAP[pdap] = perm | (sreq ? RDC_PDAP_SREQ_MASK : 0) | (lock ? RDC_PDAP_LCK_MASK : 0);
1fff9164:	f503 238a 	add.w	r3, r3, #282624	; 0x45000
    CCM_REG(ccmGate) = control;
1fff9168:	f241 1111 	movw	r1, #4369	; 0x1111
1fff916c:	220c      	movs	r2, #12
1fff916e:	f8c4 19e0 	str.w	r1, [r4, #2528]	; 0x9e0
1fff9172:	f8c3 2428 	str.w	r2, [r3, #1064]	; 0x428
 *
 * @param base WDOG base pointer.
 */
static inline void WDOG_DisablePowerdown(WDOG_Type *base)
{
    base->WMCR &= ~WDOG_WMCR_PDE_MASK;
1fff9176:	f5a3 1398 	sub.w	r3, r3, #1245184	; 0x130000
1fff917a:	891d      	ldrh	r5, [r3, #8]
1fff917c:	f025 0501 	bic.w	r5, r5, #1
1fff9180:	042d      	lsls	r5, r5, #16
1fff9182:	0c2d      	lsrs	r5, r5, #16
1fff9184:	811d      	strh	r5, [r3, #8]
1fff9186:	f8c4 69e0 	str.w	r6, [r4, #2528]	; 0x9e0
1fff918a:	f8c7 1860 	str.w	r1, [r7, #2144]	; 0x860
1fff918e:	f8c7 1880 	str.w	r1, [r7, #2176]	; 0x880
1fff9192:	f8c4 10a0 	str.w	r1, [r4, #160]	; 0xa0
1fff9196:	f8c4 10b0 	str.w	r1, [r4, #176]	; 0xb0
1fff919a:	f8c4 10c0 	str.w	r1, [r4, #192]	; 0xc0
1fff919e:	f8c4 1a80 	str.w	r1, [r4, #2688]	; 0xa80
1fff91a2:	f8c4 1a90 	str.w	r1, [r4, #2704]	; 0xa90
1fff91a6:	f8c4 1260 	str.w	r1, [r4, #608]	; 0x260
	CCM_ControlGate(CCM, ccmCcgrGateIomux, ccmClockNeededRun);
	CCM_ControlGate(CCM, ccmCcgrGateIomuxLpsr, ccmClockNeededRun);

	/* Enable clock gate for RDC */
	CCM_ControlGate(CCM, ccmCcgrGateRdc, ccmClockNeededRun);
}
1fff91aa:	b003      	add	sp, #12
1fff91ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
1fff91ae:	bf00      	nop
1fff91b0:	30380000 	.word	0x30380000
1fff91b4:	3038bb80 	.word	0x3038bb80
1fff91b8:	30384000 	.word	0x30384000
1fff91bc:	3038b000 	.word	0x3038b000

1fff91c0 <nxp_mcimx7_init>:
	CCM_ControlGate(CCM, ccmCcgrGateMu, ccmClockNeededRun);
}
#endif /* CONFIG_IPM_IMX */

static int nxp_mcimx7_init(const struct device *arg)
{
1fff91c0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    base->MDA[mda] = RDC_MDA_DID(domainId) | (lock ? RDC_MDA_LCK_MASK : 0);
1fff91c2:	4d15      	ldr	r5, [pc, #84]	; (1fff9218 <nxp_mcimx7_init+0x58>)
1fff91c4:	4e15      	ldr	r6, [pc, #84]	; (1fff921c <nxp_mcimx7_init+0x5c>)
1fff91c6:	2301      	movs	r3, #1
1fff91c8:	f8c5 3204 	str.w	r3, [r5, #516]	; 0x204

	/* SoC specific RDC settings */
	SOC_RdcInit();

	/* BoC specific clock settings */
	SOC_ClockInit();
1fff91cc:	f7ff ffba 	bl	1fff9144 <SOC_ClockInit>
	CCM_UpdateRoot(CCM, ccmRootUart6, ccmRootmuxUartOsc24m, 0, 0);
1fff91d0:	2400      	movs	r4, #0
    base->PDAP[pdap] = perm | (sreq ? RDC_PDAP_SREQ_MASK : 0) | (lock ? RDC_PDAP_LCK_MASK : 0);
1fff91d2:	230f      	movs	r3, #15
1fff91d4:	f242 2222 	movw	r2, #8738	; 0x2222
1fff91d8:	f8c5 3404 	str.w	r3, [r5, #1028]	; 0x404
1fff91dc:	4910      	ldr	r1, [pc, #64]	; (1fff9220 <nxp_mcimx7_init+0x60>)
1fff91de:	f8c6 2a10 	str.w	r2, [r6, #2576]	; 0xa10
1fff91e2:	4810      	ldr	r0, [pc, #64]	; (1fff9224 <nxp_mcimx7_init+0x64>)
1fff91e4:	f8c5 3520 	str.w	r3, [r5, #1312]	; 0x520
1fff91e8:	4622      	mov	r2, r4
1fff91ea:	4623      	mov	r3, r4
1fff91ec:	9400      	str	r4, [sp, #0]
1fff91ee:	f000 fc59 	bl	1fff9aa4 <CCM_UpdateRoot>
    CCM_REG_SET(ccmRoot) = CCM_TARGET_ROOT_SET_ENABLE_MASK;
1fff91f2:	4b0d      	ldr	r3, [pc, #52]	; (1fff9228 <nxp_mcimx7_init+0x68>)
1fff91f4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
1fff91f8:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
    CCM_REG(ccmGate) = control;
1fff91fc:	f243 3333 	movw	r3, #13107	; 0x3333
1fff9200:	f8c6 3990 	str.w	r3, [r6, #2448]	; 0x990
1fff9204:	230c      	movs	r3, #12
1fff9206:	f8c5 352c 	str.w	r3, [r5, #1324]	; 0x52c
#ifdef CONFIG_IPM_IMX
	nxp_mcimx7_mu_config();
#endif /* CONFIG_IPM_IMX */

	return 0;
}
1fff920a:	4620      	mov	r0, r4
1fff920c:	f241 1311 	movw	r3, #4369	; 0x1111
1fff9210:	f8c6 3270 	str.w	r3, [r6, #624]	; 0x270
1fff9214:	b002      	add	sp, #8
1fff9216:	bd70      	pop	{r4, r5, r6, pc}
1fff9218:	303d0000 	.word	0x303d0000
1fff921c:	30384000 	.word	0x30384000
1fff9220:	3038b200 	.word	0x3038b200
1fff9224:	30380000 	.word	0x30380000
1fff9228:	3038b000 	.word	0x3038b000

1fff922c <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
1fff922c:	4901      	ldr	r1, [pc, #4]	; (1fff9234 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
1fff922e:	2210      	movs	r2, #16
	str	r2, [r1]
1fff9230:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
1fff9232:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
1fff9234:	e000ed10 	.word	0xe000ed10

1fff9238 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
1fff9238:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
1fff923a:	4040      	eors	r0, r0
	msr	BASEPRI, r0
1fff923c:	f380 8811 	msr	BASEPRI, r0
	isb
1fff9240:	f3bf 8f6f 	isb	sy
	 * (i.e. if the caller sets _kernel.idle).
	 */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */

	/* Enter low power state */
	_sleep_if_allowed wfi
1fff9244:	f3bf 8f4f 	dsb	sy
1fff9248:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
1fff924a:	b662      	cpsie	i
	isb
1fff924c:	f3bf 8f6f 	isb	sy

	bx	lr
1fff9250:	4770      	bx	lr
1fff9252:	bf00      	nop

1fff9254 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
1fff9254:	b240      	sxtb	r0, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
1fff9256:	2800      	cmp	r0, #0
1fff9258:	db07      	blt.n	1fff926a <arch_irq_enable+0x16>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
1fff925a:	4a04      	ldr	r2, [pc, #16]	; (1fff926c <arch_irq_enable+0x18>)
1fff925c:	0941      	lsrs	r1, r0, #5
1fff925e:	2301      	movs	r3, #1
1fff9260:	f000 001f 	and.w	r0, r0, #31
1fff9264:	4083      	lsls	r3, r0
1fff9266:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
1fff926a:	4770      	bx	lr
1fff926c:	e000e100 	.word	0xe000e100

1fff9270 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
1fff9270:	b240      	sxtb	r0, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
1fff9272:	2800      	cmp	r0, #0
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
1fff9274:	bfa8      	it	ge
1fff9276:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
		prio += _IRQ_PRIO_OFFSET;
1fff927a:	f101 0101 	add.w	r1, r1, #1
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
1fff927e:	bfb8      	it	lt
1fff9280:	4b06      	ldrlt	r3, [pc, #24]	; (1fff929c <z_arm_irq_priority_set+0x2c>)
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
1fff9282:	ea4f 1101 	mov.w	r1, r1, lsl #4
1fff9286:	bfac      	ite	ge
1fff9288:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
1fff928c:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
1fff9290:	b2c9      	uxtb	r1, r1
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
1fff9292:	bfb4      	ite	lt
1fff9294:	5419      	strblt	r1, [r3, r0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
1fff9296:	f880 1300 	strbge.w	r1, [r0, #768]	; 0x300
}
1fff929a:	4770      	bx	lr
1fff929c:	e000ed14 	.word	0xe000ed14

1fff92a0 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
1fff92a0:	bf30      	wfi
    b z_SysNmiOnReset
1fff92a2:	f7ff bffd 	b.w	1fff92a0 <z_SysNmiOnReset>
1fff92a6:	bf00      	nop

1fff92a8 <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
1fff92a8:	4a0f      	ldr	r2, [pc, #60]	; (1fff92e8 <z_arm_prep_c+0x40>)
 *
 * This routine prepares for the execution of and runs C code.
 *
 */
void z_arm_prep_c(void)
{
1fff92aa:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
1fff92ac:	4b0f      	ldr	r3, [pc, #60]	; (1fff92ec <z_arm_prep_c+0x44>)
1fff92ae:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
1fff92b2:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
1fff92b4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
1fff92b8:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
1fff92bc:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
1fff92c0:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
1fff92c4:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 */
__STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, control" : "=r" (result) );
1fff92c8:	f3ef 8314 	mrs	r3, CONTROL
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
1fff92cc:	f023 0304 	bic.w	r3, r3, #4
  \details Writes the given value to the Control Register.
  \param [in]    control  Control Register value to set
 */
__STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
{
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
1fff92d0:	f383 8814 	msr	CONTROL, r3
  __ASM volatile ("isb 0xF":::"memory");
1fff92d4:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
1fff92d8:	f001 f88a 	bl	1fffa3f0 <z_bss_zero>
	z_data_copy();
1fff92dc:	f001 fd3c 	bl	1fffad58 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
1fff92e0:	f000 f9de 	bl	1fff96a0 <z_arm_interrupt_init>
	z_cstart();
1fff92e4:	f001 f8c4 	bl	1fffa470 <z_cstart>
1fff92e8:	1fff8000 	.word	0x1fff8000
1fff92ec:	e000ed00 	.word	0xe000ed00

1fff92f0 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
1fff92f0:	4a09      	ldr	r2, [pc, #36]	; (1fff9318 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
1fff92f2:	490a      	ldr	r1, [pc, #40]	; (1fff931c <arch_swap+0x2c>)
	_current->arch.basepri = key;
1fff92f4:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
1fff92f6:	6809      	ldr	r1, [r1, #0]
1fff92f8:	66d9      	str	r1, [r3, #108]	; 0x6c

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
1fff92fa:	4909      	ldr	r1, [pc, #36]	; (1fff9320 <arch_swap+0x30>)
	_current->arch.basepri = key;
1fff92fc:	6698      	str	r0, [r3, #104]	; 0x68
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
1fff92fe:	684b      	ldr	r3, [r1, #4]
1fff9300:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
1fff9304:	604b      	str	r3, [r1, #4]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
1fff9306:	2300      	movs	r3, #0
1fff9308:	f383 8811 	msr	BASEPRI, r3
1fff930c:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
1fff9310:	6893      	ldr	r3, [r2, #8]
}
1fff9312:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
1fff9314:	4770      	bx	lr
1fff9316:	bf00      	nop
1fff9318:	200005a8 	.word	0x200005a8
1fff931c:	1fffd30c 	.word	0x1fffd30c
1fff9320:	e000ed00 	.word	0xe000ed00

1fff9324 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
1fff9324:	490f      	ldr	r1, [pc, #60]	; (1fff9364 <z_arm_pendsv+0x40>)
    ldr r2, [r1, #_kernel_offset_to_current]
1fff9326:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
1fff9328:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
1fff932c:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
1fff932e:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
1fff9332:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
1fff9336:	2010      	movs	r0, #16
    msr BASEPRI_MAX, r0
1fff9338:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
1fff933c:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
1fff9340:	4f09      	ldr	r7, [pc, #36]	; (1fff9368 <z_arm_pendsv+0x44>)
    ldr v3, =_SCS_ICSR_UNPENDSV
1fff9342:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
1fff9346:	694a      	ldr	r2, [r1, #20]

    str r2, [r1, #_kernel_offset_to_current]
1fff9348:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
1fff934a:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
1fff934c:	6e90      	ldr	r0, [r2, #104]	; 0x68
    movs r3, #0
1fff934e:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
1fff9350:	6693      	str	r3, [r2, #104]	; 0x68
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
1fff9352:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
1fff9356:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
1fff935a:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
1fff935e:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
1fff9362:	4770      	bx	lr
    ldr r1, =_kernel
1fff9364:	200005a8 	.word	0x200005a8
    ldr v4, =_SCS_ICSR
1fff9368:	e000ed04 	.word	0xe000ed04

1fff936c <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
1fff936c:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
1fff9370:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
1fff9372:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
1fff9376:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
1fff937a:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
1fff937c:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
1fff9380:	2902      	cmp	r1, #2
    beq _oops
1fff9382:	d0ff      	beq.n	1fff9384 <_oops>

1fff9384 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
1fff9384:	b501      	push	{r0, lr}
    push {r1, r2}
    push {r4-r11}
    mov  r1, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    bl z_do_kernel_oops
1fff9386:	f002 f8a7 	bl	1fffb4d8 <z_do_kernel_oops>
     * the MSP to its value prior to entering the function
     */
    add sp, #40
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    pop {r0, pc}
1fff938a:	bd01      	pop	{r0, pc}

1fff938c <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
1fff938c:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
1fff9390:	9b00      	ldr	r3, [sp, #0]
1fff9392:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->pc &= 0xfffffffe;
1fff9396:	490a      	ldr	r1, [pc, #40]	; (1fff93c0 <arch_new_thread+0x34>)
	iframe->a3 = (uint32_t)p2;
1fff9398:	9b01      	ldr	r3, [sp, #4]
1fff939a:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
1fff939e:	9b02      	ldr	r3, [sp, #8]
1fff93a0:	f842 3c14 	str.w	r3, [r2, #-20]
	iframe->pc &= 0xfffffffe;
1fff93a4:	f021 0101 	bic.w	r1, r1, #1

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
1fff93a8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
1fff93ac:	f842 3c04 	str.w	r3, [r2, #-4]
	iframe->pc &= 0xfffffffe;
1fff93b0:	f842 1c08 	str.w	r1, [r2, #-8]
		((uintptr_t)iframe - sizeof(struct __fpu_sf));
	memset(iframe, 0, sizeof(struct __fpu_sf));
#endif

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
1fff93b4:	2300      	movs	r3, #0
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
1fff93b6:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
1fff93b8:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
1fff93ba:	6683      	str	r3, [r0, #104]	; 0x68
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
1fff93bc:	4770      	bx	lr
1fff93be:	bf00      	nop
1fff93c0:	1fffb07b 	.word	0x1fffb07b

1fff93c4 <arch_switch_to_main_thread>:
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
	z_arm_prepare_switch_to_main();

	_current = main_thread;
1fff93c4:	4b07      	ldr	r3, [pc, #28]	; (1fff93e4 <arch_switch_to_main_thread+0x20>)
1fff93c6:	6098      	str	r0, [r3, #8]

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
1fff93c8:	4610      	mov	r0, r2
1fff93ca:	f381 8809 	msr	PSP, r1
1fff93ce:	2100      	movs	r1, #0
1fff93d0:	b663      	cpsie	if
1fff93d2:	f381 8811 	msr	BASEPRI, r1
1fff93d6:	f3bf 8f6f 	isb	sy
1fff93da:	2200      	movs	r2, #0
1fff93dc:	2300      	movs	r3, #0
1fff93de:	f001 fe4c 	bl	1fffb07a <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
1fff93e2:	bf00      	nop
1fff93e4:	200005a8 	.word	0x200005a8

1fff93e8 <_isr_wrapper>:
 *
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
1fff93e8:	b501      	push	{r0, lr}
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
1fff93ea:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
1fff93ee:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
1fff93f2:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
1fff93f6:	4904      	ldr	r1, [pc, #16]	; (1fff9408 <_isr_wrapper+0x20>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
1fff93f8:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
1fff93fa:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
1fff93fc:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
1fff93fe:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
1fff9402:	4902      	ldr	r1, [pc, #8]	; (1fff940c <_isr_wrapper+0x24>)
	bx r1
1fff9404:	4708      	bx	r1
1fff9406:	0000      	.short	0x0000
	ldr r1, =_sw_isr_table
1fff9408:	1fffcb7c 	.word	0x1fffcb7c
	ldr r1, =z_arm_int_exit
1fff940c:	1fff9411 	.word	0x1fff9411

1fff9410 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
1fff9410:	4b04      	ldr	r3, [pc, #16]	; (1fff9424 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
1fff9412:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
1fff9414:	6958      	ldr	r0, [r3, #20]
	cmp r0, r1
1fff9416:	4288      	cmp	r0, r1
	beq _EXIT_EXC
1fff9418:	d003      	beq.n	1fff9422 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
1fff941a:	4903      	ldr	r1, [pc, #12]	; (1fff9428 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
1fff941c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
1fff9420:	600a      	str	r2, [r1, #0]

1fff9422 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
1fff9422:	4770      	bx	lr
	ldr r3, =_kernel
1fff9424:	200005a8 	.word	0x200005a8
	ldr r1, =_SCS_ICSR
1fff9428:	e000ed04 	.word	0xe000ed04

1fff942c <usage_fault.constprop.0>:
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
1fff942c:	4b13      	ldr	r3, [pc, #76]	; (1fff947c <usage_fault.constprop.0+0x50>)
1fff942e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
1fff9430:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
		reason = K_ERR_ARM_USAGE_DIV_0;
		PR_FAULT_INFO("  Division by zero");
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
1fff9434:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
1fff9436:	bf14      	ite	ne
1fff9438:	201e      	movne	r0, #30
1fff943a:	201d      	moveq	r0, #29
		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
1fff943c:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
1fff9440:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
1fff9442:	bf18      	it	ne
1fff9444:	201f      	movne	r0, #31
		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
1fff9446:	f412 2f00 	tst.w	r2, #524288	; 0x80000
		PR_FAULT_INFO("  No coprocessor instructions");
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
1fff944a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
1fff944c:	bf18      	it	ne
1fff944e:	2021      	movne	r0, #33	; 0x21
		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
1fff9450:	f412 2f80 	tst.w	r2, #262144	; 0x40000
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
1fff9454:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
1fff9456:	bf18      	it	ne
1fff9458:	2022      	movne	r0, #34	; 0x22
		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
1fff945a:	f412 3f00 	tst.w	r2, #131072	; 0x20000
		PR_FAULT_INFO("  Illegal use of the EPSR");
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
1fff945e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
1fff9460:	bf18      	it	ne
1fff9462:	2023      	movne	r0, #35	; 0x23
		reason = K_ERR_ARM_USAGE_UNDEFINED_INSTRUCTION;
1fff9464:	f412 3f80 	tst.w	r2, #65536	; 0x10000
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
1fff9468:	6a9a      	ldr	r2, [r3, #40]	; 0x28
1fff946a:	ea6f 4202 	mvn.w	r2, r2, lsl #16
1fff946e:	ea6f 4212 	mvn.w	r2, r2, lsr #16
1fff9472:	629a      	str	r2, [r3, #40]	; 0x28

	return reason;
}
1fff9474:	bf18      	it	ne
1fff9476:	2024      	movne	r0, #36	; 0x24
1fff9478:	4770      	bx	lr
1fff947a:	bf00      	nop
1fff947c:	e000ed00 	.word	0xe000ed00

1fff9480 <bus_fault.constprop.0>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
1fff9480:	b510      	push	{r4, lr}
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
1fff9482:	4b19      	ldr	r3, [pc, #100]	; (1fff94e8 <bus_fault.constprop.0+0x68>)
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
1fff9484:	4602      	mov	r2, r0
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
1fff9486:	6a98      	ldr	r0, [r3, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
1fff9488:	6a9c      	ldr	r4, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_BUS_GENERIC;
1fff948a:	f410 5f80 	tst.w	r0, #4096	; 0x1000
1fff948e:	bf14      	ite	ne
1fff9490:	2017      	movne	r0, #23
1fff9492:	2016      	moveq	r0, #22
		reason = K_ERR_ARM_BUS_UNSTACKING;
1fff9494:	f414 6f00 	tst.w	r4, #2048	; 0x800
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
1fff9498:	6a9c      	ldr	r4, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_UNSTACKING;
1fff949a:	bf18      	it	ne
1fff949c:	2018      	movne	r0, #24
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
1fff949e:	05a4      	lsls	r4, r4, #22
1fff94a0:	d509      	bpl.n	1fff94b6 <bus_fault.constprop.0+0x36>
		STORE_xFAR(bfar, SCB->BFAR);
1fff94a2:	6b98      	ldr	r0, [r3, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
1fff94a4:	6a98      	ldr	r0, [r3, #40]	; 0x28
1fff94a6:	0400      	lsls	r0, r0, #16
1fff94a8:	d504      	bpl.n	1fff94b4 <bus_fault.constprop.0+0x34>
			if (from_hard_fault != 0) {
1fff94aa:	b11a      	cbz	r2, 1fff94b4 <bus_fault.constprop.0+0x34>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
1fff94ac:	6a9a      	ldr	r2, [r3, #40]	; 0x28
1fff94ae:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
1fff94b2:	629a      	str	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_PRECISE_DATA_BUS;
1fff94b4:	2019      	movs	r0, #25
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
1fff94b6:	4b0c      	ldr	r3, [pc, #48]	; (1fff94e8 <bus_fault.constprop.0+0x68>)
1fff94b8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
1fff94ba:	f412 6f80 	tst.w	r2, #1024	; 0x400
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
1fff94be:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
1fff94c0:	bf18      	it	ne
1fff94c2:	201a      	movne	r0, #26
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
1fff94c4:	05d2      	lsls	r2, r2, #23
1fff94c6:	d40c      	bmi.n	1fff94e2 <bus_fault.constprop.0+0x62>
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
1fff94c8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_FP_LAZY_STATE_PRESERVATION;
1fff94ca:	f413 5f00 	tst.w	r3, #8192	; 0x2000
1fff94ce:	bf18      	it	ne
1fff94d0:	201c      	movne	r0, #28
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
1fff94d2:	4a05      	ldr	r2, [pc, #20]	; (1fff94e8 <bus_fault.constprop.0+0x68>)
1fff94d4:	6a93      	ldr	r3, [r2, #40]	; 0x28
1fff94d6:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
1fff94da:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
1fff94dc:	2300      	movs	r3, #0
1fff94de:	700b      	strb	r3, [r1, #0]
}
1fff94e0:	bd10      	pop	{r4, pc}
		reason = K_ERR_ARM_BUS_INSTRUCTION_BUS;
1fff94e2:	201b      	movs	r0, #27
1fff94e4:	e7f5      	b.n	1fff94d2 <bus_fault.constprop.0+0x52>
1fff94e6:	bf00      	nop
1fff94e8:	e000ed00 	.word	0xe000ed00

1fff94ec <mem_manage_fault.constprop.0>:
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
1fff94ec:	b510      	push	{r4, lr}
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
1fff94ee:	4b1c      	ldr	r3, [pc, #112]	; (1fff9560 <mem_manage_fault.constprop.0+0x74>)
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
1fff94f0:	4602      	mov	r2, r0
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
1fff94f2:	6a98      	ldr	r0, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
1fff94f4:	6a9c      	ldr	r4, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_MEM_GENERIC;
1fff94f6:	f010 0f10 	tst.w	r0, #16
1fff94fa:	bf14      	ite	ne
1fff94fc:	2011      	movne	r0, #17
1fff94fe:	2010      	moveq	r0, #16
		reason = K_ERR_ARM_MEM_UNSTACKING;
1fff9500:	f014 0f08 	tst.w	r4, #8
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
1fff9504:	6a9c      	ldr	r4, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_UNSTACKING;
1fff9506:	bf18      	it	ne
1fff9508:	2012      	movne	r0, #18
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
1fff950a:	07a4      	lsls	r4, r4, #30
1fff950c:	d509      	bpl.n	1fff9522 <mem_manage_fault.constprop.0+0x36>
		uint32_t temp = SCB->MMFAR;
1fff950e:	6b58      	ldr	r0, [r3, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
1fff9510:	6a98      	ldr	r0, [r3, #40]	; 0x28
1fff9512:	0600      	lsls	r0, r0, #24
1fff9514:	d504      	bpl.n	1fff9520 <mem_manage_fault.constprop.0+0x34>
			if (from_hard_fault != 0) {
1fff9516:	b11a      	cbz	r2, 1fff9520 <mem_manage_fault.constprop.0+0x34>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
1fff9518:	6a9a      	ldr	r2, [r3, #40]	; 0x28
1fff951a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
1fff951e:	629a      	str	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_DATA_ACCESS;
1fff9520:	2013      	movs	r0, #19
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
1fff9522:	4b0f      	ldr	r3, [pc, #60]	; (1fff9560 <mem_manage_fault.constprop.0+0x74>)
1fff9524:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
1fff9526:	f012 0f01 	tst.w	r2, #1
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
1fff952a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
1fff952c:	bf18      	it	ne
1fff952e:	2014      	movne	r0, #20
		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
1fff9530:	f012 0f20 	tst.w	r2, #32
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
1fff9534:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
1fff9536:	bf18      	it	ne
1fff9538:	2015      	movne	r0, #21
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
1fff953a:	06d4      	lsls	r4, r2, #27
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
1fff953c:	bf58      	it	pl
1fff953e:	6a9b      	ldrpl	r3, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
1fff9540:	4b07      	ldr	r3, [pc, #28]	; (1fff9560 <mem_manage_fault.constprop.0+0x74>)
1fff9542:	6a9a      	ldr	r2, [r3, #40]	; 0x28
1fff9544:	0692      	lsls	r2, r2, #26
		SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTPENDED_Msk;
1fff9546:	bf42      	ittt	mi
1fff9548:	6a5a      	ldrmi	r2, [r3, #36]	; 0x24
1fff954a:	f422 5200 	bicmi.w	r2, r2, #8192	; 0x2000
1fff954e:	625a      	strmi	r2, [r3, #36]	; 0x24
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
1fff9550:	6a9a      	ldr	r2, [r3, #40]	; 0x28
1fff9552:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
1fff9556:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
1fff9558:	2300      	movs	r3, #0
1fff955a:	700b      	strb	r3, [r1, #0]
}
1fff955c:	bd10      	pop	{r4, pc}
1fff955e:	bf00      	nop
1fff9560:	e000ed00 	.word	0xe000ed00

1fff9564 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
1fff9564:	b570      	push	{r4, r5, r6, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
1fff9566:	4b44      	ldr	r3, [pc, #272]	; (1fff9678 <z_arm_fault+0x114>)
1fff9568:	685b      	ldr	r3, [r3, #4]
{
1fff956a:	b08a      	sub	sp, #40	; 0x28
1fff956c:	4606      	mov	r6, r0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
1fff956e:	f3c3 0308 	ubfx	r3, r3, #0, #9
1fff9572:	2500      	movs	r5, #0
1fff9574:	f385 8811 	msr	BASEPRI, r5
1fff9578:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
1fff957c:	f002 407f 	and.w	r0, r2, #4278190080	; 0xff000000
1fff9580:	f1b0 4f7f 	cmp.w	r0, #4278190080	; 0xff000000
1fff9584:	d111      	bne.n	1fff95aa <z_arm_fault+0x46>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
1fff9586:	f002 000c 	and.w	r0, r2, #12
1fff958a:	2808      	cmp	r0, #8
1fff958c:	d00d      	beq.n	1fff95aa <z_arm_fault+0x46>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
1fff958e:	0710      	lsls	r0, r2, #28
			ptr_esf =  (z_arch_esf_t *)psp;
1fff9590:	bf4c      	ite	mi
1fff9592:	460e      	movmi	r6, r1
			*nested_exc = true;
1fff9594:	2501      	movpl	r5, #1
	*recoverable = false;
1fff9596:	2200      	movs	r2, #0
	switch (fault) {
1fff9598:	3b03      	subs	r3, #3
	*recoverable = false;
1fff959a:	f88d 2007 	strb.w	r2, [sp, #7]
	switch (fault) {
1fff959e:	2b03      	cmp	r3, #3
1fff95a0:	d805      	bhi.n	1fff95ae <z_arm_fault+0x4a>
1fff95a2:	e8df f003 	tbb	[pc, r3]
1fff95a6:	5c1e      	.short	0x5c1e
1fff95a8:	5960      	.short	0x5960
		return NULL;
1fff95aa:	462e      	mov	r6, r5
1fff95ac:	e7f3      	b.n	1fff9596 <z_arm_fault+0x32>
1fff95ae:	2400      	movs	r4, #0
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
1fff95b0:	f89d 3007 	ldrb.w	r3, [sp, #7]
1fff95b4:	b99b      	cbnz	r3, 1fff95de <z_arm_fault+0x7a>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
1fff95b6:	2220      	movs	r2, #32
1fff95b8:	4631      	mov	r1, r6
1fff95ba:	a802      	add	r0, sp, #8
1fff95bc:	f001 ffdf 	bl	1fffb57e <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
1fff95c0:	9b09      	ldr	r3, [sp, #36]	; 0x24
1fff95c2:	2d00      	cmp	r5, #0
1fff95c4:	d053      	beq.n	1fff966e <z_arm_fault+0x10a>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
1fff95c6:	f3c3 0208 	ubfx	r2, r3, #0, #9
1fff95ca:	b922      	cbnz	r2, 1fff95d6 <z_arm_fault+0x72>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
1fff95cc:	ea6f 2353 	mvn.w	r3, r3, lsr #9
1fff95d0:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
1fff95d4:	9309      	str	r3, [sp, #36]	; 0x24

	if (IS_ENABLED(CONFIG_SIMPLIFIED_EXCEPTION_CODES) && (reason >= K_ERR_ARCH_START)) {
		reason = K_ERR_CPU_EXCEPTION;
	}

	z_arm_fatal_error(reason, &esf_copy);
1fff95d6:	a902      	add	r1, sp, #8
1fff95d8:	4620      	mov	r0, r4
1fff95da:	f001 ff7b 	bl	1fffb4d4 <z_arm_fatal_error>
}
1fff95de:	b00a      	add	sp, #40	; 0x28
1fff95e0:	bd70      	pop	{r4, r5, r6, pc}
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
1fff95e2:	4b25      	ldr	r3, [pc, #148]	; (1fff9678 <z_arm_fault+0x114>)
1fff95e4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1fff95e6:	0791      	lsls	r1, r2, #30
1fff95e8:	d4e1      	bmi.n	1fff95ae <z_arm_fault+0x4a>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
1fff95ea:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1fff95ec:	2a00      	cmp	r2, #0
1fff95ee:	dbde      	blt.n	1fff95ae <z_arm_fault+0x4a>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
1fff95f0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1fff95f2:	0052      	lsls	r2, r2, #1
1fff95f4:	d5db      	bpl.n	1fff95ae <z_arm_fault+0x4a>
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
1fff95f6:	695a      	ldr	r2, [r3, #20]
	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
1fff95f8:	69b1      	ldr	r1, [r6, #24]
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
1fff95fa:	f442 7280 	orr.w	r2, r2, #256	; 0x100
1fff95fe:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
1fff9600:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
1fff9604:	f3bf 8f6f 	isb	sy
	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
1fff9608:	695a      	ldr	r2, [r3, #20]
	uint16_t fault_insn = *(ret_addr - 1);
1fff960a:	f831 1c02 	ldrh.w	r1, [r1, #-2]
	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
1fff960e:	f422 7280 	bic.w	r2, r2, #256	; 0x100
1fff9612:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
1fff9614:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
1fff9618:	f3bf 8f6f 	isb	sy
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
1fff961c:	f64d 7202 	movw	r2, #57090	; 0xdf02
1fff9620:	4291      	cmp	r1, r2
1fff9622:	d009      	beq.n	1fff9638 <z_arm_fault+0xd4>
		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
1fff9624:	6a9a      	ldr	r2, [r3, #40]	; 0x28
1fff9626:	b2d2      	uxtb	r2, r2
1fff9628:	b142      	cbz	r2, 1fff963c <z_arm_fault+0xd8>
			reason = mem_manage_fault(esf, 1, recoverable);
1fff962a:	f10d 0107 	add.w	r1, sp, #7
1fff962e:	2001      	movs	r0, #1
		reason = mem_manage_fault(esf, 0, recoverable);
1fff9630:	f7ff ff5c 	bl	1fff94ec <mem_manage_fault.constprop.0>
		reason = usage_fault(esf);
1fff9634:	4604      	mov	r4, r0
		break;
1fff9636:	e7bb      	b.n	1fff95b0 <z_arm_fault+0x4c>
			reason = esf->basic.r0;
1fff9638:	6834      	ldr	r4, [r6, #0]
1fff963a:	e7b9      	b.n	1fff95b0 <z_arm_fault+0x4c>
		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
1fff963c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
1fff963e:	f412 4f7f 	tst.w	r2, #65280	; 0xff00
1fff9642:	d005      	beq.n	1fff9650 <z_arm_fault+0xec>
			reason = bus_fault(esf, 1, recoverable);
1fff9644:	f10d 0107 	add.w	r1, sp, #7
1fff9648:	2001      	movs	r0, #1
		reason = bus_fault(esf, 0, recoverable);
1fff964a:	f7ff ff19 	bl	1fff9480 <bus_fault.constprop.0>
1fff964e:	e7f1      	b.n	1fff9634 <z_arm_fault+0xd0>
		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
1fff9650:	6a9b      	ldr	r3, [r3, #40]	; 0x28
1fff9652:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
1fff9656:	d3aa      	bcc.n	1fff95ae <z_arm_fault+0x4a>
		reason = usage_fault(esf);
1fff9658:	f7ff fee8 	bl	1fff942c <usage_fault.constprop.0>
1fff965c:	e7ea      	b.n	1fff9634 <z_arm_fault+0xd0>
		reason = mem_manage_fault(esf, 0, recoverable);
1fff965e:	f10d 0107 	add.w	r1, sp, #7
1fff9662:	2000      	movs	r0, #0
1fff9664:	e7e4      	b.n	1fff9630 <z_arm_fault+0xcc>
		reason = bus_fault(esf, 0, recoverable);
1fff9666:	f10d 0107 	add.w	r1, sp, #7
1fff966a:	2000      	movs	r0, #0
1fff966c:	e7ed      	b.n	1fff964a <z_arm_fault+0xe6>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
1fff966e:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
1fff9672:	f023 0301 	bic.w	r3, r3, #1
1fff9676:	e7ad      	b.n	1fff95d4 <z_arm_fault+0x70>
1fff9678:	e000ed00 	.word	0xe000ed00

1fff967c <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
1fff967c:	4a02      	ldr	r2, [pc, #8]	; (1fff9688 <z_arm_fault_init+0xc>)
1fff967e:	6953      	ldr	r3, [r2, #20]
1fff9680:	f043 0310 	orr.w	r3, r3, #16
1fff9684:	6153      	str	r3, [r2, #20]
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
#ifdef CONFIG_TRAP_UNALIGNED_ACCESS
	SCB->CCR |= SCB_CCR_UNALIGN_TRP_Msk;
#endif /* CONFIG_TRAP_UNALIGNED_ACCESS */
}
1fff9686:	4770      	bx	lr
1fff9688:	e000ed00 	.word	0xe000ed00

1fff968c <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
1fff968c:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
1fff9690:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
1fff9694:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
1fff9696:	4672      	mov	r2, lr
	bl z_arm_fault
1fff9698:	f7ff ff64 	bl	1fff9564 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
1fff969c:	bd01      	pop	{r0, pc}
1fff969e:	bf00      	nop

1fff96a0 <z_arm_interrupt_init>:
1fff96a0:	4804      	ldr	r0, [pc, #16]	; (1fff96b4 <z_arm_interrupt_init+0x14>)
 *
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
1fff96a2:	2300      	movs	r3, #0
1fff96a4:	2110      	movs	r1, #16
1fff96a6:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
1fff96a8:	3301      	adds	r3, #1
1fff96aa:	2b7f      	cmp	r3, #127	; 0x7f
1fff96ac:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
1fff96b0:	d1f9      	bne.n	1fff96a6 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
1fff96b2:	4770      	bx	lr
1fff96b4:	e000e100 	.word	0xe000e100

1fff96b8 <__start>:

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
1fff96b8:	2010      	movs	r0, #16
    msr BASEPRI, r0
1fff96ba:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
1fff96be:	4808      	ldr	r0, [pc, #32]	; (1fff96e0 <__start+0x28>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
1fff96c0:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
1fff96c4:	1840      	adds	r0, r0, r1
    msr PSP, r0
1fff96c6:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
1fff96ca:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
1fff96ce:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
1fff96d0:	4308      	orrs	r0, r1
    msr CONTROL, r0
1fff96d2:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
1fff96d6:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
1fff96da:	f7ff fde5 	bl	1fff92a8 <z_arm_prep_c>
1fff96de:	0000      	.short	0x0000
    ldr r0, =z_interrupt_stacks
1fff96e0:	200011f0 	.word	0x200011f0

1fff96e4 <z_impl_k_thread_abort>:
#include <zephyr/wait_q.h>
#include <zephyr/sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
1fff96e4:	4b08      	ldr	r3, [pc, #32]	; (1fff9708 <z_impl_k_thread_abort+0x24>)
1fff96e6:	689b      	ldr	r3, [r3, #8]
1fff96e8:	4283      	cmp	r3, r0
1fff96ea:	d10b      	bne.n	1fff9704 <z_impl_k_thread_abort+0x20>
 */
__STATIC_FORCEINLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
1fff96ec:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
1fff96f0:	b143      	cbz	r3, 1fff9704 <z_impl_k_thread_abort+0x20>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
1fff96f2:	4b06      	ldr	r3, [pc, #24]	; (1fff970c <z_impl_k_thread_abort+0x28>)
1fff96f4:	685a      	ldr	r2, [r3, #4]
1fff96f6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
1fff96fa:	605a      	str	r2, [r3, #4]
			/* Clear any system calls that may be pending
			 * as they have a higher priority than the PendSV
			 * handler and will check the stack of the thread
			 * being aborted.
			 */
			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
1fff96fc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
1fff96fe:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
1fff9702:	625a      	str	r2, [r3, #36]	; 0x24
		}
	}

	z_thread_abort(thread);
1fff9704:	f001 bac8 	b.w	1fffac98 <z_thread_abort>
1fff9708:	200005a8 	.word	0x200005a8
1fff970c:	e000ed00 	.word	0xe000ed00

1fff9710 <__stdout_hook_install>:

static int (*_stdout_hook)(int c) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int c))
{
	_stdout_hook = hook;
1fff9710:	4b01      	ldr	r3, [pc, #4]	; (1fff9718 <__stdout_hook_install+0x8>)
1fff9712:	6018      	str	r0, [r3, #0]
}
1fff9714:	4770      	bx	lr
1fff9716:	bf00      	nop
1fff9718:	2000009c 	.word	0x2000009c

1fff971c <snprintf>:
	return 0; /* indicate keep going so we get the total count */
}

int snprintf(char *ZRESTRICT str, size_t len,
	     const char *ZRESTRICT format, ...)
{
1fff971c:	b40c      	push	{r2, r3}
1fff971e:	b510      	push	{r4, lr}
1fff9720:	b086      	sub	sp, #24

	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
1fff9722:	b909      	cbnz	r1, 1fff9728 <snprintf+0xc>
		str = &dummy; /* write final NUL to dummy, can't change *s */
1fff9724:	f10d 000b 	add.w	r0, sp, #11
1fff9728:	2400      	movs	r4, #0
	}

	p.ptr = str;
	p.len = (int) len;
1fff972a:	e9cd 0104 	strd	r0, r1, [sp, #16]

	va_start(vargs, format);
1fff972e:	ab09      	add	r3, sp, #36	; 0x24
1fff9730:	9a08      	ldr	r2, [sp, #32]
1fff9732:	9400      	str	r4, [sp, #0]
1fff9734:	a904      	add	r1, sp, #16
1fff9736:	4805      	ldr	r0, [pc, #20]	; (1fff974c <snprintf+0x30>)
1fff9738:	9303      	str	r3, [sp, #12]
1fff973a:	f7ff f949 	bl	1fff89d0 <z_cbvprintf_impl>
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
	va_end(vargs);

	*(p.ptr) = 0;
1fff973e:	9b04      	ldr	r3, [sp, #16]
1fff9740:	701c      	strb	r4, [r3, #0]
	return r;
}
1fff9742:	b006      	add	sp, #24
1fff9744:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
1fff9748:	b002      	add	sp, #8
1fff974a:	4770      	bx	lr
1fff974c:	1fffb5ad 	.word	0x1fffb5ad

1fff9750 <ram_console_out>:
char ram_console[CONFIG_RAM_CONSOLE_BUFFER_SIZE + 1];
static int pos;

static int ram_console_out(int character)
{
	ram_console[pos] = (char)character;
1fff9750:	4906      	ldr	r1, [pc, #24]	; (1fff976c <ram_console_out+0x1c>)
1fff9752:	4a07      	ldr	r2, [pc, #28]	; (1fff9770 <ram_console_out+0x20>)
1fff9754:	680b      	ldr	r3, [r1, #0]
1fff9756:	54d0      	strb	r0, [r2, r3]
	pos = (pos + 1) % CONFIG_RAM_CONSOLE_BUFFER_SIZE;
1fff9758:	3301      	adds	r3, #1
1fff975a:	425a      	negs	r2, r3
1fff975c:	f3c2 0209 	ubfx	r2, r2, #0, #10
1fff9760:	f3c3 0309 	ubfx	r3, r3, #0, #10
1fff9764:	bf58      	it	pl
1fff9766:	4253      	negpl	r3, r2
1fff9768:	600b      	str	r3, [r1, #0]
	return character;
}
1fff976a:	4770      	bx	lr
1fff976c:	20000558 	.word	0x20000558
1fff9770:	200005ec 	.word	0x200005ec

1fff9774 <ram_console_init>:

static int ram_console_init(const struct device *d)
{
1fff9774:	b510      	push	{r4, lr}
	ARG_UNUSED(d);
	__printk_hook_install(ram_console_out);
1fff9776:	4c04      	ldr	r4, [pc, #16]	; (1fff9788 <ram_console_init+0x14>)
1fff9778:	4620      	mov	r0, r4
1fff977a:	f7ff f915 	bl	1fff89a8 <__printk_hook_install>
	__stdout_hook_install(ram_console_out);
1fff977e:	4620      	mov	r0, r4
1fff9780:	f7ff ffc6 	bl	1fff9710 <__stdout_hook_install>

	return 0;
}
1fff9784:	2000      	movs	r0, #0
1fff9786:	bd10      	pop	{r4, pc}
1fff9788:	1fff9751 	.word	0x1fff9751

1fff978c <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
1fff978c:	b508      	push	{r3, lr}
1fff978e:	4807      	ldr	r0, [pc, #28]	; (1fff97ac <uart_console_init+0x20>)
1fff9790:	f002 ffb4 	bl	1fffc6fc <z_device_is_ready>

	ARG_UNUSED(arg);

	if (!device_is_ready(uart_console_dev)) {
1fff9794:	b138      	cbz	r0, 1fff97a6 <uart_console_init+0x1a>
	__stdout_hook_install(console_out);
1fff9796:	4806      	ldr	r0, [pc, #24]	; (1fff97b0 <uart_console_init+0x24>)
1fff9798:	f7ff ffba 	bl	1fff9710 <__stdout_hook_install>
	__printk_hook_install(console_out);
1fff979c:	4804      	ldr	r0, [pc, #16]	; (1fff97b0 <uart_console_init+0x24>)
1fff979e:	f7ff f903 	bl	1fff89a8 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
1fff97a2:	2000      	movs	r0, #0
}
1fff97a4:	bd08      	pop	{r3, pc}
		return -ENODEV;
1fff97a6:	f06f 0012 	mvn.w	r0, #18
1fff97aa:	e7fb      	b.n	1fff97a4 <uart_console_init+0x18>
1fff97ac:	1fffcb4c 	.word	0x1fffcb4c
1fff97b0:	1fff97b5 	.word	0x1fff97b5

1fff97b4 <console_out>:
	if ('\n' == c) {
1fff97b4:	280a      	cmp	r0, #10
{
1fff97b6:	b538      	push	{r3, r4, r5, lr}
1fff97b8:	4d07      	ldr	r5, [pc, #28]	; (1fff97d8 <console_out+0x24>)
1fff97ba:	4604      	mov	r4, r0
	if ('\n' == c) {
1fff97bc:	d104      	bne.n	1fff97c8 <console_out+0x14>
					unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
1fff97be:	68ab      	ldr	r3, [r5, #8]
1fff97c0:	210d      	movs	r1, #13
1fff97c2:	685b      	ldr	r3, [r3, #4]
1fff97c4:	4628      	mov	r0, r5
1fff97c6:	4798      	blx	r3
1fff97c8:	68ab      	ldr	r3, [r5, #8]
1fff97ca:	4803      	ldr	r0, [pc, #12]	; (1fff97d8 <console_out+0x24>)
1fff97cc:	685b      	ldr	r3, [r3, #4]
1fff97ce:	b2e1      	uxtb	r1, r4
1fff97d0:	4798      	blx	r3
}
1fff97d2:	4620      	mov	r0, r4
1fff97d4:	bd38      	pop	{r3, r4, r5, pc}
1fff97d6:	bf00      	nop
1fff97d8:	1fffcb4c 	.word	0x1fffcb4c

1fff97dc <uart_imx_irq_err_disable>:
	UART_SetIntCmd(uart, uartIntParityError, true);
	UART_SetIntCmd(uart, uartIntFrameError, true);
}

static void uart_imx_irq_err_disable(const struct device *dev)
{
1fff97dc:	b510      	push	{r4, lr}
	UART_Type *uart = UART_STRUCT(dev);
1fff97de:	6843      	ldr	r3, [r0, #4]

	UART_SetIntCmd(uart, uartIntParityError, false);
1fff97e0:	4906      	ldr	r1, [pc, #24]	; (1fff97fc <uart_imx_irq_err_disable+0x20>)
	UART_Type *uart = UART_STRUCT(dev);
1fff97e2:	681c      	ldr	r4, [r3, #0]
	UART_SetIntCmd(uart, uartIntParityError, false);
1fff97e4:	2200      	movs	r2, #0
1fff97e6:	4620      	mov	r0, r4
1fff97e8:	f002 fa79 	bl	1fffbcde <UART_SetIntCmd>
	UART_SetIntCmd(uart, uartIntFrameError, false);
1fff97ec:	4620      	mov	r0, r4
1fff97ee:	4904      	ldr	r1, [pc, #16]	; (1fff9800 <uart_imx_irq_err_disable+0x24>)
}
1fff97f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	UART_SetIntCmd(uart, uartIntFrameError, false);
1fff97f4:	2200      	movs	r2, #0
1fff97f6:	f002 ba72 	b.w	1fffbcde <UART_SetIntCmd>
1fff97fa:	bf00      	nop
1fff97fc:	0088000c 	.word	0x0088000c
1fff9800:	0088000b 	.word	0x0088000b

1fff9804 <uart_imx_irq_err_enable>:
{
1fff9804:	b510      	push	{r4, lr}
	UART_Type *uart = UART_STRUCT(dev);
1fff9806:	6843      	ldr	r3, [r0, #4]
	UART_SetIntCmd(uart, uartIntParityError, true);
1fff9808:	4906      	ldr	r1, [pc, #24]	; (1fff9824 <uart_imx_irq_err_enable+0x20>)
	UART_Type *uart = UART_STRUCT(dev);
1fff980a:	681c      	ldr	r4, [r3, #0]
	UART_SetIntCmd(uart, uartIntParityError, true);
1fff980c:	2201      	movs	r2, #1
1fff980e:	4620      	mov	r0, r4
1fff9810:	f002 fa65 	bl	1fffbcde <UART_SetIntCmd>
	UART_SetIntCmd(uart, uartIntFrameError, true);
1fff9814:	4620      	mov	r0, r4
1fff9816:	4904      	ldr	r1, [pc, #16]	; (1fff9828 <uart_imx_irq_err_enable+0x24>)
}
1fff9818:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	UART_SetIntCmd(uart, uartIntFrameError, true);
1fff981c:	2201      	movs	r2, #1
1fff981e:	f002 ba5e 	b.w	1fffbcde <UART_SetIntCmd>
1fff9822:	bf00      	nop
1fff9824:	0088000c 	.word	0x0088000c
1fff9828:	0088000b 	.word	0x0088000b

1fff982c <uart_imx_irq_rx_disable>:
	UART_Type *uart = UART_STRUCT(dev);
1fff982c:	6843      	ldr	r3, [r0, #4]
	UART_SetIntCmd(uart, uartIntRxReady, false);
1fff982e:	4902      	ldr	r1, [pc, #8]	; (1fff9838 <uart_imx_irq_rx_disable+0xc>)
1fff9830:	6818      	ldr	r0, [r3, #0]
1fff9832:	2200      	movs	r2, #0
1fff9834:	f002 ba53 	b.w	1fffbcde <UART_SetIntCmd>
1fff9838:	00800009 	.word	0x00800009

1fff983c <uart_imx_irq_rx_enable>:
	UART_Type *uart = UART_STRUCT(dev);
1fff983c:	6843      	ldr	r3, [r0, #4]
	UART_SetIntCmd(uart, uartIntRxReady, true);
1fff983e:	4902      	ldr	r1, [pc, #8]	; (1fff9848 <uart_imx_irq_rx_enable+0xc>)
1fff9840:	6818      	ldr	r0, [r3, #0]
1fff9842:	2201      	movs	r2, #1
1fff9844:	f002 ba4b 	b.w	1fffbcde <UART_SetIntCmd>
1fff9848:	00800009 	.word	0x00800009

1fff984c <uart_imx_irq_tx_disable>:
	UART_Type *uart = UART_STRUCT(dev);
1fff984c:	6843      	ldr	r3, [r0, #4]
	UART_SetIntCmd(uart, uartIntTxReady, false);
1fff984e:	4902      	ldr	r1, [pc, #8]	; (1fff9858 <uart_imx_irq_tx_disable+0xc>)
1fff9850:	6818      	ldr	r0, [r3, #0]
1fff9852:	2200      	movs	r2, #0
1fff9854:	f002 ba43 	b.w	1fffbcde <UART_SetIntCmd>
1fff9858:	0080000d 	.word	0x0080000d

1fff985c <uart_imx_irq_tx_enable>:
	UART_Type *uart = UART_STRUCT(dev);
1fff985c:	6843      	ldr	r3, [r0, #4]
	UART_SetIntCmd(uart, uartIntTxReady, true);
1fff985e:	4902      	ldr	r1, [pc, #8]	; (1fff9868 <uart_imx_irq_tx_enable+0xc>)
1fff9860:	6818      	ldr	r0, [r3, #0]
1fff9862:	2201      	movs	r2, #1
1fff9864:	f002 ba3b 	b.w	1fffbcde <UART_SetIntCmd>
1fff9868:	0080000d 	.word	0x0080000d

1fff986c <uart_imx_fifo_read>:
{
1fff986c:	b510      	push	{r4, lr}
	UART_Type *uart = UART_STRUCT(dev);
1fff986e:	6843      	ldr	r3, [r0, #4]
1fff9870:	6818      	ldr	r0, [r3, #0]
	while (((size - num_rx) > 0) &&
1fff9872:	2400      	movs	r4, #0
1fff9874:	4294      	cmp	r4, r2
1fff9876:	d003      	beq.n	1fff9880 <uart_imx_fifo_read+0x14>
 */
static inline bool UART_GetStatusFlag(UART_Type* base, uint32_t flag){
    volatile uint32_t* uart_reg = 0;

    uart_reg = (uint32_t *)((uint32_t)base + (flag >> 16));
    return (bool)((*uart_reg >> (flag & 0x0000FFFF)) & 0x1);
1fff9878:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
1fff987c:	059b      	lsls	r3, r3, #22
1fff987e:	d408      	bmi.n	1fff9892 <uart_imx_fifo_read+0x26>
1fff9880:	f8d0 3098 	ldr.w	r3, [r0, #152]	; 0x98
	if (UART_GetStatusFlag(uart, uartStatusRxOverrun)) {
1fff9884:	079b      	lsls	r3, r3, #30
1fff9886:	d502      	bpl.n	1fff988e <uart_imx_fifo_read+0x22>
		UART_ClearStatusFlag(uart, uartStatusRxOverrun);
1fff9888:	4904      	ldr	r1, [pc, #16]	; (1fff989c <uart_imx_fifo_read+0x30>)
1fff988a:	f002 fa37 	bl	1fffbcfc <UART_ClearStatusFlag>
}
1fff988e:	4620      	mov	r0, r4
1fff9890:	bd10      	pop	{r4, pc}
    return (uint8_t)(UART_URXD_REG(base) & UART_URXD_RX_DATA_MASK);
1fff9892:	6803      	ldr	r3, [r0, #0]
1fff9894:	550b      	strb	r3, [r1, r4]
1fff9896:	3401      	adds	r4, #1
1fff9898:	e7ec      	b.n	1fff9874 <uart_imx_fifo_read+0x8>
1fff989a:	bf00      	nop
1fff989c:	00980001 	.word	0x00980001

1fff98a0 <uart_imx_poll_in>:
{
1fff98a0:	b508      	push	{r3, lr}
	UART_Type *uart = UART_STRUCT(dev);
1fff98a2:	6843      	ldr	r3, [r0, #4]
1fff98a4:	6818      	ldr	r0, [r3, #0]
    return (bool)((*uart_reg >> (flag & 0x0000FFFF)) & 0x1);
1fff98a6:	f8d0 3098 	ldr.w	r3, [r0, #152]	; 0x98
	if (UART_GetStatusFlag(uart, uartStatusRxDataReady)) {
1fff98aa:	07da      	lsls	r2, r3, #31
1fff98ac:	d50b      	bpl.n	1fff98c6 <uart_imx_poll_in+0x26>
    return (uint8_t)(UART_URXD_REG(base) & UART_URXD_RX_DATA_MASK);
1fff98ae:	6803      	ldr	r3, [r0, #0]
1fff98b0:	700b      	strb	r3, [r1, #0]
    return (bool)((*uart_reg >> (flag & 0x0000FFFF)) & 0x1);
1fff98b2:	f8d0 3098 	ldr.w	r3, [r0, #152]	; 0x98
		if (UART_GetStatusFlag(uart, uartStatusRxOverrun)) {
1fff98b6:	079b      	lsls	r3, r3, #30
1fff98b8:	d401      	bmi.n	1fff98be <uart_imx_poll_in+0x1e>
		ret = 0;
1fff98ba:	2000      	movs	r0, #0
}
1fff98bc:	bd08      	pop	{r3, pc}
			UART_ClearStatusFlag(uart, uartStatusRxOverrun);
1fff98be:	4903      	ldr	r1, [pc, #12]	; (1fff98cc <uart_imx_poll_in+0x2c>)
1fff98c0:	f002 fa1c 	bl	1fffbcfc <UART_ClearStatusFlag>
1fff98c4:	e7f9      	b.n	1fff98ba <uart_imx_poll_in+0x1a>
	int ret = -1;
1fff98c6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	return ret;
1fff98ca:	e7f7      	b.n	1fff98bc <uart_imx_poll_in+0x1c>
1fff98cc:	00980001 	.word	0x00980001

1fff98d0 <elapsed>:
 *     - the timer reset or the last time the function was called
 *     - and until the current call of the function is completed.
 * - the function is invoked with interrupts disabled.
 */
static uint32_t elapsed(void)
{
1fff98d0:	b510      	push	{r4, lr}
	uint32_t val1 = SysTick->VAL;	/* A */
1fff98d2:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
1fff98d6:	699a      	ldr	r2, [r3, #24]
	uint32_t ctrl = SysTick->CTRL;	/* B */
1fff98d8:	6919      	ldr	r1, [r3, #16]
	uint32_t val2 = SysTick->VAL;	/* C */
1fff98da:	6998      	ldr	r0, [r3, #24]
	 * 4) After C we'll see it next time
	 *
	 * So the count in val2 is post-wrap and last_load needs to be
	 * added if and only if COUNTFLAG is set or val1 < val2.
	 */
	if ((ctrl & SysTick_CTRL_COUNTFLAG_Msk)
1fff98dc:	4b09      	ldr	r3, [pc, #36]	; (1fff9904 <elapsed+0x34>)
1fff98de:	f411 3f80 	tst.w	r1, #65536	; 0x10000
1fff98e2:	4909      	ldr	r1, [pc, #36]	; (1fff9908 <elapsed+0x38>)
1fff98e4:	d101      	bne.n	1fff98ea <elapsed+0x1a>
	    || (val1 < val2)) {
1fff98e6:	4282      	cmp	r2, r0
1fff98e8:	d206      	bcs.n	1fff98f8 <elapsed+0x28>
		overflow_cyc += last_load;
1fff98ea:	681a      	ldr	r2, [r3, #0]
1fff98ec:	680c      	ldr	r4, [r1, #0]
1fff98ee:	4422      	add	r2, r4
1fff98f0:	601a      	str	r2, [r3, #0]

		/* We know there was a wrap, but we might not have
		 * seen it in CTRL, so clear it. */
		(void)SysTick->CTRL;
1fff98f2:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
1fff98f6:	6912      	ldr	r2, [r2, #16]
	}

	return (last_load - val2) + overflow_cyc;
1fff98f8:	681b      	ldr	r3, [r3, #0]
1fff98fa:	680a      	ldr	r2, [r1, #0]
1fff98fc:	4413      	add	r3, r2
}
1fff98fe:	1a18      	subs	r0, r3, r0
1fff9900:	bd10      	pop	{r4, pc}
1fff9902:	bf00      	nop
1fff9904:	20000578 	.word	0x20000578
1fff9908:	20000584 	.word	0x20000584

1fff990c <sys_clock_driver_init>:
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
1fff990c:	4b09      	ldr	r3, [pc, #36]	; (1fff9934 <sys_clock_driver_init+0x28>)
1fff990e:	2210      	movs	r2, #16
1fff9910:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
static int sys_clock_driver_init(const struct device *dev)
{
	ARG_UNUSED(dev);

	NVIC_SetPriority(SysTick_IRQn, _IRQ_PRIO_OFFSET);
	last_load = CYC_PER_TICK - 1;
1fff9914:	4b08      	ldr	r3, [pc, #32]	; (1fff9938 <sys_clock_driver_init+0x2c>)
1fff9916:	f644 621f 	movw	r2, #19999	; 0x4e1f
1fff991a:	601a      	str	r2, [r3, #0]
	overflow_cyc = 0U;
1fff991c:	4b07      	ldr	r3, [pc, #28]	; (1fff993c <sys_clock_driver_init+0x30>)
1fff991e:	2000      	movs	r0, #0
1fff9920:	6018      	str	r0, [r3, #0]
	SysTick->LOAD = last_load;
1fff9922:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
1fff9926:	615a      	str	r2, [r3, #20]
	SysTick->VAL = 0; /* resets timer to last_load */
1fff9928:	6198      	str	r0, [r3, #24]
	SysTick->CTRL |= (SysTick_CTRL_ENABLE_Msk |
1fff992a:	691a      	ldr	r2, [r3, #16]
1fff992c:	f042 0207 	orr.w	r2, r2, #7
1fff9930:	611a      	str	r2, [r3, #16]
			  SysTick_CTRL_TICKINT_Msk |
			  SysTick_CTRL_CLKSOURCE_Msk);
	return 0;
}
1fff9932:	4770      	bx	lr
1fff9934:	e000ed00 	.word	0xe000ed00
1fff9938:	20000584 	.word	0x20000584
1fff993c:	20000578 	.word	0x20000578

1fff9940 <sys_clock_isr>:
{
1fff9940:	b508      	push	{r3, lr}
	elapsed();
1fff9942:	f7ff ffc5 	bl	1fff98d0 <elapsed>
	cycle_count += overflow_cyc;
1fff9946:	4b0c      	ldr	r3, [pc, #48]	; (1fff9978 <sys_clock_isr+0x38>)
1fff9948:	4a0c      	ldr	r2, [pc, #48]	; (1fff997c <sys_clock_isr+0x3c>)
1fff994a:	6818      	ldr	r0, [r3, #0]
1fff994c:	6811      	ldr	r1, [r2, #0]
1fff994e:	4408      	add	r0, r1
1fff9950:	6010      	str	r0, [r2, #0]
	overflow_cyc = 0;
1fff9952:	2200      	movs	r2, #0
1fff9954:	601a      	str	r2, [r3, #0]
		dticks = (cycle_count - announced_cycles) / CYC_PER_TICK;
1fff9956:	4a0a      	ldr	r2, [pc, #40]	; (1fff9980 <sys_clock_isr+0x40>)
1fff9958:	6813      	ldr	r3, [r2, #0]
1fff995a:	f644 6120 	movw	r1, #20000	; 0x4e20
1fff995e:	1ac0      	subs	r0, r0, r3
1fff9960:	fbb0 f0f1 	udiv	r0, r0, r1
		announced_cycles += dticks * CYC_PER_TICK;
1fff9964:	fb01 3300 	mla	r3, r1, r0, r3
1fff9968:	6013      	str	r3, [r2, #0]
		sys_clock_announce(dticks);
1fff996a:	f001 facb 	bl	1fffaf04 <sys_clock_announce>
}
1fff996e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
1fff9972:	f7ff bd4d 	b.w	1fff9410 <z_arm_exc_exit>
1fff9976:	bf00      	nop
1fff9978:	20000578 	.word	0x20000578
1fff997c:	20000580 	.word	0x20000580
1fff9980:	2000057c 	.word	0x2000057c

1fff9984 <sys_clock_set_timeout>:
{
1fff9984:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
1fff9988:	4e32      	ldr	r6, [pc, #200]	; (1fff9a54 <sys_clock_set_timeout+0xd0>)
	if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && idle && ticks == K_TICKS_FOREVER) {
1fff998a:	2900      	cmp	r1, #0
1fff998c:	d055      	beq.n	1fff9a3a <sys_clock_set_timeout+0xb6>
1fff998e:	1c42      	adds	r2, r0, #1
1fff9990:	d10a      	bne.n	1fff99a8 <sys_clock_set_timeout+0x24>
		SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
1fff9992:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
1fff9996:	6913      	ldr	r3, [r2, #16]
1fff9998:	f023 0301 	bic.w	r3, r3, #1
1fff999c:	6113      	str	r3, [r2, #16]
		last_load = TIMER_STOPPED;
1fff999e:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
1fff99a2:	6033      	str	r3, [r6, #0]
}
1fff99a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uint32_t last_load_ = last_load;
1fff99a8:	6835      	ldr	r5, [r6, #0]
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
1fff99aa:	2801      	cmp	r0, #1
1fff99ac:	dd4b      	ble.n	1fff9a46 <sys_clock_set_timeout+0xc2>
1fff99ae:	f240 3845 	movw	r8, #837	; 0x345
1fff99b2:	4540      	cmp	r0, r8
1fff99b4:	dc01      	bgt.n	1fff99ba <sys_clock_set_timeout+0x36>
1fff99b6:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
	__asm__ volatile(
1fff99ba:	f04f 0310 	mov.w	r3, #16
1fff99be:	f3ef 8411 	mrs	r4, BASEPRI
1fff99c2:	f383 8812 	msr	BASEPRI_MAX, r3
1fff99c6:	f3bf 8f6f 	isb	sy
	uint32_t pending = elapsed();
1fff99ca:	f7ff ff81 	bl	1fff98d0 <elapsed>
	cycle_count += pending;
1fff99ce:	4f22      	ldr	r7, [pc, #136]	; (1fff9a58 <sys_clock_set_timeout+0xd4>)
	val1 = SysTick->VAL;
1fff99d0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
	overflow_cyc = 0U;
1fff99d4:	2100      	movs	r1, #0
	val1 = SysTick->VAL;
1fff99d6:	f8d3 c018 	ldr.w	ip, [r3, #24]
	cycle_count += pending;
1fff99da:	683b      	ldr	r3, [r7, #0]
1fff99dc:	18c2      	adds	r2, r0, r3
	overflow_cyc = 0U;
1fff99de:	4b1f      	ldr	r3, [pc, #124]	; (1fff9a5c <sys_clock_set_timeout+0xd8>)
1fff99e0:	6019      	str	r1, [r3, #0]
	uint32_t unannounced = cycle_count - announced_cycles;
1fff99e2:	4b1f      	ldr	r3, [pc, #124]	; (1fff9a60 <sys_clock_set_timeout+0xdc>)
1fff99e4:	681b      	ldr	r3, [r3, #0]
	if ((int32_t)unannounced < 0) {
1fff99e6:	1ad1      	subs	r1, r2, r3
1fff99e8:	d430      	bmi.n	1fff9a4c <sys_clock_set_timeout+0xc8>
		delay = ticks * CYC_PER_TICK;
1fff99ea:	f644 6020 	movw	r0, #20000	; 0x4e20
		delay += unannounced;
1fff99ee:	fb00 1108 	mla	r1, r0, r8, r1
		 ((delay + CYC_PER_TICK - 1) / CYC_PER_TICK) * CYC_PER_TICK;
1fff99f2:	f501 419c 	add.w	r1, r1, #19968	; 0x4e00
		delay -= unannounced;
1fff99f6:	1a9b      	subs	r3, r3, r2
		 ((delay + CYC_PER_TICK - 1) / CYC_PER_TICK) * CYC_PER_TICK;
1fff99f8:	311f      	adds	r1, #31
1fff99fa:	fbb1 f1f0 	udiv	r1, r1, r0
		delay -= unannounced;
1fff99fe:	fb00 3301 	mla	r3, r0, r1, r3
		delay = MAX(delay, MIN_DELAY);
1fff9a02:	f240 41e2 	movw	r1, #1250	; 0x4e2
1fff9a06:	428b      	cmp	r3, r1
1fff9a08:	d920      	bls.n	1fff9a4c <sys_clock_set_timeout+0xc8>
		if (delay > MAX_CYCLES) {
1fff9a0a:	4916      	ldr	r1, [pc, #88]	; (1fff9a64 <sys_clock_set_timeout+0xe0>)
1fff9a0c:	428b      	cmp	r3, r1
1fff9a0e:	bf28      	it	cs
1fff9a10:	460b      	movcs	r3, r1
	val2 = SysTick->VAL;
1fff9a12:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
		last_load = MIN_DELAY;
1fff9a16:	6033      	str	r3, [r6, #0]
	val2 = SysTick->VAL;
1fff9a18:	6988      	ldr	r0, [r1, #24]
	SysTick->LOAD = last_load - 1;
1fff9a1a:	3b01      	subs	r3, #1
1fff9a1c:	614b      	str	r3, [r1, #20]
	SysTick->VAL = 0; /* resets timer to last_load */
1fff9a1e:	2300      	movs	r3, #0
1fff9a20:	618b      	str	r3, [r1, #24]
	if (val1 < val2) {
1fff9a22:	4584      	cmp	ip, r0
1fff9a24:	ebac 0300 	sub.w	r3, ip, r0
		cycle_count += (val1 + (last_load_ - val2));
1fff9a28:	bf38      	it	cc
1fff9a2a:	195b      	addcc	r3, r3, r5
		cycle_count += (val1 - val2);
1fff9a2c:	441a      	add	r2, r3
1fff9a2e:	603a      	str	r2, [r7, #0]
	__asm__ volatile(
1fff9a30:	f384 8811 	msr	BASEPRI, r4
1fff9a34:	f3bf 8f6f 	isb	sy
1fff9a38:	e7b4      	b.n	1fff99a4 <sys_clock_set_timeout+0x20>
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
1fff9a3a:	1c43      	adds	r3, r0, #1
	uint32_t last_load_ = last_load;
1fff9a3c:	6835      	ldr	r5, [r6, #0]
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
1fff9a3e:	d1b4      	bne.n	1fff99aa <sys_clock_set_timeout+0x26>
1fff9a40:	f240 3045 	movw	r0, #837	; 0x345
1fff9a44:	e7b7      	b.n	1fff99b6 <sys_clock_set_timeout+0x32>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
1fff9a46:	f04f 0800 	mov.w	r8, #0
1fff9a4a:	e7b6      	b.n	1fff99ba <sys_clock_set_timeout+0x36>
1fff9a4c:	f240 43e2 	movw	r3, #1250	; 0x4e2
1fff9a50:	e7df      	b.n	1fff9a12 <sys_clock_set_timeout+0x8e>
1fff9a52:	bf00      	nop
1fff9a54:	20000584 	.word	0x20000584
1fff9a58:	20000580 	.word	0x20000580
1fff9a5c:	20000578 	.word	0x20000578
1fff9a60:	2000057c 	.word	0x2000057c
1fff9a64:	00ff6ea0 	.word	0x00ff6ea0

1fff9a68 <sys_clock_elapsed>:
{
1fff9a68:	b510      	push	{r4, lr}
	__asm__ volatile(
1fff9a6a:	f04f 0310 	mov.w	r3, #16
1fff9a6e:	f3ef 8411 	mrs	r4, BASEPRI
1fff9a72:	f383 8812 	msr	BASEPRI_MAX, r3
1fff9a76:	f3bf 8f6f 	isb	sy
	uint32_t cyc = elapsed() + cycle_count - announced_cycles;
1fff9a7a:	f7ff ff29 	bl	1fff98d0 <elapsed>
1fff9a7e:	4b07      	ldr	r3, [pc, #28]	; (1fff9a9c <sys_clock_elapsed+0x34>)
1fff9a80:	4a07      	ldr	r2, [pc, #28]	; (1fff9aa0 <sys_clock_elapsed+0x38>)
1fff9a82:	681b      	ldr	r3, [r3, #0]
1fff9a84:	6812      	ldr	r2, [r2, #0]
1fff9a86:	1a9b      	subs	r3, r3, r2
1fff9a88:	4403      	add	r3, r0
	__asm__ volatile(
1fff9a8a:	f384 8811 	msr	BASEPRI, r4
1fff9a8e:	f3bf 8f6f 	isb	sy
}
1fff9a92:	f644 6020 	movw	r0, #20000	; 0x4e20
1fff9a96:	fbb3 f0f0 	udiv	r0, r3, r0
1fff9a9a:	bd10      	pop	{r4, pc}
1fff9a9c:	20000580 	.word	0x20000580
1fff9aa0:	2000057c 	.word	0x2000057c

1fff9aa4 <CCM_UpdateRoot>:
 * Function Name : CCM_UpdateRoot
 * Description   : Update clock root in one step, for dynamical clock switching
 *
 *END**************************************************************************/
void CCM_UpdateRoot(CCM_Type * base, uint32_t ccmRoot, uint32_t mux, uint32_t pre, uint32_t post)
{
1fff9aa4:	b510      	push	{r4, lr}
    assert (pre < 8);
    assert (post < 64);

    CCM_REG(ccmRoot) = (CCM_REG(ccmRoot) &
                        (~(CCM_TARGET_ROOT_MUX_MASK | CCM_TARGET_ROOT_PRE_PODF_MASK | CCM_TARGET_ROOT_POST_PODF_MASK))) |
                       CCM_TARGET_ROOT_MUX(mux) | CCM_TARGET_ROOT_PRE_PODF(pre) | CCM_TARGET_ROOT_POST_PODF(post);
1fff9aa6:	9802      	ldr	r0, [sp, #8]
    CCM_REG(ccmRoot) = (CCM_REG(ccmRoot) &
1fff9aa8:	680c      	ldr	r4, [r1, #0]
                       CCM_TARGET_ROOT_MUX(mux) | CCM_TARGET_ROOT_PRE_PODF(pre) | CCM_TARGET_ROOT_POST_PODF(post);
1fff9aaa:	041b      	lsls	r3, r3, #16
1fff9aac:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
1fff9ab0:	f000 003f 	and.w	r0, r0, #63	; 0x3f
1fff9ab4:	0612      	lsls	r2, r2, #24
1fff9ab6:	f002 62e0 	and.w	r2, r2, #117440512	; 0x7000000
1fff9aba:	4303      	orrs	r3, r0
1fff9abc:	4313      	orrs	r3, r2
    CCM_REG(ccmRoot) = (CCM_REG(ccmRoot) &
1fff9abe:	4a02      	ldr	r2, [pc, #8]	; (1fff9ac8 <CCM_UpdateRoot+0x24>)
1fff9ac0:	4022      	ands	r2, r4
                       CCM_TARGET_ROOT_MUX(mux) | CCM_TARGET_ROOT_PRE_PODF(pre) | CCM_TARGET_ROOT_POST_PODF(post);
1fff9ac2:	4313      	orrs	r3, r2
    CCM_REG(ccmRoot) = (CCM_REG(ccmRoot) &
1fff9ac4:	600b      	str	r3, [r1, #0]
}
1fff9ac6:	bd10      	pop	{r4, pc}
1fff9ac8:	f8f8ffc0 	.word	0xf8f8ffc0

1fff9acc <CCM_ANALOG_GetSysPllFreq>:
 *         - true: The PLL is bypassed.
 *         - false: The PLL is not bypassed.
 */
static inline bool CCM_ANALOG_IsPllBypassed(CCM_ANALOG_Type * base, uint32_t pllControl)
{
    return (bool)(CCM_ANALOG_TUPLE_REG(base, pllControl) & CCM_ANALOG_PLL_ARM_BYPASS_MASK);
1fff9acc:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
 * Description   : Get system PLL frequency
 *
 *END**************************************************************************/
uint32_t CCM_ANALOG_GetSysPllFreq(CCM_ANALOG_Type * base)
{
    if (CCM_ANALOG_IsPllBypassed(base, ccmAnalogPll480Control))
1fff9ad0:	03db      	lsls	r3, r3, #15
1fff9ad2:	d409      	bmi.n	1fff9ae8 <CCM_ANALOG_GetSysPllFreq+0x1c>
        return 24000000ul;

    if (CCM_ANALOG_PLL_480 & CCM_ANALOG_PLL_480_DIV_SELECT_MASK)
1fff9ad4:	4b05      	ldr	r3, [pc, #20]	; (1fff9aec <CCM_ANALOG_GetSysPllFreq+0x20>)
        return 528000000ul;
1fff9ad6:	4806      	ldr	r0, [pc, #24]	; (1fff9af0 <CCM_ANALOG_GetSysPllFreq+0x24>)
    if (CCM_ANALOG_PLL_480 & CCM_ANALOG_PLL_480_DIV_SELECT_MASK)
1fff9ad8:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
        return 528000000ul;
1fff9adc:	f013 0f01 	tst.w	r3, #1
1fff9ae0:	4b04      	ldr	r3, [pc, #16]	; (1fff9af4 <CCM_ANALOG_GetSysPllFreq+0x28>)
1fff9ae2:	bf18      	it	ne
1fff9ae4:	4618      	movne	r0, r3
1fff9ae6:	4770      	bx	lr
        return 24000000ul;
1fff9ae8:	4803      	ldr	r0, [pc, #12]	; (1fff9af8 <CCM_ANALOG_GetSysPllFreq+0x2c>)
    else
        return 480000000ul;
}
1fff9aea:	4770      	bx	lr
1fff9aec:	30360000 	.word	0x30360000
1fff9af0:	1c9c3800 	.word	0x1c9c3800
1fff9af4:	1f78a400 	.word	0x1f78a400
1fff9af8:	016e3600 	.word	0x016e3600

1fff9afc <UART_SetBaudRate>:
    uint32_t refFreqDiv;
    uint32_t divider = 1;

    /* get the approximately maximum divisor */
    numerator = clockRate;
    denominator = baudRate << 4;
1fff9afc:	0113      	lsls	r3, r2, #4
{
1fff9afe:	b5f0      	push	{r4, r5, r6, r7, lr}
    numerator = clockRate;
1fff9b00:	460a      	mov	r2, r1
    denominator = baudRate << 4;
1fff9b02:	461c      	mov	r4, r3
    divisor = 1;
1fff9b04:	2501      	movs	r5, #1

    while (denominator != 0)
1fff9b06:	2c00      	cmp	r4, #0
1fff9b08:	d147      	bne.n	1fff9b9a <UART_SetBaudRate+0x9e>
        divisor = denominator;
        denominator = numerator % denominator;
        numerator = divisor;
    }

    numerator = clockRate / divisor;
1fff9b0a:	fbb1 f4f5 	udiv	r4, r1, r5
    denominator = (baudRate << 4) / divisor;
1fff9b0e:	fbb3 f3f5 	udiv	r3, r3, r5

    /* numerator ranges from 1 ~ 7 * 64k */
    /* denominator ranges from 1 ~ 64k */
    if ((numerator > (UART_UBIR_INC_MASK * 7)) ||
1fff9b12:	4f2f      	ldr	r7, [pc, #188]	; (1fff9bd0 <UART_SetBaudRate+0xd4>)
1fff9b14:	42bc      	cmp	r4, r7
1fff9b16:	f103 35ff 	add.w	r5, r3, #4294967295	; 0xffffffff
1fff9b1a:	f104 36ff 	add.w	r6, r4, #4294967295	; 0xffffffff
1fff9b1e:	d944      	bls.n	1fff9baa <UART_SetBaudRate+0xae>
        (denominator > UART_UBIR_INC_MASK))
    {
        uint32_t m = (numerator - 1) / (UART_UBIR_INC_MASK * 7) + 1;
1fff9b20:	fbb6 f6f7 	udiv	r6, r6, r7
        uint32_t n = (denominator - 1) / UART_UBIR_INC_MASK + 1;
1fff9b24:	f64f 72ff 	movw	r2, #65535	; 0xffff
        uint32_t m = (numerator - 1) / (UART_UBIR_INC_MASK * 7) + 1;
1fff9b28:	3601      	adds	r6, #1
        uint32_t n = (denominator - 1) / UART_UBIR_INC_MASK + 1;
1fff9b2a:	fbb5 f5f2 	udiv	r5, r5, r2
1fff9b2e:	1c6a      	adds	r2, r5, #1
        uint32_t max = m > n ? m : n;
1fff9b30:	42b2      	cmp	r2, r6
1fff9b32:	bf38      	it	cc
1fff9b34:	4632      	movcc	r2, r6
        numerator /= max;
1fff9b36:	fbb4 f4f2 	udiv	r4, r4, r2
        denominator /= max;
        if (0 == numerator)
            numerator = 1;
        if (0 == denominator)
1fff9b3a:	4293      	cmp	r3, r2
            denominator = 1;
1fff9b3c:	bf34      	ite	cc
1fff9b3e:	2301      	movcc	r3, #1
        denominator /= max;
1fff9b40:	fbb3 f3f2 	udivcs	r3, r3, r2
    }
    divider = (numerator - 1) / UART_UBIR_INC_MASK + 1;
1fff9b44:	f64f 75ff 	movw	r5, #65535	; 0xffff
1fff9b48:	1e62      	subs	r2, r4, #1
1fff9b4a:	fbb2 f2f5 	udiv	r2, r2, r5
1fff9b4e:	1c55      	adds	r5, r2, #1

    switch (divider)
1fff9b50:	3a01      	subs	r2, #1
1fff9b52:	2a05      	cmp	r2, #5
1fff9b54:	bf9c      	itt	ls
1fff9b56:	4e1f      	ldrls	r6, [pc, #124]	; (1fff9bd4 <UART_SetBaudRate+0xd8>)
1fff9b58:	5cb6      	ldrbls	r6, [r6, r2]
            break;
        default:
        refFreqDiv = 0x05;
    }

    UART_UFCR_REG(base) &= ~UART_UFCR_RFDIV_MASK;
1fff9b5a:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
1fff9b5e:	f422 7260 	bic.w	r2, r2, #896	; 0x380
1fff9b62:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
    UART_UFCR_REG(base) |= UART_UFCR_RFDIV(refFreqDiv);
1fff9b66:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
    divider = (numerator - 1) / UART_UBIR_INC_MASK + 1;
1fff9b6a:	bf88      	it	hi
1fff9b6c:	2605      	movhi	r6, #5
    UART_UFCR_REG(base) |= UART_UFCR_RFDIV(refFreqDiv);
1fff9b6e:	ea42 12c6 	orr.w	r2, r2, r6, lsl #7
1fff9b72:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
    UART_UBIR_REG(base) = UART_UBIR_INC(denominator - 1);
1fff9b76:	1e5a      	subs	r2, r3, #1
    UART_UBMR_REG(base) = UART_UBMR_MOD(numerator / divider - 1);
1fff9b78:	fbb4 f3f5 	udiv	r3, r4, r5
1fff9b7c:	3b01      	subs	r3, #1
1fff9b7e:	b29b      	uxth	r3, r3
    UART_UBIR_REG(base) = UART_UBIR_INC(denominator - 1);
1fff9b80:	b292      	uxth	r2, r2
1fff9b82:	f8c0 20a4 	str.w	r2, [r0, #164]	; 0xa4
    UART_UBMR_REG(base) = UART_UBMR_MOD(numerator / divider - 1);
1fff9b86:	f8c0 30a8 	str.w	r3, [r0, #168]	; 0xa8
    UART_ONEMS_REG(base) = UART_ONEMS_ONEMS(clockRate/(1000 * divider));
1fff9b8a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
1fff9b8e:	435d      	muls	r5, r3
1fff9b90:	fbb1 f1f5 	udiv	r1, r1, r5
1fff9b94:	f8c0 10b0 	str.w	r1, [r0, #176]	; 0xb0
}
1fff9b98:	bdf0      	pop	{r4, r5, r6, r7, pc}
        denominator = numerator % denominator;
1fff9b9a:	fbb2 f6f4 	udiv	r6, r2, r4
1fff9b9e:	fb04 2616 	mls	r6, r4, r6, r2
1fff9ba2:	4625      	mov	r5, r4
1fff9ba4:	4622      	mov	r2, r4
1fff9ba6:	4634      	mov	r4, r6
1fff9ba8:	e7ad      	b.n	1fff9b06 <UART_SetBaudRate+0xa>
    if ((numerator > (UART_UBIR_INC_MASK * 7)) ||
1fff9baa:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
1fff9bae:	d3c9      	bcc.n	1fff9b44 <UART_SetBaudRate+0x48>
        uint32_t m = (numerator - 1) / (UART_UBIR_INC_MASK * 7) + 1;
1fff9bb0:	fbb6 f6f7 	udiv	r6, r6, r7
1fff9bb4:	1c72      	adds	r2, r6, #1
        uint32_t n = (denominator - 1) / UART_UBIR_INC_MASK + 1;
1fff9bb6:	f64f 76ff 	movw	r6, #65535	; 0xffff
1fff9bba:	fbb5 f5f6 	udiv	r5, r5, r6
1fff9bbe:	3501      	adds	r5, #1
        uint32_t max = m > n ? m : n;
1fff9bc0:	42aa      	cmp	r2, r5
1fff9bc2:	bf38      	it	cc
1fff9bc4:	462a      	movcc	r2, r5
        if (0 == numerator)
1fff9bc6:	4294      	cmp	r4, r2
1fff9bc8:	d2b5      	bcs.n	1fff9b36 <UART_SetBaudRate+0x3a>
            numerator = 1;
1fff9bca:	2401      	movs	r4, #1
1fff9bcc:	e7b5      	b.n	1fff9b3a <UART_SetBaudRate+0x3e>
1fff9bce:	bf00      	nop
1fff9bd0:	0006fff9 	.word	0x0006fff9
1fff9bd4:	1fffd4dd 	.word	0x1fffd4dd

1fff9bd8 <get_uart_clock_freq>:
{
	uint32_t root;
	uint32_t hz;
	uint32_t pre, post;

	switch ((uint32_t)base) {
1fff9bd8:	4b3b      	ldr	r3, [pc, #236]	; (1fff9cc8 <get_uart_clock_freq+0xf0>)
1fff9bda:	4298      	cmp	r0, r3
{
1fff9bdc:	b513      	push	{r0, r1, r4, lr}
	switch ((uint32_t)base) {
1fff9bde:	d046      	beq.n	1fff9c6e <get_uart_clock_freq+0x96>
1fff9be0:	d80e      	bhi.n	1fff9c00 <get_uart_clock_freq+0x28>
1fff9be2:	f5a3 13f0 	sub.w	r3, r3, #1966080	; 0x1e0000
1fff9be6:	4298      	cmp	r0, r3
1fff9be8:	d038      	beq.n	1fff9c5c <get_uart_clock_freq+0x84>
1fff9bea:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
1fff9bee:	4298      	cmp	r0, r3
1fff9bf0:	d02d      	beq.n	1fff9c4e <get_uart_clock_freq+0x76>
1fff9bf2:	f5a3 3340 	sub.w	r3, r3, #196608	; 0x30000
1fff9bf6:	4298      	cmp	r0, r3
1fff9bf8:	d016      	beq.n	1fff9c28 <get_uart_clock_freq+0x50>
	case UART7_BASE:
		root = CCM_GetRootMux(CCM, ccmRootUart7);
		CCM_GetRootDivider(CCM, ccmRootUart7, &pre, &post);
		break;
	default:
		return 0;
1fff9bfa:	2000      	movs	r0, #0
	default:
		return 0;
	}

	return hz / (pre + 1) / (post + 1);
}
1fff9bfc:	b002      	add	sp, #8
1fff9bfe:	bd10      	pop	{r4, pc}
	switch ((uint32_t)base) {
1fff9c00:	4b32      	ldr	r3, [pc, #200]	; (1fff9ccc <get_uart_clock_freq+0xf4>)
1fff9c02:	4298      	cmp	r0, r3
1fff9c04:	d03c      	beq.n	1fff9c80 <get_uart_clock_freq+0xa8>
1fff9c06:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
1fff9c0a:	4298      	cmp	r0, r3
1fff9c0c:	d041      	beq.n	1fff9c92 <get_uart_clock_freq+0xba>
1fff9c0e:	f5a3 3300 	sub.w	r3, r3, #131072	; 0x20000
1fff9c12:	4298      	cmp	r0, r3
1fff9c14:	d1f1      	bne.n	1fff9bfa <get_uart_clock_freq+0x22>
    return (CCM_REG(ccmRoot) & CCM_TARGET_ROOT_MUX_MASK) >> CCM_TARGET_ROOT_MUX_SHIFT;
1fff9c16:	4b2e      	ldr	r3, [pc, #184]	; (1fff9cd0 <get_uart_clock_freq+0xf8>)
		CCM_GetRootDivider(CCM, ccmRootUart5, &pre, &post);
1fff9c18:	492e      	ldr	r1, [pc, #184]	; (1fff9cd4 <get_uart_clock_freq+0xfc>)
1fff9c1a:	f8d3 4180 	ldr.w	r4, [r3, #384]	; 0x180
1fff9c1e:	466a      	mov	r2, sp
1fff9c20:	f3c4 6402 	ubfx	r4, r4, #24, #3
1fff9c24:	ab01      	add	r3, sp, #4
1fff9c26:	e007      	b.n	1fff9c38 <get_uart_clock_freq+0x60>
1fff9c28:	4b2b      	ldr	r3, [pc, #172]	; (1fff9cd8 <get_uart_clock_freq+0x100>)
		CCM_GetRootDivider(CCM, ccmRootUart1, &pre, &post);
1fff9c2a:	492c      	ldr	r1, [pc, #176]	; (1fff9cdc <get_uart_clock_freq+0x104>)
1fff9c2c:	f8d3 4f80 	ldr.w	r4, [r3, #3968]	; 0xf80
1fff9c30:	466a      	mov	r2, sp
1fff9c32:	f3c4 6402 	ubfx	r4, r4, #24, #3
1fff9c36:	ab01      	add	r3, sp, #4
		CCM_GetRootDivider(CCM, ccmRootUart7, &pre, &post);
1fff9c38:	4829      	ldr	r0, [pc, #164]	; (1fff9ce0 <get_uart_clock_freq+0x108>)
1fff9c3a:	f001 ffbd 	bl	1fffbbb8 <CCM_GetRootDivider>
	switch (root) {
1fff9c3e:	2c01      	cmp	r4, #1
1fff9c40:	d030      	beq.n	1fff9ca4 <get_uart_clock_freq+0xcc>
1fff9c42:	2c04      	cmp	r4, #4
1fff9c44:	d03b      	beq.n	1fff9cbe <get_uart_clock_freq+0xe6>
1fff9c46:	2c00      	cmp	r4, #0
1fff9c48:	d1d7      	bne.n	1fff9bfa <get_uart_clock_freq+0x22>
1fff9c4a:	4826      	ldr	r0, [pc, #152]	; (1fff9ce4 <get_uart_clock_freq+0x10c>)
1fff9c4c:	e02e      	b.n	1fff9cac <get_uart_clock_freq+0xd4>
1fff9c4e:	4920      	ldr	r1, [pc, #128]	; (1fff9cd0 <get_uart_clock_freq+0xf8>)
1fff9c50:	680c      	ldr	r4, [r1, #0]
		CCM_GetRootDivider(CCM, ccmRootUart2, &pre, &post);
1fff9c52:	ab01      	add	r3, sp, #4
1fff9c54:	f3c4 6402 	ubfx	r4, r4, #24, #3
1fff9c58:	466a      	mov	r2, sp
1fff9c5a:	e7ed      	b.n	1fff9c38 <get_uart_clock_freq+0x60>
1fff9c5c:	4b1c      	ldr	r3, [pc, #112]	; (1fff9cd0 <get_uart_clock_freq+0xf8>)
		CCM_GetRootDivider(CCM, ccmRootUart3, &pre, &post);
1fff9c5e:	4922      	ldr	r1, [pc, #136]	; (1fff9ce8 <get_uart_clock_freq+0x110>)
1fff9c60:	f8d3 4080 	ldr.w	r4, [r3, #128]	; 0x80
1fff9c64:	466a      	mov	r2, sp
1fff9c66:	f3c4 6402 	ubfx	r4, r4, #24, #3
1fff9c6a:	ab01      	add	r3, sp, #4
1fff9c6c:	e7e4      	b.n	1fff9c38 <get_uart_clock_freq+0x60>
1fff9c6e:	4b18      	ldr	r3, [pc, #96]	; (1fff9cd0 <get_uart_clock_freq+0xf8>)
		CCM_GetRootDivider(CCM, ccmRootUart4, &pre, &post);
1fff9c70:	491e      	ldr	r1, [pc, #120]	; (1fff9cec <get_uart_clock_freq+0x114>)
1fff9c72:	f8d3 4100 	ldr.w	r4, [r3, #256]	; 0x100
1fff9c76:	466a      	mov	r2, sp
1fff9c78:	f3c4 6402 	ubfx	r4, r4, #24, #3
1fff9c7c:	ab01      	add	r3, sp, #4
1fff9c7e:	e7db      	b.n	1fff9c38 <get_uart_clock_freq+0x60>
1fff9c80:	4b13      	ldr	r3, [pc, #76]	; (1fff9cd0 <get_uart_clock_freq+0xf8>)
		CCM_GetRootDivider(CCM, ccmRootUart6, &pre, &post);
1fff9c82:	491b      	ldr	r1, [pc, #108]	; (1fff9cf0 <get_uart_clock_freq+0x118>)
1fff9c84:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
1fff9c88:	466a      	mov	r2, sp
1fff9c8a:	f3c4 6402 	ubfx	r4, r4, #24, #3
1fff9c8e:	ab01      	add	r3, sp, #4
1fff9c90:	e7d2      	b.n	1fff9c38 <get_uart_clock_freq+0x60>
1fff9c92:	4b0f      	ldr	r3, [pc, #60]	; (1fff9cd0 <get_uart_clock_freq+0xf8>)
		CCM_GetRootDivider(CCM, ccmRootUart7, &pre, &post);
1fff9c94:	4917      	ldr	r1, [pc, #92]	; (1fff9cf4 <get_uart_clock_freq+0x11c>)
1fff9c96:	f8d3 4280 	ldr.w	r4, [r3, #640]	; 0x280
1fff9c9a:	466a      	mov	r2, sp
1fff9c9c:	f3c4 6402 	ubfx	r4, r4, #24, #3
1fff9ca0:	ab01      	add	r3, sp, #4
1fff9ca2:	e7c9      	b.n	1fff9c38 <get_uart_clock_freq+0x60>
		hz = CCM_ANALOG_GetSysPllFreq(CCM_ANALOG) >> 1;
1fff9ca4:	4814      	ldr	r0, [pc, #80]	; (1fff9cf8 <get_uart_clock_freq+0x120>)
1fff9ca6:	f7ff ff11 	bl	1fff9acc <CCM_ANALOG_GetSysPllFreq>
1fff9caa:	0840      	lsrs	r0, r0, #1
	return hz / (pre + 1) / (post + 1);
1fff9cac:	9b00      	ldr	r3, [sp, #0]
1fff9cae:	3301      	adds	r3, #1
1fff9cb0:	fbb0 f0f3 	udiv	r0, r0, r3
1fff9cb4:	9b01      	ldr	r3, [sp, #4]
1fff9cb6:	3301      	adds	r3, #1
1fff9cb8:	fbb0 f0f3 	udiv	r0, r0, r3
1fff9cbc:	e79e      	b.n	1fff9bfc <get_uart_clock_freq+0x24>
		hz = CCM_ANALOG_GetSysPllFreq(CCM_ANALOG);
1fff9cbe:	480e      	ldr	r0, [pc, #56]	; (1fff9cf8 <get_uart_clock_freq+0x120>)
1fff9cc0:	f7ff ff04 	bl	1fff9acc <CCM_ANALOG_GetSysPllFreq>
		break;
1fff9cc4:	e7f2      	b.n	1fff9cac <get_uart_clock_freq+0xd4>
1fff9cc6:	bf00      	nop
1fff9cc8:	30a60000 	.word	0x30a60000
1fff9ccc:	30a80000 	.word	0x30a80000
1fff9cd0:	3038b000 	.word	0x3038b000
1fff9cd4:	3038b180 	.word	0x3038b180
1fff9cd8:	3038a000 	.word	0x3038a000
1fff9cdc:	3038af80 	.word	0x3038af80
1fff9ce0:	30380000 	.word	0x30380000
1fff9ce4:	016e3600 	.word	0x016e3600
1fff9ce8:	3038b080 	.word	0x3038b080
1fff9cec:	3038b100 	.word	0x3038b100
1fff9cf0:	3038b200 	.word	0x3038b200
1fff9cf4:	3038b280 	.word	0x3038b280
1fff9cf8:	30360000 	.word	0x30360000

1fff9cfc <metal_generic_dev_open>:
	return 0;
}

int metal_generic_dev_open(struct metal_bus *bus, const char *dev_name,
			   struct metal_device **device)
{
1fff9cfc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct metal_list *node;
	struct metal_device *dev;

	(void)bus;

	metal_list_for_each(&_metal.common.generic_device_list, node) {
1fff9d00:	4d0d      	ldr	r5, [pc, #52]	; (1fff9d38 <metal_generic_dev_open+0x3c>)
1fff9d02:	f855 4f18 	ldr.w	r4, [r5, #24]!
{
1fff9d06:	460e      	mov	r6, r1
1fff9d08:	4617      	mov	r7, r2
	metal_list_for_each(&_metal.common.generic_device_list, node) {
1fff9d0a:	42ac      	cmp	r4, r5
1fff9d0c:	d103      	bne.n	1fff9d16 <metal_generic_dev_open+0x1a>
			return metal_generic_dev_sys_open(dev);
		}
	}

	return -ENODEV;
}
1fff9d0e:	f06f 0012 	mvn.w	r0, #18
1fff9d12:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (strcmp(dev->name, dev_name) == 0) {
1fff9d16:	f854 0c7c 	ldr.w	r0, [r4, #-124]
1fff9d1a:	4631      	mov	r1, r6
		dev = metal_container_of(node, struct metal_device, node);
1fff9d1c:	f1a4 087c 	sub.w	r8, r4, #124	; 0x7c
		if (strcmp(dev->name, dev_name) == 0) {
1fff9d20:	f001 fc0d 	bl	1fffb53e <strcmp>
1fff9d24:	b930      	cbnz	r0, 1fff9d34 <metal_generic_dev_open+0x38>
			*device = dev;
1fff9d26:	f8c7 8000 	str.w	r8, [r7]
			return metal_generic_dev_sys_open(dev);
1fff9d2a:	4640      	mov	r0, r8
}
1fff9d2c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			return metal_generic_dev_sys_open(dev);
1fff9d30:	f002 b8ba 	b.w	1fffbea8 <metal_generic_dev_sys_open>
	metal_list_for_each(&_metal.common.generic_device_list, node) {
1fff9d34:	6824      	ldr	r4, [r4, #0]
1fff9d36:	e7e8      	b.n	1fff9d0a <metal_generic_dev_open+0xe>
1fff9d38:	20000588 	.word	0x20000588

1fff9d3c <metal_bus_unregister>:
{
1fff9d3c:	b510      	push	{r4, lr}
	return list->next == list;
}

static inline void metal_list_del(struct metal_list *node)
{
	node->next->prev = node->prev;
1fff9d3e:	e9d0 1209 	ldrd	r1, r2, [r0, #36]	; 0x24
1fff9d42:	604a      	str	r2, [r1, #4]
	node->prev->next = node->next;
1fff9d44:	6a41      	ldr	r1, [r0, #36]	; 0x24
1fff9d46:	6011      	str	r1, [r2, #0]
	metal_list_del(&bus->node);
1fff9d48:	f100 0324 	add.w	r3, r0, #36	; 0x24
	node->prev = node;
	node->next = node;
1fff9d4c:	e9c0 3309 	strd	r3, r3, [r0, #36]	; 0x24
	if (bus->ops.bus_close)
1fff9d50:	6843      	ldr	r3, [r0, #4]
{
1fff9d52:	4604      	mov	r4, r0
	if (bus->ops.bus_close)
1fff9d54:	b103      	cbz	r3, 1fff9d58 <metal_bus_unregister+0x1c>
		bus->ops.bus_close(bus);
1fff9d56:	4798      	blx	r3
	metal_log(METAL_LOG_DEBUG, "unregistered %s bus\n", bus->name);
1fff9d58:	4b05      	ldr	r3, [pc, #20]	; (1fff9d70 <metal_bus_unregister+0x34>)
1fff9d5a:	781a      	ldrb	r2, [r3, #0]
1fff9d5c:	2a06      	cmp	r2, #6
1fff9d5e:	d905      	bls.n	1fff9d6c <metal_bus_unregister+0x30>
1fff9d60:	685b      	ldr	r3, [r3, #4]
1fff9d62:	b11b      	cbz	r3, 1fff9d6c <metal_bus_unregister+0x30>
1fff9d64:	6822      	ldr	r2, [r4, #0]
1fff9d66:	4903      	ldr	r1, [pc, #12]	; (1fff9d74 <metal_bus_unregister+0x38>)
1fff9d68:	2007      	movs	r0, #7
1fff9d6a:	4798      	blx	r3
}
1fff9d6c:	2000      	movs	r0, #0
1fff9d6e:	bd10      	pop	{r4, pc}
1fff9d70:	20000588 	.word	0x20000588
1fff9d74:	1fffd4e3 	.word	0x1fffd4e3

1fff9d78 <metal_bus_find>:
{
1fff9d78:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	metal_list_for_each(&_metal.common.bus_list, node) {
1fff9d7c:	4e0c      	ldr	r6, [pc, #48]	; (1fff9db0 <metal_bus_find+0x38>)
1fff9d7e:	f856 4f08 	ldr.w	r4, [r6, #8]!
{
1fff9d82:	4607      	mov	r7, r0
1fff9d84:	460d      	mov	r5, r1
	metal_list_for_each(&_metal.common.bus_list, node) {
1fff9d86:	42b4      	cmp	r4, r6
1fff9d88:	d102      	bne.n	1fff9d90 <metal_bus_find+0x18>
	return -ENOENT;
1fff9d8a:	f06f 0001 	mvn.w	r0, #1
1fff9d8e:	e00a      	b.n	1fff9da6 <metal_bus_find+0x2e>
		if (strcmp(bus->name, name) == 0 && result) {
1fff9d90:	f854 0c24 	ldr.w	r0, [r4, #-36]
1fff9d94:	4639      	mov	r1, r7
		bus = metal_container_of(node, struct metal_bus, node);
1fff9d96:	f1a4 0824 	sub.w	r8, r4, #36	; 0x24
		if (strcmp(bus->name, name) == 0 && result) {
1fff9d9a:	f001 fbd0 	bl	1fffb53e <strcmp>
1fff9d9e:	b920      	cbnz	r0, 1fff9daa <metal_bus_find+0x32>
1fff9da0:	b11d      	cbz	r5, 1fff9daa <metal_bus_find+0x32>
			*result = bus;
1fff9da2:	f8c5 8000 	str.w	r8, [r5]
}
1fff9da6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	metal_list_for_each(&_metal.common.bus_list, node) {
1fff9daa:	6824      	ldr	r4, [r4, #0]
1fff9dac:	e7eb      	b.n	1fff9d86 <metal_bus_find+0xe>
1fff9dae:	bf00      	nop
1fff9db0:	20000588 	.word	0x20000588

1fff9db4 <metal_bus_register>:
{
1fff9db4:	b510      	push	{r4, lr}
	if (!bus || !bus->name || !strlen(bus->name))
1fff9db6:	4604      	mov	r4, r0
1fff9db8:	b910      	cbnz	r0, 1fff9dc0 <metal_bus_register+0xc>
		return -EINVAL;
1fff9dba:	f06f 0015 	mvn.w	r0, #21
}
1fff9dbe:	bd10      	pop	{r4, pc}
	if (!bus || !bus->name || !strlen(bus->name))
1fff9dc0:	6800      	ldr	r0, [r0, #0]
1fff9dc2:	2800      	cmp	r0, #0
1fff9dc4:	d0f9      	beq.n	1fff9dba <metal_bus_register+0x6>
1fff9dc6:	f001 fbaa 	bl	1fffb51e <strlen>
1fff9dca:	2800      	cmp	r0, #0
1fff9dcc:	d0f5      	beq.n	1fff9dba <metal_bus_register+0x6>
	if (metal_bus_find(bus->name, NULL) == 0)
1fff9dce:	6820      	ldr	r0, [r4, #0]
1fff9dd0:	2100      	movs	r1, #0
1fff9dd2:	f7ff ffd1 	bl	1fff9d78 <metal_bus_find>
1fff9dd6:	b1c8      	cbz	r0, 1fff9e0c <metal_bus_register+0x58>
	metal_list_init(&bus->devices);
1fff9dd8:	f104 031c 	add.w	r3, r4, #28
	list->next = list;
1fff9ddc:	e9c4 3307 	strd	r3, r3, [r4, #28]
	new_node->prev = node->prev;
1fff9de0:	4b0c      	ldr	r3, [pc, #48]	; (1fff9e14 <metal_bus_register+0x60>)
1fff9de2:	68d9      	ldr	r1, [r3, #12]
1fff9de4:	62a1      	str	r1, [r4, #40]	; 0x28
	metal_list_add_tail(&_metal.common.bus_list, &bus->node);
1fff9de6:	f104 0224 	add.w	r2, r4, #36	; 0x24
	new_node->next = node;
1fff9dea:	f103 0008 	add.w	r0, r3, #8
	new_node->next->prev = new_node;
1fff9dee:	60da      	str	r2, [r3, #12]
	new_node->next = node;
1fff9df0:	6260      	str	r0, [r4, #36]	; 0x24
	new_node->prev->next = new_node;
1fff9df2:	600a      	str	r2, [r1, #0]
	metal_log(METAL_LOG_DEBUG, "registered %s bus\n", bus->name);
1fff9df4:	781a      	ldrb	r2, [r3, #0]
1fff9df6:	2a06      	cmp	r2, #6
1fff9df8:	d901      	bls.n	1fff9dfe <metal_bus_register+0x4a>
1fff9dfa:	685b      	ldr	r3, [r3, #4]
1fff9dfc:	b90b      	cbnz	r3, 1fff9e02 <metal_bus_register+0x4e>
	return 0;
1fff9dfe:	2000      	movs	r0, #0
1fff9e00:	e7dd      	b.n	1fff9dbe <metal_bus_register+0xa>
	metal_log(METAL_LOG_DEBUG, "registered %s bus\n", bus->name);
1fff9e02:	6822      	ldr	r2, [r4, #0]
1fff9e04:	4904      	ldr	r1, [pc, #16]	; (1fff9e18 <metal_bus_register+0x64>)
1fff9e06:	2007      	movs	r0, #7
1fff9e08:	4798      	blx	r3
1fff9e0a:	e7f8      	b.n	1fff9dfe <metal_bus_register+0x4a>
		return -EEXIST;
1fff9e0c:	f06f 0010 	mvn.w	r0, #16
1fff9e10:	e7d5      	b.n	1fff9dbe <metal_bus_register+0xa>
1fff9e12:	bf00      	nop
1fff9e14:	20000588 	.word	0x20000588
1fff9e18:	1fffd4e5 	.word	0x1fffd4e5

1fff9e1c <metal_register_generic_device>:
{
1fff9e1c:	b510      	push	{r4, lr}
1fff9e1e:	4604      	mov	r4, r0
	if (!device->name || !strlen(device->name) ||
1fff9e20:	6800      	ldr	r0, [r0, #0]
1fff9e22:	b910      	cbnz	r0, 1fff9e2a <metal_register_generic_device+0xe>
		return -EINVAL;
1fff9e24:	f06f 0015 	mvn.w	r0, #21
}
1fff9e28:	bd10      	pop	{r4, pc}
	if (!device->name || !strlen(device->name) ||
1fff9e2a:	f001 fb78 	bl	1fffb51e <strlen>
1fff9e2e:	2800      	cmp	r0, #0
1fff9e30:	d0f8      	beq.n	1fff9e24 <metal_register_generic_device+0x8>
1fff9e32:	68a3      	ldr	r3, [r4, #8]
1fff9e34:	2b02      	cmp	r3, #2
1fff9e36:	d8f5      	bhi.n	1fff9e24 <metal_register_generic_device+0x8>
	device->bus = &metal_generic_bus;
1fff9e38:	4b07      	ldr	r3, [pc, #28]	; (1fff9e58 <metal_register_generic_device+0x3c>)
1fff9e3a:	6063      	str	r3, [r4, #4]
	new_node->prev = node->prev;
1fff9e3c:	4b07      	ldr	r3, [pc, #28]	; (1fff9e5c <metal_register_generic_device+0x40>)
1fff9e3e:	69da      	ldr	r2, [r3, #28]
1fff9e40:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
	metal_list_add_tail(&_metal.common.generic_device_list,
1fff9e44:	f104 017c 	add.w	r1, r4, #124	; 0x7c
	new_node->next = node;
1fff9e48:	f103 0018 	add.w	r0, r3, #24
1fff9e4c:	67e0      	str	r0, [r4, #124]	; 0x7c
	new_node->next->prev = new_node;
1fff9e4e:	61d9      	str	r1, [r3, #28]
	return 0;
1fff9e50:	2000      	movs	r0, #0
	new_node->prev->next = new_node;
1fff9e52:	6011      	str	r1, [r2, #0]
}
1fff9e54:	e7e8      	b.n	1fff9e28 <metal_register_generic_device+0xc>
1fff9e56:	bf00      	nop
1fff9e58:	200000a0 	.word	0x200000a0
1fff9e5c:	20000588 	.word	0x20000588

1fff9e60 <metal_init>:

#include <string.h>
#include <metal/sys.h>

int metal_init(const struct metal_init_params *params)
{
1fff9e60:	b538      	push	{r3, r4, r5, lr}
	int error = 0;

	memset(&_metal, 0, sizeof(_metal));
1fff9e62:	4c0e      	ldr	r4, [pc, #56]	; (1fff9e9c <metal_init+0x3c>)
{
1fff9e64:	4605      	mov	r5, r0
	memset(&_metal, 0, sizeof(_metal));
1fff9e66:	2220      	movs	r2, #32
1fff9e68:	4620      	mov	r0, r4
1fff9e6a:	2100      	movs	r1, #0
1fff9e6c:	f001 fb92 	bl	1fffb594 <memset>

	_metal.common.log_handler   = params->log_handler;
1fff9e70:	682b      	ldr	r3, [r5, #0]
1fff9e72:	6063      	str	r3, [r4, #4]
	_metal.common.log_level     = params->log_level;
1fff9e74:	4623      	mov	r3, r4
1fff9e76:	792a      	ldrb	r2, [r5, #4]
1fff9e78:	f803 2b08 	strb.w	r2, [r3], #8
	list->next = list;
1fff9e7c:	e9c4 3302 	strd	r3, r3, [r4, #8]
	list->prev = list;
1fff9e80:	f104 0310 	add.w	r3, r4, #16
	list->next = list;
1fff9e84:	e9c4 3304 	strd	r3, r3, [r4, #16]
	list->prev = list;
1fff9e88:	f104 0318 	add.w	r3, r4, #24
	list->next = list;
1fff9e8c:	e9c4 3306 	strd	r3, r3, [r4, #24]

	metal_list_init(&_metal.common.bus_list);
	metal_list_init(&_metal.common.generic_shmem_list);
	metal_list_init(&_metal.common.generic_device_list);

	error = metal_sys_init(params);
1fff9e90:	4628      	mov	r0, r5
	if (error)
		return error;

	return error;
}
1fff9e92:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	error = metal_sys_init(params);
1fff9e96:	f000 b80f 	b.w	1fff9eb8 <metal_sys_init>
1fff9e9a:	bf00      	nop
1fff9e9c:	20000588 	.word	0x20000588

1fff9ea0 <metal_finish>:

void metal_finish(void)
{
1fff9ea0:	b508      	push	{r3, lr}
	metal_sys_finish();
1fff9ea2:	f000 f811 	bl	1fff9ec8 <metal_sys_finish>
	memset(&_metal, 0, sizeof(_metal));
}
1fff9ea6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	memset(&_metal, 0, sizeof(_metal));
1fff9eaa:	4802      	ldr	r0, [pc, #8]	; (1fff9eb4 <metal_finish+0x14>)
1fff9eac:	2220      	movs	r2, #32
1fff9eae:	2100      	movs	r1, #0
1fff9eb0:	f001 bb70 	b.w	1fffb594 <memset>
1fff9eb4:	20000588 	.word	0x20000588

1fff9eb8 <metal_sys_init>:
#include <metal/utilities.h>

struct metal_state _metal;

int metal_sys_init(const struct metal_init_params *params)
{
1fff9eb8:	b508      	push	{r3, lr}
	metal_bus_register(&metal_generic_bus);
1fff9eba:	4802      	ldr	r0, [pc, #8]	; (1fff9ec4 <metal_sys_init+0xc>)
1fff9ebc:	f7ff ff7a 	bl	1fff9db4 <metal_bus_register>
	return 0;
}
1fff9ec0:	2000      	movs	r0, #0
1fff9ec2:	bd08      	pop	{r3, pc}
1fff9ec4:	200000a0 	.word	0x200000a0

1fff9ec8 <metal_sys_finish>:

void metal_sys_finish(void)
{
	metal_bus_unregister(&metal_generic_bus);
1fff9ec8:	4801      	ldr	r0, [pc, #4]	; (1fff9ed0 <metal_sys_finish+0x8>)
1fff9eca:	f7ff bf37 	b.w	1fff9d3c <metal_bus_unregister>
1fff9ece:	bf00      	nop
1fff9ed0:	200000a0 	.word	0x200000a0

1fff9ed4 <metal_zephyr_log_handler>:
	"metal: debug:     ",
};

void metal_zephyr_log_handler(enum metal_log_level level,
			      const char *format, ...)
{
1fff9ed4:	b40e      	push	{r1, r2, r3}
1fff9ed6:	b533      	push	{r0, r1, r4, r5, lr}
	va_list args;

	if (level <= METAL_LOG_EMERGENCY || level > METAL_LOG_DEBUG)
1fff9ed8:	1e43      	subs	r3, r0, #1
		level = METAL_LOG_EMERGENCY;
1fff9eda:	2b06      	cmp	r3, #6
{
1fff9edc:	ac05      	add	r4, sp, #20
		level = METAL_LOG_EMERGENCY;
1fff9ede:	bf88      	it	hi
1fff9ee0:	2000      	movhi	r0, #0
	printk("%s", level_strs[level]);
1fff9ee2:	4b09      	ldr	r3, [pc, #36]	; (1fff9f08 <metal_zephyr_log_handler+0x34>)
{
1fff9ee4:	f854 5b04 	ldr.w	r5, [r4], #4
	printk("%s", level_strs[level]);
1fff9ee8:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]
1fff9eec:	4807      	ldr	r0, [pc, #28]	; (1fff9f0c <metal_zephyr_log_handler+0x38>)
1fff9eee:	f001 f8b7 	bl	1fffb060 <printk>

	va_start(args, format);
	vprintk(format, args);
1fff9ef2:	4621      	mov	r1, r4
1fff9ef4:	4628      	mov	r0, r5
	va_start(args, format);
1fff9ef6:	9401      	str	r4, [sp, #4]
	vprintk(format, args);
1fff9ef8:	f7fe fd5c 	bl	1fff89b4 <vprintk>
	va_end(args);
}
1fff9efc:	b002      	add	sp, #8
1fff9efe:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
1fff9f02:	b003      	add	sp, #12
1fff9f04:	4770      	bx	lr
1fff9f06:	bf00      	nop
1fff9f08:	1fffd2c8 	.word	0x1fffd2c8
1fff9f0c:	1fffd4f8 	.word	0x1fffd4f8

1fff9f10 <virtio_create_virtqueues>:
}

int virtio_create_virtqueues(struct virtio_device *vdev, unsigned int flags,
			     unsigned int nvqs, const char *names[],
			     vq_callback callbacks[])
{
1fff9f10:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
1fff9f14:	461f      	mov	r7, r3
	unsigned int num_vrings, i;
	int ret;
	(void)flags;

	num_vrings = vdev->vrings_num;
	if (nvqs > num_vrings)
1fff9f16:	6a83      	ldr	r3, [r0, #40]	; 0x28
{
1fff9f18:	b085      	sub	sp, #20
	if (nvqs > num_vrings)
1fff9f1a:	4293      	cmp	r3, r2
{
1fff9f1c:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
1fff9f20:	4605      	mov	r5, r0
1fff9f22:	4616      	mov	r6, r2
	if (nvqs > num_vrings)
1fff9f24:	d31f      	bcc.n	1fff9f66 <virtio_create_virtqueues+0x56>
		return ERROR_VQUEUE_INVLD_PARAM;
	/* Initialize virtqueue for each vring */
	for (i = 0; i < nvqs; i++) {
1fff9f26:	2400      	movs	r4, #0
		vring_info = &vdev->vrings_info[i];
1fff9f28:	f04f 0918 	mov.w	r9, #24
	for (i = 0; i < nvqs; i++) {
1fff9f2c:	42b4      	cmp	r4, r6
1fff9f2e:	d103      	bne.n	1fff9f38 <virtio_create_virtqueues+0x28>
				       callbacks[i], vdev->func->notify,
				       vring_info->vq);
		if (ret)
			return ret;
	}
	return 0;
1fff9f30:	2000      	movs	r0, #0
}
1fff9f32:	b005      	add	sp, #20
1fff9f34:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		vring_info = &vdev->vrings_info[i];
1fff9f38:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
1fff9f3a:	fb09 f204 	mul.w	r2, r9, r4
1fff9f3e:	188b      	adds	r3, r1, r2
		ret = virtqueue_create(vdev, i, names[i], vring_alloc,
1fff9f40:	588a      	ldr	r2, [r1, r2]
1fff9f42:	9202      	str	r2, [sp, #8]
				       callbacks[i], vdev->func->notify,
1fff9f44:	6a2a      	ldr	r2, [r5, #32]
		ret = virtqueue_create(vdev, i, names[i], vring_alloc,
1fff9f46:	6a12      	ldr	r2, [r2, #32]
1fff9f48:	9201      	str	r2, [sp, #4]
1fff9f4a:	f858 2024 	ldr.w	r2, [r8, r4, lsl #2]
1fff9f4e:	9200      	str	r2, [sp, #0]
1fff9f50:	f857 2024 	ldr.w	r2, [r7, r4, lsl #2]
1fff9f54:	3304      	adds	r3, #4
1fff9f56:	b2a1      	uxth	r1, r4
1fff9f58:	4628      	mov	r0, r5
1fff9f5a:	f001 ffea 	bl	1fffbf32 <virtqueue_create>
		if (ret)
1fff9f5e:	2800      	cmp	r0, #0
1fff9f60:	d1e7      	bne.n	1fff9f32 <virtio_create_virtqueues+0x22>
	for (i = 0; i < nvqs; i++) {
1fff9f62:	3401      	adds	r4, #1
1fff9f64:	e7e2      	b.n	1fff9f2c <virtio_create_virtqueues+0x1c>
		return ERROR_VQUEUE_INVLD_PARAM;
1fff9f66:	4801      	ldr	r0, [pc, #4]	; (1fff9f6c <virtio_create_virtqueues+0x5c>)
1fff9f68:	e7e3      	b.n	1fff9f32 <virtio_create_virtqueues+0x22>
1fff9f6a:	bf00      	nop
1fff9f6c:	fffff440 	.word	0xfffff440

1fff9f70 <virtqueue_add_consumed_buffer>:
 *
 * @return                       - Function status
 */
int virtqueue_add_consumed_buffer(struct virtqueue *vq, uint16_t head_idx,
				  uint32_t len)
{
1fff9f70:	b530      	push	{r4, r5, lr}
	struct vring_used_elem *used_desc = NULL;
	uint16_t used_idx;

	if (head_idx >= vq->vq_nentries) {
1fff9f72:	8944      	ldrh	r4, [r0, #10]
1fff9f74:	428c      	cmp	r4, r1
1fff9f76:	d912      	bls.n	1fff9f9e <virtqueue_add_consumed_buffer+0x2e>
	}

	VQUEUE_BUSY(vq);

	/* CACHE: used is never written by driver, so it's safe to directly access it */
	used_idx = vq->vq_ring.used->idx & (vq->vq_nentries - 1);
1fff9f78:	6a03      	ldr	r3, [r0, #32]
1fff9f7a:	885d      	ldrh	r5, [r3, #2]
1fff9f7c:	3c01      	subs	r4, #1
1fff9f7e:	402c      	ands	r4, r5
1fff9f80:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
	used_desc = &vq->vq_ring.used->ring[used_idx];
	used_desc->id = head_idx;
1fff9f84:	6059      	str	r1, [r3, #4]
	used_desc->len = len;
1fff9f86:	609a      	str	r2, [r3, #8]

	/* We still need to flush it because this is read by driver */
	VRING_FLUSH(vq->vq_ring.used->ring[used_idx]);

	atomic_thread_fence(memory_order_seq_cst);
1fff9f88:	f3bf 8f5b 	dmb	ish

	vq->vq_ring.used->idx++;
1fff9f8c:	6a02      	ldr	r2, [r0, #32]
1fff9f8e:	8853      	ldrh	r3, [r2, #2]
1fff9f90:	3301      	adds	r3, #1
1fff9f92:	8053      	strh	r3, [r2, #2]

	/* Used.idx is read by driver, so we need to flush it */
	VRING_FLUSH(vq->vq_ring.used->idx);

	/* Keep pending count until virtqueue_notify(). */
	vq->vq_queued_cnt++;
1fff9f94:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
1fff9f96:	3301      	adds	r3, #1
1fff9f98:	84c3      	strh	r3, [r0, #38]	; 0x26

	VQUEUE_IDLE(vq);

	return VQUEUE_SUCCESS;
1fff9f9a:	2000      	movs	r0, #0
}
1fff9f9c:	bd30      	pop	{r4, r5, pc}
		return ERROR_VRING_NO_BUFF;
1fff9f9e:	4801      	ldr	r0, [pc, #4]	; (1fff9fa4 <virtqueue_add_consumed_buffer+0x34>)
1fff9fa0:	e7fc      	b.n	1fff9f9c <virtqueue_add_consumed_buffer+0x2c>
1fff9fa2:	bf00      	nop
1fff9fa4:	fffff441 	.word	0xfffff441

1fff9fa8 <rpmsg_send_offchannel_raw>:
 *
 */
int rpmsg_send_offchannel_raw(struct rpmsg_endpoint *ept, uint32_t src,
			      uint32_t dst, const void *data, int len,
			      int wait)
{
1fff9fa8:	b470      	push	{r4, r5, r6}
1fff9faa:	9e03      	ldr	r6, [sp, #12]
1fff9fac:	4614      	mov	r4, r2
	struct rpmsg_device *rdev;

	if (!ept || !ept->rdev || !data || dst == RPMSG_ADDR_ANY || len < 0)
1fff9fae:	b158      	cbz	r0, 1fff9fc8 <rpmsg_send_offchannel_raw+0x20>
1fff9fb0:	6a00      	ldr	r0, [r0, #32]
1fff9fb2:	b148      	cbz	r0, 1fff9fc8 <rpmsg_send_offchannel_raw+0x20>
1fff9fb4:	b143      	cbz	r3, 1fff9fc8 <rpmsg_send_offchannel_raw+0x20>
1fff9fb6:	3401      	adds	r4, #1
1fff9fb8:	d006      	beq.n	1fff9fc8 <rpmsg_send_offchannel_raw+0x20>
1fff9fba:	2e00      	cmp	r6, #0
1fff9fbc:	db04      	blt.n	1fff9fc8 <rpmsg_send_offchannel_raw+0x20>
		return RPMSG_ERR_PARAM;

	rdev = ept->rdev;

	if (rdev->ops.send_offchannel_raw)
1fff9fbe:	6f04      	ldr	r4, [r0, #112]	; 0x70
1fff9fc0:	b114      	cbz	r4, 1fff9fc8 <rpmsg_send_offchannel_raw+0x20>
		return rdev->ops.send_offchannel_raw(rdev, src, dst, data,
1fff9fc2:	46a4      	mov	ip, r4
						     len, wait);

	return RPMSG_ERR_PARAM;
}
1fff9fc4:	bc70      	pop	{r4, r5, r6}
		return rdev->ops.send_offchannel_raw(rdev, src, dst, data,
1fff9fc6:	4760      	bx	ip
		return RPMSG_ERR_PARAM;
1fff9fc8:	4801      	ldr	r0, [pc, #4]	; (1fff9fd0 <rpmsg_send_offchannel_raw+0x28>)
}
1fff9fca:	bc70      	pop	{r4, r5, r6}
1fff9fcc:	4770      	bx	lr
1fff9fce:	bf00      	nop
1fff9fd0:	fffff82d 	.word	0xfffff82d

1fff9fd4 <rpmsg_register_endpoint>:
			     struct rpmsg_endpoint *ept,
			     const char *name,
			     uint32_t src, uint32_t dest,
			     rpmsg_ept_cb cb,
			     rpmsg_ns_unbind_cb ns_unbind_cb)
{
1fff9fd4:	b570      	push	{r4, r5, r6, lr}
1fff9fd6:	461e      	mov	r6, r3
	strncpy(ept->name, name ? name : "", sizeof(ept->name));
1fff9fd8:	4b0d      	ldr	r3, [pc, #52]	; (1fffa010 <rpmsg_register_endpoint+0x3c>)
{
1fff9fda:	460c      	mov	r4, r1
1fff9fdc:	4611      	mov	r1, r2
1fff9fde:	4605      	mov	r5, r0
	strncpy(ept->name, name ? name : "", sizeof(ept->name));
1fff9fe0:	2220      	movs	r2, #32
1fff9fe2:	2900      	cmp	r1, #0
1fff9fe4:	bf08      	it	eq
1fff9fe6:	4619      	moveq	r1, r3
1fff9fe8:	4620      	mov	r0, r4
1fff9fea:	f001 fa84 	bl	1fffb4f6 <strncpy>
	ept->addr = src;
	ept->dest_addr = dest;
1fff9fee:	9b04      	ldr	r3, [sp, #16]
1fff9ff0:	62a3      	str	r3, [r4, #40]	; 0x28
	ept->cb = cb;
1fff9ff2:	9b05      	ldr	r3, [sp, #20]
1fff9ff4:	62e3      	str	r3, [r4, #44]	; 0x2c
	ept->ns_unbind_cb = ns_unbind_cb;
1fff9ff6:	9b06      	ldr	r3, [sp, #24]
1fff9ff8:	6323      	str	r3, [r4, #48]	; 0x30
	ept->addr = src;
1fff9ffa:	6266      	str	r6, [r4, #36]	; 0x24
	ept->rdev = rdev;
1fff9ffc:	6225      	str	r5, [r4, #32]
	new_node->prev = node->prev;
1fff9ffe:	686a      	ldr	r2, [r5, #4]
	new_node->next = node;
1fffa000:	e9c4 520d 	strd	r5, r2, [r4, #52]	; 0x34
	metal_list_add_tail(&rdev->endpoints, &ept->node);
1fffa004:	f104 0334 	add.w	r3, r4, #52	; 0x34
	new_node->next->prev = new_node;
1fffa008:	606b      	str	r3, [r5, #4]
	new_node->prev->next = new_node;
1fffa00a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
1fffa00c:	6013      	str	r3, [r2, #0]
}
1fffa00e:	bd70      	pop	{r4, r5, r6, pc}
1fffa010:	1fffd44a 	.word	0x1fffd44a

1fffa014 <rpmsg_create_ept>:

int rpmsg_create_ept(struct rpmsg_endpoint *ept, struct rpmsg_device *rdev,
		     const char *name, uint32_t src, uint32_t dest,
		     rpmsg_ept_cb cb, rpmsg_ns_unbind_cb unbind_cb)
{
1fffa014:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
1fffa018:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
1fffa01c:	460d      	mov	r5, r1
1fffa01e:	4692      	mov	sl, r2
1fffa020:	461f      	mov	r7, r3
	int status = RPMSG_SUCCESS;
	uint32_t addr = src;

	if (!ept || !rdev || !cb)
1fffa022:	4606      	mov	r6, r0
1fffa024:	2800      	cmp	r0, #0
1fffa026:	d06c      	beq.n	1fffa102 <rpmsg_create_ept+0xee>
1fffa028:	2900      	cmp	r1, #0
1fffa02a:	d06a      	beq.n	1fffa102 <rpmsg_create_ept+0xee>
1fffa02c:	f1b9 0f00 	cmp.w	r9, #0
1fffa030:	d067      	beq.n	1fffa102 <rpmsg_create_ept+0xee>
		return RPMSG_ERR_PARAM;

	metal_mutex_acquire(&rdev->lock);
1fffa032:	f101 0858 	add.w	r8, r1, #88	; 0x58
 * @brief	Acquire a mutex
 * @param[in]	mutex	Mutex to mutex.
 */
static inline void metal_mutex_acquire(metal_mutex_t *mutex)
{
	__metal_mutex_acquire(mutex);
1fffa036:	4640      	mov	r0, r8
1fffa038:	f002 f808 	bl	1fffc04c <__metal_mutex_acquire>
	if (src == RPMSG_ADDR_ANY) {
1fffa03c:	1c78      	adds	r0, r7, #1
1fffa03e:	d140      	bne.n	1fffa0c2 <rpmsg_create_ept+0xae>
		addr = rpmsg_get_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE);
1fffa040:	6cac      	ldr	r4, [r5, #72]	; 0x48
			    unsigned int max)
{
	unsigned int bit;

	for (bit = start;
	     bit < max && !metal_bitmap_is_bit_clear(bitmap, bit);
1fffa042:	f014 0401 	ands.w	r4, r4, #1
1fffa046:	f105 0348 	add.w	r3, r5, #72	; 0x48
1fffa04a:	d00b      	beq.n	1fffa064 <rpmsg_create_ept+0x50>
	for (bit = start;
1fffa04c:	2400      	movs	r4, #0
	     bit++)
1fffa04e:	3401      	adds	r4, #1
	     bit < max && !metal_bitmap_is_bit_clear(bitmap, bit);
1fffa050:	2c80      	cmp	r4, #128	; 0x80
1fffa052:	d054      	beq.n	1fffa0fe <rpmsg_create_ept+0xea>
	return ((bitmap[bit / METAL_BITS_PER_ULONG] &
1fffa054:	0962      	lsrs	r2, r4, #5
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1))) == 0) ? 0 : 1;
1fffa056:	f004 011f 	and.w	r1, r4, #31
1fffa05a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
1fffa05e:	40ca      	lsrs	r2, r1
	     bit < max && !metal_bitmap_is_bit_clear(bitmap, bit);
1fffa060:	07d1      	lsls	r1, r2, #31
1fffa062:	d4f4      	bmi.n	1fffa04e <rpmsg_create_ept+0x3a>
	bitmap[bit / METAL_BITS_PER_ULONG] |=
1fffa064:	0960      	lsrs	r0, r4, #5
		addr = RPMSG_RESERVED_ADDRESSES + nextbit;
1fffa066:	f504 6780 	add.w	r7, r4, #1024	; 0x400
1fffa06a:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
1fffa06e:	f004 041f 	and.w	r4, r4, #31
1fffa072:	2101      	movs	r1, #1
1fffa074:	40a1      	lsls	r1, r4
	bitmap[bit / METAL_BITS_PER_ULONG] |=
1fffa076:	430a      	orrs	r2, r1
1fffa078:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
		 * 1.Trust the author of predefined service
		 * 2.Simplify the tracking implementation
		 */
	}

	rpmsg_register_endpoint(rdev, ept, name, addr, dest, cb, unbind_cb);
1fffa07c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
1fffa07e:	e9cd 9301 	strd	r9, r3, [sp, #4]
1fffa082:	9b0c      	ldr	r3, [sp, #48]	; 0x30
1fffa084:	9300      	str	r3, [sp, #0]
1fffa086:	4652      	mov	r2, sl
1fffa088:	463b      	mov	r3, r7
1fffa08a:	4631      	mov	r1, r6
1fffa08c:	4628      	mov	r0, r5
1fffa08e:	f7ff ffa1 	bl	1fff9fd4 <rpmsg_register_endpoint>
	z_impl_k_sem_give(sem);
1fffa092:	4640      	mov	r0, r8
1fffa094:	f000 faf6 	bl	1fffa684 <z_impl_k_sem_give>
	metal_mutex_release(&rdev->lock);

	/* Send NS announcement to remote processor */
	if (ept->name[0] && rdev->support_ns &&
1fffa098:	7834      	ldrb	r4, [r6, #0]
1fffa09a:	b174      	cbz	r4, 1fffa0ba <rpmsg_create_ept+0xa6>
1fffa09c:	f895 4088 	ldrb.w	r4, [r5, #136]	; 0x88
1fffa0a0:	b15c      	cbz	r4, 1fffa0ba <rpmsg_create_ept+0xa6>
1fffa0a2:	6ab3      	ldr	r3, [r6, #40]	; 0x28
1fffa0a4:	3301      	adds	r3, #1
1fffa0a6:	d12e      	bne.n	1fffa106 <rpmsg_create_ept+0xf2>
	    ept->dest_addr == RPMSG_ADDR_ANY)
		status = rpmsg_send_ns_message(ept, RPMSG_NS_CREATE);
1fffa0a8:	2100      	movs	r1, #0
1fffa0aa:	4630      	mov	r0, r6
1fffa0ac:	f001 fffd 	bl	1fffc0aa <rpmsg_send_ns_message>

	if (status)
1fffa0b0:	4604      	mov	r4, r0
1fffa0b2:	b110      	cbz	r0, 1fffa0ba <rpmsg_create_ept+0xa6>
		rpmsg_unregister_endpoint(ept);
1fffa0b4:	4630      	mov	r0, r6
1fffa0b6:	f001 ffcf 	bl	1fffc058 <rpmsg_unregister_endpoint>
	return status;

ret_status:
	metal_mutex_release(&rdev->lock);
	return status;
}
1fffa0ba:	4620      	mov	r0, r4
1fffa0bc:	b004      	add	sp, #16
1fffa0be:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	} else if (src >= RPMSG_RESERVED_ADDRESSES) {
1fffa0c2:	f5b7 6f80 	cmp.w	r7, #1024	; 0x400
1fffa0c6:	d3d9      	bcc.n	1fffa07c <rpmsg_create_ept+0x68>
	addr -= RPMSG_RESERVED_ADDRESSES;
1fffa0c8:	f5a7 6380 	sub.w	r3, r7, #1024	; 0x400
	if (addr >= 0 && addr < size)
1fffa0cc:	2b7f      	cmp	r3, #127	; 0x7f
		status = rpmsg_is_address_set(rdev->bitmap,
1fffa0ce:	f105 0148 	add.w	r1, r5, #72	; 0x48
	if (addr >= 0 && addr < size)
1fffa0d2:	d80f      	bhi.n	1fffa0f4 <rpmsg_create_ept+0xe0>
	return ((bitmap[bit / METAL_BITS_PER_ULONG] &
1fffa0d4:	0958      	lsrs	r0, r3, #5
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1))) == 0) ? 0 : 1;
1fffa0d6:	f003 031f 	and.w	r3, r3, #31
	return ((bitmap[bit / METAL_BITS_PER_ULONG] &
1fffa0da:	f851 4020 	ldr.w	r4, [r1, r0, lsl #2]
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1))) == 0) ? 0 : 1;
1fffa0de:	fa24 f203 	lsr.w	r2, r4, r3
		if (!status) {
1fffa0e2:	07d2      	lsls	r2, r2, #31
1fffa0e4:	d40b      	bmi.n	1fffa0fe <rpmsg_create_ept+0xea>
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
1fffa0e6:	2201      	movs	r2, #1
1fffa0e8:	fa02 f303 	lsl.w	r3, r2, r3
	bitmap[bit / METAL_BITS_PER_ULONG] |=
1fffa0ec:	4323      	orrs	r3, r4
1fffa0ee:	f841 3020 	str.w	r3, [r1, r0, lsl #2]
}
1fffa0f2:	e7c3      	b.n	1fffa07c <rpmsg_create_ept+0x68>
1fffa0f4:	4c05      	ldr	r4, [pc, #20]	; (1fffa10c <rpmsg_create_ept+0xf8>)
1fffa0f6:	4640      	mov	r0, r8
1fffa0f8:	f000 fac4 	bl	1fffa684 <z_impl_k_sem_give>
}
1fffa0fc:	e7dd      	b.n	1fffa0ba <rpmsg_create_ept+0xa6>
			status = RPMSG_ERR_ADDR;
1fffa0fe:	4c04      	ldr	r4, [pc, #16]	; (1fffa110 <rpmsg_create_ept+0xfc>)
1fffa100:	e7f9      	b.n	1fffa0f6 <rpmsg_create_ept+0xe2>
		return RPMSG_ERR_PARAM;
1fffa102:	4c02      	ldr	r4, [pc, #8]	; (1fffa10c <rpmsg_create_ept+0xf8>)
1fffa104:	e7d9      	b.n	1fffa0ba <rpmsg_create_ept+0xa6>
1fffa106:	2400      	movs	r4, #0
1fffa108:	e7d7      	b.n	1fffa0ba <rpmsg_create_ept+0xa6>
1fffa10a:	bf00      	nop
1fffa10c:	fffff82d 	.word	0xfffff82d
1fffa110:	fffff829 	.word	0xfffff829

1fffa114 <rpmsg_virtio_send_offchannel_raw>:
 */
static int rpmsg_virtio_send_offchannel_raw(struct rpmsg_device *rdev,
					    uint32_t src, uint32_t dst,
					    const void *data,
					    int len, int wait)
{
1fffa114:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
1fffa118:	b085      	sub	sp, #20
1fffa11a:	460f      	mov	r7, r1
1fffa11c:	4690      	mov	r8, r2

	/* Get the associated remote device for channel. */
	rvdev = metal_container_of(rdev, struct rpmsg_virtio_device, rdev);

	/* Get the payload buffer. */
	buffer = rpmsg_virtio_get_tx_payload_buffer(rdev, &buff_len, wait);
1fffa11e:	a903      	add	r1, sp, #12
1fffa120:	9a0d      	ldr	r2, [sp, #52]	; 0x34
{
1fffa122:	4605      	mov	r5, r0
1fffa124:	4699      	mov	r9, r3
	buffer = rpmsg_virtio_get_tx_payload_buffer(rdev, &buff_len, wait);
1fffa126:	f002 f988 	bl	1fffc43a <rpmsg_virtio_get_tx_payload_buffer>
	if (!buffer)
1fffa12a:	4604      	mov	r4, r0
1fffa12c:	b1e0      	cbz	r0, 1fffa168 <rpmsg_virtio_send_offchannel_raw+0x54>
		return RPMSG_ERR_NO_BUFF;

	/* Copy data to rpmsg buffer. */
	if (len > (int)buff_len)
		len = buff_len;
	io = rvdev->shbuf_io;
1fffa12e:	f8d5 00a4 	ldr.w	r0, [r5, #164]	; 0xa4
1fffa132:	9e0c      	ldr	r6, [sp, #48]	; 0x30
1fffa134:	9b03      	ldr	r3, [sp, #12]
 * @return	METAL_BAD_OFFSET if out of range, or offset.
 */
static inline unsigned long
metal_io_virt_to_offset(struct metal_io_region *io, void *virt)
{
	size_t offset = (uintptr_t)virt - (uintptr_t)io->virt;
1fffa136:	6801      	ldr	r1, [r0, #0]
	status = metal_io_block_write(io, metal_io_virt_to_offset(io, buffer),
1fffa138:	f8d0 c008 	ldr.w	ip, [r0, #8]
1fffa13c:	429e      	cmp	r6, r3
1fffa13e:	bfa8      	it	ge
1fffa140:	461e      	movge	r6, r3
1fffa142:	1a61      	subs	r1, r4, r1
1fffa144:	4633      	mov	r3, r6
1fffa146:	464a      	mov	r2, r9
1fffa148:	4561      	cmp	r1, ip
1fffa14a:	bf28      	it	cs
1fffa14c:	f04f 31ff 	movcs.w	r1, #4294967295	; 0xffffffff
1fffa150:	f001 fe70 	bl	1fffbe34 <metal_io_block_write>
				      data, len);
	RPMSG_ASSERT(status == len, "failed to write buffer\r\n");

	return rpmsg_virtio_send_offchannel_nocopy(rdev, src, dst, buffer, len);
1fffa154:	9600      	str	r6, [sp, #0]
1fffa156:	4623      	mov	r3, r4
1fffa158:	4642      	mov	r2, r8
1fffa15a:	4639      	mov	r1, r7
1fffa15c:	4628      	mov	r0, r5
1fffa15e:	f002 f89c 	bl	1fffc29a <rpmsg_virtio_send_offchannel_nocopy>
}
1fffa162:	b005      	add	sp, #20
1fffa164:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return RPMSG_ERR_NO_BUFF;
1fffa168:	4800      	ldr	r0, [pc, #0]	; (1fffa16c <rpmsg_virtio_send_offchannel_raw+0x58>)
1fffa16a:	e7fa      	b.n	1fffa162 <rpmsg_virtio_send_offchannel_raw+0x4e>
1fffa16c:	fffff82e 	.word	0xfffff82e

1fffa170 <rpmsg_init_vdev_with_config>:
				struct virtio_device *vdev,
				rpmsg_ns_bind_cb ns_bind_cb,
				struct metal_io_region *shm_io,
				struct rpmsg_virtio_shm_pool *shpool,
				const struct rpmsg_virtio_config *config)
{
1fffa170:	b5f0      	push	{r4, r5, r6, r7, lr}
1fffa172:	460d      	mov	r5, r1
1fffa174:	b089      	sub	sp, #36	; 0x24
1fffa176:	4616      	mov	r6, r2
1fffa178:	461f      	mov	r7, r3
	const char *vq_names[RPMSG_NUM_VRINGS];
	vq_callback callback[RPMSG_NUM_VRINGS];
	int status;
	unsigned int i, role;

	if (!rvdev || !vdev || !shm_io)
1fffa17a:	4604      	mov	r4, r0
1fffa17c:	2800      	cmp	r0, #0
1fffa17e:	f000 8081 	beq.w	1fffa284 <rpmsg_init_vdev_with_config+0x114>
1fffa182:	2900      	cmp	r1, #0
1fffa184:	d07e      	beq.n	1fffa284 <rpmsg_init_vdev_with_config+0x114>
1fffa186:	2b00      	cmp	r3, #0
1fffa188:	d07c      	beq.n	1fffa284 <rpmsg_init_vdev_with_config+0x114>
		return RPMSG_ERR_PARAM;

	rdev = &rvdev->rdev;
	memset(rdev, 0, sizeof(*rdev));
1fffa18a:	228c      	movs	r2, #140	; 0x8c
1fffa18c:	2100      	movs	r1, #0
1fffa18e:	f001 fa01 	bl	1fffb594 <memset>
	return z_impl_k_sem_init(sem, initial_count, limit);
1fffa192:	2201      	movs	r2, #1
1fffa194:	4611      	mov	r1, r2
1fffa196:	f104 0058 	add.w	r0, r4, #88	; 0x58
1fffa19a:	f002 faf1 	bl	1fffc780 <z_impl_k_sem_init>
	metal_mutex_init(&rdev->lock);
	rvdev->vdev = vdev;
	rdev->ns_bind_cb = ns_bind_cb;
	vdev->priv = rvdev;
	rdev->ops.send_offchannel_raw = rpmsg_virtio_send_offchannel_raw;
1fffa19e:	4b3a      	ldr	r3, [pc, #232]	; (1fffa288 <rpmsg_init_vdev_with_config+0x118>)
	rvdev->vdev = vdev;
1fffa1a0:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98
	rdev->ns_bind_cb = ns_bind_cb;
1fffa1a4:	66a6      	str	r6, [r4, #104]	; 0x68
	vdev->priv = rvdev;
1fffa1a6:	626c      	str	r4, [r5, #36]	; 0x24
	rdev->ops.send_offchannel_raw = rpmsg_virtio_send_offchannel_raw;
1fffa1a8:	6723      	str	r3, [r4, #112]	; 0x70
	rdev->ops.hold_rx_buffer = rpmsg_virtio_hold_rx_buffer;
1fffa1aa:	4b38      	ldr	r3, [pc, #224]	; (1fffa28c <rpmsg_init_vdev_with_config+0x11c>)
1fffa1ac:	6763      	str	r3, [r4, #116]	; 0x74
	rdev->ops.release_rx_buffer = rpmsg_virtio_release_rx_buffer;
1fffa1ae:	4b38      	ldr	r3, [pc, #224]	; (1fffa290 <rpmsg_init_vdev_with_config+0x120>)
1fffa1b0:	67a3      	str	r3, [r4, #120]	; 0x78
	rdev->ops.get_tx_payload_buffer = rpmsg_virtio_get_tx_payload_buffer;
1fffa1b2:	4b38      	ldr	r3, [pc, #224]	; (1fffa294 <rpmsg_init_vdev_with_config+0x124>)
1fffa1b4:	67e3      	str	r3, [r4, #124]	; 0x7c
	rdev->ops.send_offchannel_nocopy = rpmsg_virtio_send_offchannel_nocopy;
1fffa1b6:	4b38      	ldr	r3, [pc, #224]	; (1fffa298 <rpmsg_init_vdev_with_config+0x128>)
1fffa1b8:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
	rdev->ops.release_tx_buffer = rpmsg_virtio_release_tx_buffer;
1fffa1bc:	4b37      	ldr	r3, [pc, #220]	; (1fffa29c <rpmsg_init_vdev_with_config+0x12c>)
1fffa1be:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
}

static inline unsigned int
rpmsg_virtio_get_role(struct rpmsg_virtio_device *rvdev)
{
	return rvdev->vdev->role;
1fffa1c2:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
1fffa1c6:	699e      	ldr	r6, [r3, #24]
	(void)config;
#endif /*!VIRTIO_DEVICE_ONLY*/


#ifndef VIRTIO_DRIVER_ONLY
	if (role == RPMSG_REMOTE) {
1fffa1c8:	2e01      	cmp	r6, #1
1fffa1ca:	d04d      	beq.n	1fffa268 <rpmsg_init_vdev_with_config+0xf8>
		/* wait synchro with the host */
		rpmsg_virtio_wait_remote_ready(rvdev);
	}
#endif /*!VIRTIO_DRIVER_ONLY*/
	vdev->features = rpmsg_virtio_get_features(rvdev);
1fffa1cc:	f8d4 0098 	ldr.w	r0, [r4, #152]	; 0x98
}

static inline uint32_t
rpmsg_virtio_get_features(struct rpmsg_virtio_device *rvdev)
{
	return rvdev->vdev->func->get_features(rvdev->vdev);
1fffa1d0:	6a03      	ldr	r3, [r0, #32]
1fffa1d2:	689b      	ldr	r3, [r3, #8]
1fffa1d4:	4798      	blx	r3
1fffa1d6:	2300      	movs	r3, #0
1fffa1d8:	6128      	str	r0, [r5, #16]
	}
#endif /*!VIRTIO_DEVICE_ONLY*/

#ifndef VIRTIO_DRIVER_ONLY
	(void)shpool;
	if (role == RPMSG_REMOTE) {
1fffa1da:	2e01      	cmp	r6, #1
	rdev->support_ns = !!(vdev->features & (1 << VIRTIO_RPMSG_F_NS));
1fffa1dc:	f000 0001 	and.w	r0, r0, #1
	vdev->features = rpmsg_virtio_get_features(rvdev);
1fffa1e0:	616b      	str	r3, [r5, #20]
	rdev->support_ns = !!(vdev->features & (1 << VIRTIO_RPMSG_F_NS));
1fffa1e2:	f884 0088 	strb.w	r0, [r4, #136]	; 0x88
	if (role == RPMSG_REMOTE) {
1fffa1e6:	d10f      	bne.n	1fffa208 <rpmsg_init_vdev_with_config+0x98>
		vq_names[0] = "tx_vq";
1fffa1e8:	4b2d      	ldr	r3, [pc, #180]	; (1fffa2a0 <rpmsg_init_vdev_with_config+0x130>)
1fffa1ea:	9304      	str	r3, [sp, #16]
		vq_names[1] = "rx_vq";
1fffa1ec:	4b2d      	ldr	r3, [pc, #180]	; (1fffa2a4 <rpmsg_init_vdev_with_config+0x134>)
1fffa1ee:	9305      	str	r3, [sp, #20]
		callback[0] = rpmsg_virtio_tx_callback;
1fffa1f0:	4b2d      	ldr	r3, [pc, #180]	; (1fffa2a8 <rpmsg_init_vdev_with_config+0x138>)
1fffa1f2:	9306      	str	r3, [sp, #24]
		callback[1] = rpmsg_virtio_rx_callback;
1fffa1f4:	4b2d      	ldr	r3, [pc, #180]	; (1fffa2ac <rpmsg_init_vdev_with_config+0x13c>)
1fffa1f6:	9307      	str	r3, [sp, #28]
		rvdev->rvq  = vdev->vrings_info[1].vq;
1fffa1f8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
1fffa1fa:	699b      	ldr	r3, [r3, #24]
1fffa1fc:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
		rvdev->svq  = vdev->vrings_info[0].vq;
1fffa200:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
1fffa202:	681b      	ldr	r3, [r3, #0]
1fffa204:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
	}
#endif /*!VIRTIO_DRIVER_ONLY*/
	rvdev->shbuf_io = shm_io;
	metal_list_init(&rvdev->reclaimer);
1fffa208:	f104 03ac 	add.w	r3, r4, #172	; 0xac
	list->next = list;
1fffa20c:	e9c4 332b 	strd	r3, r3, [r4, #172]	; 0xac
rpmsg_virtio_create_virtqueues(struct rpmsg_virtio_device *rvdev,
			       int flags, unsigned int nvqs,
			       const char *names[],
			       vq_callback *callbacks)
{
	return virtio_create_virtqueues(rvdev->vdev, flags, nvqs, names,
1fffa210:	ab06      	add	r3, sp, #24
	rvdev->shbuf_io = shm_io;
1fffa212:	f8c4 70a4 	str.w	r7, [r4, #164]	; 0xa4
1fffa216:	9300      	str	r3, [sp, #0]
1fffa218:	f8d4 0098 	ldr.w	r0, [r4, #152]	; 0x98
1fffa21c:	ab04      	add	r3, sp, #16
1fffa21e:	2202      	movs	r2, #2
1fffa220:	2100      	movs	r1, #0
1fffa222:	f7ff fe75 	bl	1fff9f10 <virtio_create_virtqueues>

	/* Create virtqueues for remote device */
	status = rpmsg_virtio_create_virtqueues(rvdev, 0, RPMSG_NUM_VRINGS,
						vq_names, callback);
	if (status != RPMSG_SUCCESS)
1fffa226:	4606      	mov	r6, r0
1fffa228:	b9c8      	cbnz	r0, 1fffa25e <rpmsg_init_vdev_with_config+0xee>

	/*
	 * Suppress "tx-complete" interrupts
	 * since send method use busy loop when buffer pool exhaust
	 */
	virtqueue_disable_cb(rvdev->svq);
1fffa22a:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
1fffa22e:	f001 fec6 	bl	1fffbfbe <virtqueue_disable_cb>

	/* TODO: can have a virtio function to set the shared memory I/O */
	for (i = 0; i < RPMSG_NUM_VRINGS; i++) {
		struct virtqueue *vq;

		vq = vdev->vrings_info[i].vq;
1fffa232:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
1fffa234:	681b      	ldr	r3, [r3, #0]
		vq->shm_io = shm_io;
1fffa236:	629f      	str	r7, [r3, #40]	; 0x28
		vq = vdev->vrings_info[i].vq;
1fffa238:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
1fffa23a:	699b      	ldr	r3, [r3, #24]
		vq->shm_io = shm_io;
1fffa23c:	629f      	str	r7, [r3, #40]	; 0x28

	/*
	 * Create name service announcement endpoint if device supports name
	 * service announcement feature.
	 */
	if (rdev->support_ns) {
1fffa23e:	f894 3088 	ldrb.w	r3, [r4, #136]	; 0x88
1fffa242:	e9c4 4400 	strd	r4, r4, [r4]
1fffa246:	b153      	cbz	r3, 1fffa25e <rpmsg_init_vdev_with_config+0xee>
		rpmsg_register_endpoint(rdev, &rdev->ns_ept, "NS",
1fffa248:	4b19      	ldr	r3, [pc, #100]	; (1fffa2b0 <rpmsg_init_vdev_with_config+0x140>)
1fffa24a:	9301      	str	r3, [sp, #4]
1fffa24c:	2335      	movs	r3, #53	; 0x35
1fffa24e:	4a19      	ldr	r2, [pc, #100]	; (1fffa2b4 <rpmsg_init_vdev_with_config+0x144>)
1fffa250:	9602      	str	r6, [sp, #8]
1fffa252:	9300      	str	r3, [sp, #0]
1fffa254:	f104 0108 	add.w	r1, r4, #8
1fffa258:	4620      	mov	r0, r4
1fffa25a:	f7ff febb 	bl	1fff9fd4 <rpmsg_register_endpoint>
	if (role == RPMSG_HOST)
		rpmsg_virtio_set_status(rvdev, VIRTIO_CONFIG_STATUS_DRIVER_OK);
#endif /*!VIRTIO_DEVICE_ONLY*/

	return status;
}
1fffa25e:	4630      	mov	r0, r6
1fffa260:	b009      	add	sp, #36	; 0x24
1fffa262:	bdf0      	pop	{r4, r5, r6, r7, pc}
		} else if (status & VIRTIO_CONFIG_STATUS_DRIVER_OK) {
1fffa264:	0743      	lsls	r3, r0, #29
1fffa266:	d4b1      	bmi.n	1fffa1cc <rpmsg_init_vdev_with_config+0x5c>
		status = rpmsg_virtio_get_status(rvdev);
1fffa268:	f8d4 0098 	ldr.w	r0, [r4, #152]	; 0x98
	return rvdev->vdev->func->get_status(rvdev->vdev);
1fffa26c:	6a03      	ldr	r3, [r0, #32]
1fffa26e:	681b      	ldr	r3, [r3, #0]
1fffa270:	4798      	blx	r3
		if (status & VIRTIO_CONFIG_STATUS_NEEDS_RESET) {
1fffa272:	0642      	lsls	r2, r0, #25
1fffa274:	d5f6      	bpl.n	1fffa264 <rpmsg_init_vdev_with_config+0xf4>
			rpmsg_virtio_set_status(rvdev, 0);
1fffa276:	f8d4 0098 	ldr.w	r0, [r4, #152]	; 0x98
	rvdev->vdev->func->set_status(rvdev->vdev, status);
1fffa27a:	6a03      	ldr	r3, [r0, #32]
1fffa27c:	2100      	movs	r1, #0
1fffa27e:	685b      	ldr	r3, [r3, #4]
1fffa280:	4798      	blx	r3
}
1fffa282:	e7f1      	b.n	1fffa268 <rpmsg_init_vdev_with_config+0xf8>
		return RPMSG_ERR_PARAM;
1fffa284:	4e0c      	ldr	r6, [pc, #48]	; (1fffa2b8 <rpmsg_init_vdev_with_config+0x148>)
1fffa286:	e7ea      	b.n	1fffa25e <rpmsg_init_vdev_with_config+0xee>
1fffa288:	1fffa115 	.word	0x1fffa115
1fffa28c:	1fffc1a1 	.word	0x1fffc1a1
1fffa290:	1fffc315 	.word	0x1fffc315
1fffa294:	1fffc43b 	.word	0x1fffc43b
1fffa298:	1fffc29b 	.word	0x1fffc29b
1fffa29c:	1fffc1c1 	.word	0x1fffc1c1
1fffa2a0:	1fffd593 	.word	0x1fffd593
1fffa2a4:	1fffd599 	.word	0x1fffd599
1fffa2a8:	1fffc1af 	.word	0x1fffc1af
1fffa2ac:	1fffc35b 	.word	0x1fffc35b
1fffa2b0:	1fffc203 	.word	0x1fffc203
1fffa2b4:	1fffd59f 	.word	0x1fffd59f
1fffa2b8:	fffff82d 	.word	0xfffff82d

1fffa2bc <rproc_virtio_create_vdev>:
rproc_virtio_create_vdev(unsigned int role, unsigned int notifyid,
			 void *rsc, struct metal_io_region *rsc_io,
			 void *priv,
			 rpvdev_notify_func notify,
			 virtio_dev_reset_cb rst_cb)
{
1fffa2bc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
1fffa2c0:	e9cd 0100 	strd	r0, r1, [sp]
#endif

#if (CONFIG_HEAP_MEM_POOL_SIZE > 0)
static inline void *metal_allocate_memory(unsigned int size)
{
	return k_malloc(size);
1fffa2c4:	2048      	movs	r0, #72	; 0x48
	struct remoteproc_virtio *rpvdev;
	struct virtio_vring_info *vrings_info;
	struct fw_rsc_vdev *vdev_rsc = rsc;
	struct virtio_device *vdev;
	unsigned int num_vrings = vdev_rsc->num_of_vrings;
1fffa2c6:	7e57      	ldrb	r7, [r2, #25]
{
1fffa2c8:	4690      	mov	r8, r2
1fffa2ca:	469a      	mov	sl, r3
1fffa2cc:	f002 fb84 	bl	1fffc9d8 <k_malloc>
	unsigned int i;

	rpvdev = metal_allocate_memory(sizeof(*rpvdev));
	if (!rpvdev)
1fffa2d0:	4604      	mov	r4, r0
1fffa2d2:	2800      	cmp	r0, #0
1fffa2d4:	d04c      	beq.n	1fffa370 <rproc_virtio_create_vdev+0xb4>
		return NULL;
	vrings_info = metal_allocate_memory(sizeof(*vrings_info) * num_vrings);
1fffa2d6:	eb07 0047 	add.w	r0, r7, r7, lsl #1
1fffa2da:	00c0      	lsls	r0, r0, #3
1fffa2dc:	f002 fb7c 	bl	1fffc9d8 <k_malloc>
	if (!vrings_info)
1fffa2e0:	4606      	mov	r6, r0
1fffa2e2:	2800      	cmp	r0, #0
1fffa2e4:	d041      	beq.n	1fffa36a <rproc_virtio_create_vdev+0xae>
		goto err0;
	memset(rpvdev, 0, sizeof(*rpvdev));
1fffa2e6:	2248      	movs	r2, #72	; 0x48
1fffa2e8:	2100      	movs	r1, #0
1fffa2ea:	4620      	mov	r0, r4
1fffa2ec:	f001 f952 	bl	1fffb594 <memset>
	memset(vrings_info, 0, sizeof(*vrings_info));
1fffa2f0:	2218      	movs	r2, #24
1fffa2f2:	2100      	movs	r1, #0
1fffa2f4:	4630      	mov	r0, r6
1fffa2f6:	f001 f94d 	bl	1fffb594 <memset>
	vdev = &rpvdev->vdev;

	for (i = 0; i < num_vrings; i++) {
1fffa2fa:	f04f 0900 	mov.w	r9, #0
		}
#endif
		vq = virtqueue_allocate(num_extra_desc);
		if (!vq)
			goto err1;
		vrings_info[i].vq = vq;
1fffa2fe:	f04f 0b18 	mov.w	fp, #24
	for (i = 0; i < num_vrings; i++) {
1fffa302:	45b9      	cmp	r9, r7
1fffa304:	d314      	bcc.n	1fffa330 <rproc_virtio_create_vdev+0x74>
	}

	rpvdev->notify = notify;
1fffa306:	9b0d      	ldr	r3, [sp, #52]	; 0x34
1fffa308:	60e3      	str	r3, [r4, #12]
	rpvdev->priv = priv;
1fffa30a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
1fffa30c:	6023      	str	r3, [r4, #0]
	 * necessary
	 */
	rpvdev->vdev_rsc = vdev_rsc;
	rpvdev->vdev_rsc_io = rsc_io;

	vdev->notifyid = notifyid;
1fffa30e:	9b01      	ldr	r3, [sp, #4]
1fffa310:	6123      	str	r3, [r4, #16]
	vdev->role = role;
1fffa312:	9b00      	ldr	r3, [sp, #0]
1fffa314:	62a3      	str	r3, [r4, #40]	; 0x28
	rpvdev->vdev_rsc_io = rsc_io;
1fffa316:	e9c4 8a01 	strd	r8, sl, [r4, #4]
	vdev->reset_cb = rst_cb;
1fffa31a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
1fffa31c:	62e3      	str	r3, [r4, #44]	; 0x2c
	vdev->vrings_num = num_vrings;
	vdev->func = &remoteproc_virtio_dispatch_funcs;
1fffa31e:	4b15      	ldr	r3, [pc, #84]	; (1fffa374 <rproc_virtio_create_vdev+0xb8>)
	vdev->vrings_info = vrings_info;
1fffa320:	63e6      	str	r6, [r4, #60]	; 0x3c
	vdev = &rpvdev->vdev;
1fffa322:	f104 0010 	add.w	r0, r4, #16
	vdev->vrings_num = num_vrings;
1fffa326:	63a7      	str	r7, [r4, #56]	; 0x38
	vdev->func = &remoteproc_virtio_dispatch_funcs;
1fffa328:	6323      	str	r3, [r4, #48]	; 0x30
	}
	metal_free_memory(vrings_info);
err0:
	metal_free_memory(rpvdev);
	return NULL;
}
1fffa32a:	b003      	add	sp, #12
1fffa32c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
1fffa330:	2034      	movs	r0, #52	; 0x34
1fffa332:	f002 fb51 	bl	1fffc9d8 <k_malloc>
	struct virtqueue *vqs;
	uint32_t vq_size = sizeof(struct virtqueue) +
		 num_desc_extra * sizeof(struct vq_desc_extra);

	vqs = (struct virtqueue *)metal_allocate_memory(vq_size);
	if (vqs) {
1fffa336:	4605      	mov	r5, r0
1fffa338:	b148      	cbz	r0, 1fffa34e <rproc_virtio_create_vdev+0x92>
		memset(vqs, 0x00, vq_size);
1fffa33a:	2234      	movs	r2, #52	; 0x34
1fffa33c:	2100      	movs	r1, #0
1fffa33e:	f001 f929 	bl	1fffb594 <memset>
		vrings_info[i].vq = vq;
1fffa342:	fb0b f209 	mul.w	r2, fp, r9
	for (i = 0; i < num_vrings; i++) {
1fffa346:	f109 0901 	add.w	r9, r9, #1
		vrings_info[i].vq = vq;
1fffa34a:	50b5      	str	r5, [r6, r2]
	for (i = 0; i < num_vrings; i++) {
1fffa34c:	e7d9      	b.n	1fffa302 <rproc_virtio_create_vdev+0x46>
		if (vrings_info[i].vq)
1fffa34e:	f04f 0818 	mov.w	r8, #24
1fffa352:	fb08 f305 	mul.w	r3, r8, r5
1fffa356:	58f0      	ldr	r0, [r6, r3]
1fffa358:	b108      	cbz	r0, 1fffa35e <rproc_virtio_create_vdev+0xa2>
}

static inline void metal_free_memory(void *ptr)
{
	k_free(ptr);
1fffa35a:	f002 fb36 	bl	1fffc9ca <k_free>
	for (i = 0; i < num_vrings; i++) {
1fffa35e:	3501      	adds	r5, #1
1fffa360:	42af      	cmp	r7, r5
1fffa362:	d8f6      	bhi.n	1fffa352 <rproc_virtio_create_vdev+0x96>
1fffa364:	4630      	mov	r0, r6
1fffa366:	f002 fb30 	bl	1fffc9ca <k_free>
1fffa36a:	4620      	mov	r0, r4
1fffa36c:	f002 fb2d 	bl	1fffc9ca <k_free>
		return NULL;
1fffa370:	2000      	movs	r0, #0
1fffa372:	e7da      	b.n	1fffa32a <rproc_virtio_create_vdev+0x6e>
1fffa374:	1fffd2e8 	.word	0x1fffd2e8

1fffa378 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
1fffa378:	4b0f      	ldr	r3, [pc, #60]	; (1fffa3b8 <z_sys_init_run_level+0x40>)
{
1fffa37a:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
1fffa37c:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
1fffa380:	3001      	adds	r0, #1
1fffa382:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
1fffa386:	42a6      	cmp	r6, r4
1fffa388:	d800      	bhi.n	1fffa38c <z_sys_init_run_level+0x14>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
1fffa38a:	bd70      	pop	{r4, r5, r6, pc}
		int rc = entry->init(dev);
1fffa38c:	e9d4 3500 	ldrd	r3, r5, [r4]
1fffa390:	4628      	mov	r0, r5
1fffa392:	4798      	blx	r3
		if (dev != NULL) {
1fffa394:	b16d      	cbz	r5, 1fffa3b2 <z_sys_init_run_level+0x3a>
			if (rc != 0) {
1fffa396:	b138      	cbz	r0, 1fffa3a8 <z_sys_init_run_level+0x30>
				if (rc < 0) {
1fffa398:	2800      	cmp	r0, #0
1fffa39a:	bfb8      	it	lt
1fffa39c:	4240      	neglt	r0, r0
				dev->state->init_res = rc;
1fffa39e:	68eb      	ldr	r3, [r5, #12]
				if (rc > UINT8_MAX) {
1fffa3a0:	28ff      	cmp	r0, #255	; 0xff
1fffa3a2:	bfa8      	it	ge
1fffa3a4:	20ff      	movge	r0, #255	; 0xff
				dev->state->init_res = rc;
1fffa3a6:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
1fffa3a8:	68ea      	ldr	r2, [r5, #12]
1fffa3aa:	7853      	ldrb	r3, [r2, #1]
1fffa3ac:	f043 0301 	orr.w	r3, r3, #1
1fffa3b0:	7053      	strb	r3, [r2, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
1fffa3b2:	3408      	adds	r4, #8
1fffa3b4:	e7e7      	b.n	1fffa386 <z_sys_init_run_level+0xe>
1fffa3b6:	bf00      	nop
1fffa3b8:	1fffd310 	.word	0x1fffd310

1fffa3bc <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
1fffa3bc:	b508      	push	{r3, lr}
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
1fffa3be:	4b0a      	ldr	r3, [pc, #40]	; (1fffa3e8 <bg_thread_main+0x2c>)
1fffa3c0:	2201      	movs	r2, #1

	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
1fffa3c2:	2003      	movs	r0, #3
	z_sys_post_kernel = true;
1fffa3c4:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
1fffa3c6:	f7ff ffd7 	bl	1fffa378 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
1fffa3ca:	f000 fe2d 	bl	1fffb028 <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
1fffa3ce:	2004      	movs	r0, #4
1fffa3d0:	f7ff ffd2 	bl	1fffa378 <z_sys_init_run_level>

	z_init_static_threads();
1fffa3d4:	f000 f90a 	bl	1fffa5ec <z_init_static_threads>
	extern int main(void);
#else
	extern void main(void);
#endif

	(void)main();
1fffa3d8:	f7fe fa94 	bl	1fff8904 <main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
1fffa3dc:	4a03      	ldr	r2, [pc, #12]	; (1fffa3ec <bg_thread_main+0x30>)
1fffa3de:	7b13      	ldrb	r3, [r2, #12]
1fffa3e0:	f023 0301 	bic.w	r3, r3, #1
1fffa3e4:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
1fffa3e6:	bd08      	pop	{r3, pc}
1fffa3e8:	200009ed 	.word	0x200009ed
1fffa3ec:	20000370 	.word	0x20000370

1fffa3f0 <z_bss_zero>:
{
1fffa3f0:	b508      	push	{r3, lr}
	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
1fffa3f2:	4803      	ldr	r0, [pc, #12]	; (1fffa400 <z_bss_zero+0x10>)
1fffa3f4:	4a03      	ldr	r2, [pc, #12]	; (1fffa404 <z_bss_zero+0x14>)
1fffa3f6:	2100      	movs	r1, #0
1fffa3f8:	1a12      	subs	r2, r2, r0
1fffa3fa:	f002 f9b1 	bl	1fffc760 <z_early_memset>
}
1fffa3fe:	bd08      	pop	{r3, pc}
1fffa400:	200001b0 	.word	0x200001b0
1fffa404:	200009f0 	.word	0x200009f0

1fffa408 <z_init_cpu>:
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
1fffa408:	b570      	push	{r4, r5, r6, lr}
	struct k_thread *thread = &z_idle_threads[i];
1fffa40a:	4e14      	ldr	r6, [pc, #80]	; (1fffa45c <z_init_cpu+0x54>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
1fffa40c:	4d14      	ldr	r5, [pc, #80]	; (1fffa460 <z_init_cpu+0x58>)
	z_setup_new_thread(thread, stack,
1fffa40e:	4915      	ldr	r1, [pc, #84]	; (1fffa464 <z_init_cpu+0x5c>)
	struct k_thread *thread = &z_idle_threads[i];
1fffa410:	2370      	movs	r3, #112	; 0x70
{
1fffa412:	b086      	sub	sp, #24
	struct k_thread *thread = &z_idle_threads[i];
1fffa414:	fb03 6600 	mla	r6, r3, r0, r6
	z_setup_new_thread(thread, stack,
1fffa418:	2201      	movs	r2, #1
1fffa41a:	2300      	movs	r3, #0
1fffa41c:	e9cd 2304 	strd	r2, r3, [sp, #16]
1fffa420:	220f      	movs	r2, #15
1fffa422:	e9cd 3202 	strd	r3, r2, [sp, #8]
1fffa426:	9301      	str	r3, [sp, #4]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
1fffa428:	2314      	movs	r3, #20
1fffa42a:	fb03 5500 	mla	r5, r3, r0, r5
	z_setup_new_thread(thread, stack,
1fffa42e:	f44f 72a0 	mov.w	r2, #320	; 0x140
{
1fffa432:	4604      	mov	r4, r0
	z_setup_new_thread(thread, stack,
1fffa434:	fb02 1100 	mla	r1, r2, r0, r1
1fffa438:	4b0b      	ldr	r3, [pc, #44]	; (1fffa468 <z_init_cpu+0x60>)
1fffa43a:	9500      	str	r5, [sp, #0]
1fffa43c:	4630      	mov	r0, r6
1fffa43e:	f000 f87f 	bl	1fffa540 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
1fffa442:	7b73      	ldrb	r3, [r6, #13]
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
	_kernel.cpus[id].id = id;
1fffa444:	742c      	strb	r4, [r5, #16]
1fffa446:	f023 0304 	bic.w	r3, r3, #4
1fffa44a:	7373      	strb	r3, [r6, #13]
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
1fffa44c:	4b07      	ldr	r3, [pc, #28]	; (1fffa46c <z_init_cpu+0x64>)
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
1fffa44e:	60ee      	str	r6, [r5, #12]
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
1fffa450:	3401      	adds	r4, #1
1fffa452:	eb03 23c4 	add.w	r3, r3, r4, lsl #11
	_kernel.cpus[id].irq_stack =
1fffa456:	606b      	str	r3, [r5, #4]
		 K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[id]));
#ifdef CONFIG_SCHED_THREAD_USAGE_ALL
	_kernel.cpus[id].usage.track_usage =
		CONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;
#endif
}
1fffa458:	b006      	add	sp, #24
1fffa45a:	bd70      	pop	{r4, r5, r6, pc}
1fffa45c:	20000300 	.word	0x20000300
1fffa460:	200005a8 	.word	0x200005a8
1fffa464:	200019f0 	.word	0x200019f0
1fffa468:	1fffc769 	.word	0x1fffc769
1fffa46c:	200011f0 	.word	0x200011f0

1fffa470 <z_cstart>:
 * @return Does not return
 */
__boot_func
FUNC_NO_STACK_PROTECTOR
FUNC_NORETURN void z_cstart(void)
{
1fffa470:	b580      	push	{r7, lr}
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
1fffa472:	2000      	movs	r0, #0
{
1fffa474:	b0a2      	sub	sp, #136	; 0x88
	z_sys_init_run_level(INIT_LEVEL_EARLY);
1fffa476:	f7ff ff7f 	bl	1fffa378 <z_sys_init_run_level>
 * pointer) register, and switched to automatically when taking an exception.
 *
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
1fffa47a:	4b2a      	ldr	r3, [pc, #168]	; (1fffa524 <z_cstart+0xb4>)
  \details Assigns the given value to the Main Stack Pointer (MSP).
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
1fffa47c:	f383 8808 	msr	MSP, r3
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
1fffa480:	4c29      	ldr	r4, [pc, #164]	; (1fffa528 <z_cstart+0xb8>)

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
1fffa482:	4e2a      	ldr	r6, [pc, #168]	; (1fffa52c <z_cstart+0xbc>)
1fffa484:	6963      	ldr	r3, [r4, #20]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
1fffa486:	4f2a      	ldr	r7, [pc, #168]	; (1fffa530 <z_cstart+0xc0>)
1fffa488:	f443 7300 	orr.w	r3, r3, #512	; 0x200
1fffa48c:	6163      	str	r3, [r4, #20]
1fffa48e:	2500      	movs	r5, #0
1fffa490:	23f0      	movs	r3, #240	; 0xf0
1fffa492:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
1fffa496:	77e5      	strb	r5, [r4, #31]
1fffa498:	7625      	strb	r5, [r4, #24]
1fffa49a:	7665      	strb	r5, [r4, #25]
1fffa49c:	76a5      	strb	r5, [r4, #26]
1fffa49e:	f884 5020 	strb.w	r5, [r4, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
1fffa4a2:	6a63      	ldr	r3, [r4, #36]	; 0x24
1fffa4a4:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
1fffa4a8:	6263      	str	r3, [r4, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
1fffa4aa:	f7ff f8e7 	bl	1fff967c <z_arm_fault_init>
	z_arm_cpu_idle_init();
1fffa4ae:	f7fe febd 	bl	1fff922c <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
1fffa4b2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
1fffa4b6:	62a3      	str	r3, [r4, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
1fffa4b8:	62e3      	str	r3, [r4, #44]	; 0x2c
	k_thread_system_pool_assign(dummy_thread);
1fffa4ba:	ac06      	add	r4, sp, #24
	dummy_thread->base.user_options = K_ESSENTIAL;
1fffa4bc:	f240 1301 	movw	r3, #257	; 0x101
	k_thread_system_pool_assign(dummy_thread);
1fffa4c0:	4620      	mov	r0, r4
	dummy_thread->base.user_options = K_ESSENTIAL;
1fffa4c2:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	k_thread_system_pool_assign(dummy_thread);
1fffa4c6:	f000 fda9 	bl	1fffb01c <k_thread_system_pool_assign>
	_current_cpu->current = dummy_thread;
1fffa4ca:	60b4      	str	r4, [r6, #8]
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
1fffa4cc:	f002 f915 	bl	1fffc6fa <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
1fffa4d0:	2001      	movs	r0, #1
1fffa4d2:	f7ff ff51 	bl	1fffa378 <z_sys_init_run_level>
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
1fffa4d6:	2002      	movs	r0, #2
	_kernel.ready_q.cache = &z_main_thread;
1fffa4d8:	4c16      	ldr	r4, [pc, #88]	; (1fffa534 <z_cstart+0xc4>)
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
1fffa4da:	f7ff ff4d 	bl	1fffa378 <z_sys_init_run_level>
	z_sched_init();
1fffa4de:	f000 fb2f 	bl	1fffab40 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
1fffa4e2:	4b15      	ldr	r3, [pc, #84]	; (1fffa538 <z_cstart+0xc8>)
	_kernel.ready_q.cache = &z_main_thread;
1fffa4e4:	6174      	str	r4, [r6, #20]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
1fffa4e6:	9305      	str	r3, [sp, #20]
1fffa4e8:	2301      	movs	r3, #1
1fffa4ea:	4914      	ldr	r1, [pc, #80]	; (1fffa53c <z_cstart+0xcc>)
1fffa4ec:	9500      	str	r5, [sp, #0]
1fffa4ee:	e9cd 5303 	strd	r5, r3, [sp, #12]
1fffa4f2:	f44f 6280 	mov.w	r2, #1024	; 0x400
1fffa4f6:	463b      	mov	r3, r7
1fffa4f8:	e9cd 5501 	strd	r5, r5, [sp, #4]
1fffa4fc:	4620      	mov	r0, r4
1fffa4fe:	f000 f81f 	bl	1fffa540 <z_setup_new_thread>
1fffa502:	7b62      	ldrb	r2, [r4, #13]
1fffa504:	4606      	mov	r6, r0
1fffa506:	f022 0204 	bic.w	r2, r2, #4
	z_ready_thread(&z_main_thread);
1fffa50a:	4620      	mov	r0, r4
1fffa50c:	7362      	strb	r2, [r4, #13]
1fffa50e:	f002 f97d 	bl	1fffc80c <z_ready_thread>
	z_init_cpu(0);
1fffa512:	4628      	mov	r0, r5
1fffa514:	f7ff ff78 	bl	1fffa408 <z_init_cpu>
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
1fffa518:	463a      	mov	r2, r7
1fffa51a:	4631      	mov	r1, r6
1fffa51c:	4620      	mov	r0, r4
1fffa51e:	f7fe ff51 	bl	1fff93c4 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
1fffa522:	bf00      	nop
1fffa524:	200019f0 	.word	0x200019f0
1fffa528:	e000ed00 	.word	0xe000ed00
1fffa52c:	200005a8 	.word	0x200005a8
1fffa530:	1fffa3bd 	.word	0x1fffa3bd
1fffa534:	20000370 	.word	0x20000370
1fffa538:	1fffd5a2 	.word	0x1fffd5a2
1fffa53c:	20001b30 	.word	0x20001b30

1fffa540 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
1fffa540:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
1fffa542:	9e0c      	ldr	r6, [sp, #48]	; 0x30
1fffa544:	7306      	strb	r6, [r0, #12]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
1fffa546:	3207      	adds	r2, #7
	thread_base->thread_state = (uint8_t)initial_state;
1fffa548:	2604      	movs	r6, #4
1fffa54a:	7346      	strb	r6, [r0, #13]
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
1fffa54c:	f100 0558 	add.w	r5, r0, #88	; 0x58

	thread_base->prio = priority;
1fffa550:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
1fffa552:	7386      	strb	r6, [r0, #14]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
1fffa554:	f022 0207 	bic.w	r2, r2, #7
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
1fffa558:	e9c0 5516 	strd	r5, r5, [r0, #88]	; 0x58
	stack_ptr = (char *)stack + stack_obj_size;
1fffa55c:	188e      	adds	r6, r1, r2
	thread_base->pended_on = NULL;
1fffa55e:	2500      	movs	r5, #0
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
1fffa560:	9a0a      	ldr	r2, [sp, #40]	; 0x28
	thread_base->pended_on = NULL;
1fffa562:	6085      	str	r5, [r0, #8]
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
1fffa564:	e9c0 5506 	strd	r5, r5, [r0, #24]

	thread_base->sched_locked = 0U;
1fffa568:	73c5      	strb	r5, [r0, #15]
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
1fffa56a:	9202      	str	r2, [sp, #8]
1fffa56c:	9a09      	ldr	r2, [sp, #36]	; 0x24
1fffa56e:	9201      	str	r2, [sp, #4]
1fffa570:	9a08      	ldr	r2, [sp, #32]
1fffa572:	9200      	str	r2, [sp, #0]
1fffa574:	4632      	mov	r2, r6
{
1fffa576:	4604      	mov	r4, r0
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
1fffa578:	f7fe ff08 	bl	1fff938c <arch_new_thread>
	if (!_current) {
1fffa57c:	4b04      	ldr	r3, [pc, #16]	; (1fffa590 <z_setup_new_thread+0x50>)
	new_thread->init_data = NULL;
1fffa57e:	6565      	str	r5, [r4, #84]	; 0x54
	if (!_current) {
1fffa580:	689b      	ldr	r3, [r3, #8]
1fffa582:	b103      	cbz	r3, 1fffa586 <z_setup_new_thread+0x46>
	new_thread->resource_pool = _current->resource_pool;
1fffa584:	6e5b      	ldr	r3, [r3, #100]	; 0x64
	return stack_ptr;
1fffa586:	6663      	str	r3, [r4, #100]	; 0x64
}
1fffa588:	4630      	mov	r0, r6
1fffa58a:	b004      	add	sp, #16
1fffa58c:	bd70      	pop	{r4, r5, r6, pc}
1fffa58e:	bf00      	nop
1fffa590:	200005a8 	.word	0x200005a8

1fffa594 <z_impl_k_thread_create>:
{
1fffa594:	b5f0      	push	{r4, r5, r6, r7, lr}
1fffa596:	b087      	sub	sp, #28
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
1fffa598:	2500      	movs	r5, #0
1fffa59a:	9505      	str	r5, [sp, #20]
1fffa59c:	9d10      	ldr	r5, [sp, #64]	; 0x40
1fffa59e:	9504      	str	r5, [sp, #16]
1fffa5a0:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
1fffa5a2:	9503      	str	r5, [sp, #12]
1fffa5a4:	9d0e      	ldr	r5, [sp, #56]	; 0x38
1fffa5a6:	9502      	str	r5, [sp, #8]
{
1fffa5a8:	e9dd 7612 	ldrd	r7, r6, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
1fffa5ac:	9d0d      	ldr	r5, [sp, #52]	; 0x34
1fffa5ae:	9501      	str	r5, [sp, #4]
1fffa5b0:	9d0c      	ldr	r5, [sp, #48]	; 0x30
1fffa5b2:	9500      	str	r5, [sp, #0]
{
1fffa5b4:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
1fffa5b6:	f7ff ffc3 	bl	1fffa540 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
1fffa5ba:	f1b6 3fff 	cmp.w	r6, #4294967295	; 0xffffffff
1fffa5be:	bf08      	it	eq
1fffa5c0:	f1b7 3fff 	cmpeq.w	r7, #4294967295	; 0xffffffff
1fffa5c4:	d005      	beq.n	1fffa5d2 <z_impl_k_thread_create+0x3e>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
1fffa5c6:	ea56 0307 	orrs.w	r3, r6, r7
1fffa5ca:	d105      	bne.n	1fffa5d8 <z_impl_k_thread_create+0x44>
	z_sched_start(thread);
1fffa5cc:	4620      	mov	r0, r4
1fffa5ce:	f000 fa37 	bl	1fffaa40 <z_sched_start>
}
1fffa5d2:	4620      	mov	r0, r4
1fffa5d4:	b007      	add	sp, #28
1fffa5d6:	bdf0      	pop	{r4, r5, r6, r7, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
1fffa5d8:	4903      	ldr	r1, [pc, #12]	; (1fffa5e8 <z_impl_k_thread_create+0x54>)
1fffa5da:	463a      	mov	r2, r7
1fffa5dc:	4633      	mov	r3, r6
1fffa5de:	f104 0018 	add.w	r0, r4, #24
1fffa5e2:	f000 fc19 	bl	1fffae18 <z_add_timeout>
1fffa5e6:	e7f4      	b.n	1fffa5d2 <z_impl_k_thread_create+0x3e>
1fffa5e8:	1fffc871 	.word	0x1fffc871

1fffa5ec <z_init_static_threads>:
{
1fffa5ec:	b5f0      	push	{r4, r5, r6, r7, lr}
1fffa5ee:	4c22      	ldr	r4, [pc, #136]	; (1fffa678 <z_init_static_threads+0x8c>)
	_FOREACH_STATIC_THREAD(thread_data) {
1fffa5f0:	4d22      	ldr	r5, [pc, #136]	; (1fffa67c <z_init_static_threads+0x90>)
{
1fffa5f2:	b087      	sub	sp, #28
1fffa5f4:	4626      	mov	r6, r4
	_FOREACH_STATIC_THREAD(thread_data) {
1fffa5f6:	42ae      	cmp	r6, r5
1fffa5f8:	f104 042c 	add.w	r4, r4, #44	; 0x2c
1fffa5fc:	d30b      	bcc.n	1fffa616 <z_init_static_threads+0x2a>
	k_sched_lock();
1fffa5fe:	f000 fa6f 	bl	1fffaae0 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
1fffa602:	4c1d      	ldr	r4, [pc, #116]	; (1fffa678 <z_init_static_threads+0x8c>)
1fffa604:	4f1e      	ldr	r7, [pc, #120]	; (1fffa680 <z_init_static_threads+0x94>)
		}
	} else if (mul_ratio) {
		if (result32) {
			return ((uint32_t)t) * (to_hz / from_hz);
		} else {
			return t * ((uint64_t)to_hz / from_hz);
1fffa606:	260a      	movs	r6, #10
1fffa608:	42ac      	cmp	r4, r5
1fffa60a:	d320      	bcc.n	1fffa64e <z_init_static_threads+0x62>
}
1fffa60c:	b007      	add	sp, #28
1fffa60e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	k_sched_unlock();
1fffa612:	f000 ba79 	b.w	1fffab08 <k_sched_unlock>
		z_setup_new_thread(
1fffa616:	f854 3c04 	ldr.w	r3, [r4, #-4]
1fffa61a:	9305      	str	r3, [sp, #20]
1fffa61c:	f854 3c0c 	ldr.w	r3, [r4, #-12]
1fffa620:	9304      	str	r3, [sp, #16]
1fffa622:	f854 3c10 	ldr.w	r3, [r4, #-16]
1fffa626:	9303      	str	r3, [sp, #12]
1fffa628:	f854 3c14 	ldr.w	r3, [r4, #-20]
1fffa62c:	9302      	str	r3, [sp, #8]
1fffa62e:	f854 3c18 	ldr.w	r3, [r4, #-24]
1fffa632:	9301      	str	r3, [sp, #4]
1fffa634:	f854 3c1c 	ldr.w	r3, [r4, #-28]
1fffa638:	9300      	str	r3, [sp, #0]
1fffa63a:	e954 2309 	ldrd	r2, r3, [r4, #-36]	; 0x24
1fffa63e:	e954 010b 	ldrd	r0, r1, [r4, #-44]	; 0x2c
1fffa642:	f7ff ff7d 	bl	1fffa540 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
1fffa646:	f854 3c2c 	ldr.w	r3, [r4, #-44]
1fffa64a:	655e      	str	r6, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
1fffa64c:	e7d2      	b.n	1fffa5f4 <z_init_static_threads+0x8>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
1fffa64e:	6a62      	ldr	r2, [r4, #36]	; 0x24
1fffa650:	1c53      	adds	r3, r2, #1
1fffa652:	d009      	beq.n	1fffa668 <z_init_static_threads+0x7c>
					    K_MSEC(thread_data->init_delay));
1fffa654:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
1fffa658:	fb82 2306 	smull	r2, r3, r2, r6
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
1fffa65c:	ea52 0103 	orrs.w	r1, r2, r3
			schedule_new_thread(thread_data->init_thread,
1fffa660:	6820      	ldr	r0, [r4, #0]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
1fffa662:	d103      	bne.n	1fffa66c <z_init_static_threads+0x80>
	z_sched_start(thread);
1fffa664:	f000 f9ec 	bl	1fffaa40 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
1fffa668:	342c      	adds	r4, #44	; 0x2c
1fffa66a:	e7cd      	b.n	1fffa608 <z_init_static_threads+0x1c>
1fffa66c:	4639      	mov	r1, r7
1fffa66e:	3018      	adds	r0, #24
1fffa670:	f000 fbd2 	bl	1fffae18 <z_add_timeout>
1fffa674:	e7f8      	b.n	1fffa668 <z_init_static_threads+0x7c>
1fffa676:	bf00      	nop
1fffa678:	1fffcf74 	.word	0x1fffcf74
1fffa67c:	1fffcf74 	.word	0x1fffcf74
1fffa680:	1fffc871 	.word	0x1fffc871

1fffa684 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
1fffa684:	b538      	push	{r3, r4, r5, lr}
1fffa686:	4604      	mov	r4, r0
	__asm__ volatile(
1fffa688:	f04f 0310 	mov.w	r3, #16
1fffa68c:	f3ef 8511 	mrs	r5, BASEPRI
1fffa690:	f383 8812 	msr	BASEPRI_MAX, r3
1fffa694:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
1fffa698:	f002 f8ee 	bl	1fffc878 <z_unpend_first_thread>

	if (thread != NULL) {
1fffa69c:	b148      	cbz	r0, 1fffa6b2 <z_impl_k_sem_give+0x2e>
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
1fffa69e:	2200      	movs	r2, #0
1fffa6a0:	66c2      	str	r2, [r0, #108]	; 0x6c
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
1fffa6a2:	f002 f8b3 	bl	1fffc80c <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
1fffa6a6:	4629      	mov	r1, r5
1fffa6a8:	4805      	ldr	r0, [pc, #20]	; (1fffa6c0 <z_impl_k_sem_give+0x3c>)

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
1fffa6aa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
1fffa6ae:	f000 b9b5 	b.w	1fffaa1c <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
1fffa6b2:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
1fffa6b6:	429a      	cmp	r2, r3
1fffa6b8:	bf18      	it	ne
1fffa6ba:	3301      	addne	r3, #1
1fffa6bc:	60a3      	str	r3, [r4, #8]
}
1fffa6be:	e7f2      	b.n	1fffa6a6 <z_impl_k_sem_give+0x22>
1fffa6c0:	200009ee 	.word	0x200009ee

1fffa6c4 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
1fffa6c4:	b513      	push	{r0, r1, r4, lr}
1fffa6c6:	f04f 0410 	mov.w	r4, #16
1fffa6ca:	f3ef 8111 	mrs	r1, BASEPRI
1fffa6ce:	f384 8812 	msr	BASEPRI_MAX, r4
1fffa6d2:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
1fffa6d6:	6884      	ldr	r4, [r0, #8]
1fffa6d8:	b144      	cbz	r4, 1fffa6ec <z_impl_k_sem_take+0x28>
		sem->count--;
1fffa6da:	3c01      	subs	r4, #1
1fffa6dc:	6084      	str	r4, [r0, #8]
	__asm__ volatile(
1fffa6de:	f381 8811 	msr	BASEPRI, r1
1fffa6e2:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
1fffa6e6:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
1fffa6e8:	b002      	add	sp, #8
1fffa6ea:	bd10      	pop	{r4, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
1fffa6ec:	ea52 0403 	orrs.w	r4, r2, r3
1fffa6f0:	d106      	bne.n	1fffa700 <z_impl_k_sem_take+0x3c>
1fffa6f2:	f381 8811 	msr	BASEPRI, r1
1fffa6f6:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
1fffa6fa:	f06f 000f 	mvn.w	r0, #15
1fffa6fe:	e7f3      	b.n	1fffa6e8 <z_impl_k_sem_take+0x24>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
1fffa700:	e9cd 2300 	strd	r2, r3, [sp]
1fffa704:	4602      	mov	r2, r0
1fffa706:	4802      	ldr	r0, [pc, #8]	; (1fffa710 <z_impl_k_sem_take+0x4c>)
1fffa708:	f000 f96a 	bl	1fffa9e0 <z_pend_curr>
	return ret;
1fffa70c:	e7ec      	b.n	1fffa6e8 <z_impl_k_sem_take+0x24>
1fffa70e:	bf00      	nop
1fffa710:	200009ee 	.word	0x200009ee

1fffa714 <sliceable>:
{
	bool ret = is_preempt(thread)
		&& slice_time(thread) != 0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
		&& !z_is_thread_prevented_from_running(thread)
		&& !z_is_idle_thread_object(thread);
1fffa714:	89c3      	ldrh	r3, [r0, #14]
1fffa716:	2b7f      	cmp	r3, #127	; 0x7f
1fffa718:	d812      	bhi.n	1fffa740 <sliceable+0x2c>
	int ret = slice_ticks;
1fffa71a:	4b0a      	ldr	r3, [pc, #40]	; (1fffa744 <sliceable+0x30>)
1fffa71c:	681b      	ldr	r3, [r3, #0]
		&& slice_time(thread) != 0
1fffa71e:	b163      	cbz	r3, 1fffa73a <sliceable+0x26>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
1fffa720:	4b09      	ldr	r3, [pc, #36]	; (1fffa748 <sliceable+0x34>)
1fffa722:	f990 200e 	ldrsb.w	r2, [r0, #14]
1fffa726:	681b      	ldr	r3, [r3, #0]
1fffa728:	429a      	cmp	r2, r3
1fffa72a:	db09      	blt.n	1fffa740 <sliceable+0x2c>
		&& !z_is_thread_prevented_from_running(thread)
1fffa72c:	7b43      	ldrb	r3, [r0, #13]
1fffa72e:	06db      	lsls	r3, r3, #27
1fffa730:	d106      	bne.n	1fffa740 <sliceable+0x2c>
		&& !z_is_idle_thread_object(thread);
1fffa732:	4b06      	ldr	r3, [pc, #24]	; (1fffa74c <sliceable+0x38>)
1fffa734:	1ac3      	subs	r3, r0, r3
1fffa736:	bf18      	it	ne
1fffa738:	2301      	movne	r3, #1
#ifdef CONFIG_TIMESLICE_PER_THREAD
	ret |= thread->base.slice_ticks != 0;
#endif

	return ret;
}
1fffa73a:	f003 0001 	and.w	r0, r3, #1
1fffa73e:	4770      	bx	lr
		&& !z_is_idle_thread_object(thread);
1fffa740:	2300      	movs	r3, #0
1fffa742:	e7fa      	b.n	1fffa73a <sliceable+0x26>
1fffa744:	200005d0 	.word	0x200005d0
1fffa748:	200005cc 	.word	0x200005cc
1fffa74c:	20000300 	.word	0x20000300

1fffa750 <slice_timeout>:

static void slice_timeout(struct _timeout *t)
{
	int cpu = ARRAY_INDEX(slice_timeouts, t);
1fffa750:	4b04      	ldr	r3, [pc, #16]	; (1fffa764 <slice_timeout+0x14>)
1fffa752:	1ac0      	subs	r0, r0, r3
1fffa754:	4b04      	ldr	r3, [pc, #16]	; (1fffa768 <slice_timeout+0x18>)
1fffa756:	10c0      	asrs	r0, r0, #3
1fffa758:	4358      	muls	r0, r3

	slice_expired[cpu] = true;
1fffa75a:	4b04      	ldr	r3, [pc, #16]	; (1fffa76c <slice_timeout+0x1c>)
1fffa75c:	2201      	movs	r2, #1
1fffa75e:	541a      	strb	r2, [r3, r0]
	 * the specific core, but that's not part of the API yet.
	 */
	if (IS_ENABLED(CONFIG_SMP) && cpu != _current_cpu->id) {
		flag_ipi();
	}
}
1fffa760:	4770      	bx	lr
1fffa762:	bf00      	nop
1fffa764:	200003e0 	.word	0x200003e0
1fffa768:	aaaaaaab 	.word	0xaaaaaaab
1fffa76c:	200009ee 	.word	0x200009ee

1fffa770 <z_reset_time_slice>:

void z_reset_time_slice(struct k_thread *curr)
{
1fffa770:	b570      	push	{r4, r5, r6, lr}
	int cpu = _current_cpu->id;
1fffa772:	4b0e      	ldr	r3, [pc, #56]	; (1fffa7ac <z_reset_time_slice+0x3c>)

	z_abort_timeout(&slice_timeouts[cpu]);
1fffa774:	4c0e      	ldr	r4, [pc, #56]	; (1fffa7b0 <z_reset_time_slice+0x40>)
	int cpu = _current_cpu->id;
1fffa776:	7c1e      	ldrb	r6, [r3, #16]
	z_abort_timeout(&slice_timeouts[cpu]);
1fffa778:	eb06 0346 	add.w	r3, r6, r6, lsl #1
1fffa77c:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
{
1fffa780:	4605      	mov	r5, r0
	z_abort_timeout(&slice_timeouts[cpu]);
1fffa782:	4620      	mov	r0, r4
1fffa784:	f002 f8d2 	bl	1fffc92c <z_abort_timeout>
	slice_expired[cpu] = false;
1fffa788:	4b0a      	ldr	r3, [pc, #40]	; (1fffa7b4 <z_reset_time_slice+0x44>)
1fffa78a:	2200      	movs	r2, #0
	if (sliceable(curr)) {
1fffa78c:	4628      	mov	r0, r5
	slice_expired[cpu] = false;
1fffa78e:	559a      	strb	r2, [r3, r6]
	if (sliceable(curr)) {
1fffa790:	f7ff ffc0 	bl	1fffa714 <sliceable>
1fffa794:	b148      	cbz	r0, 1fffa7aa <z_reset_time_slice+0x3a>
	int ret = slice_ticks;
1fffa796:	4b08      	ldr	r3, [pc, #32]	; (1fffa7b8 <z_reset_time_slice+0x48>)
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
1fffa798:	4908      	ldr	r1, [pc, #32]	; (1fffa7bc <z_reset_time_slice+0x4c>)
			      K_TICKS(slice_time(curr) - 1));
1fffa79a:	681a      	ldr	r2, [r3, #0]
1fffa79c:	3a01      	subs	r2, #1
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
1fffa79e:	4620      	mov	r0, r4
1fffa7a0:	17d3      	asrs	r3, r2, #31
	}
}
1fffa7a2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
1fffa7a6:	f000 bb37 	b.w	1fffae18 <z_add_timeout>
}
1fffa7aa:	bd70      	pop	{r4, r5, r6, pc}
1fffa7ac:	200005a8 	.word	0x200005a8
1fffa7b0:	200003e0 	.word	0x200003e0
1fffa7b4:	200009ee 	.word	0x200009ee
1fffa7b8:	200005d0 	.word	0x200005d0
1fffa7bc:	1fffa751 	.word	0x1fffa751

1fffa7c0 <update_cache>:
	}
#endif
}

static void update_cache(int preempt_ok)
{
1fffa7c0:	b538      	push	{r3, r4, r5, lr}
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
1fffa7c2:	4d0d      	ldr	r5, [pc, #52]	; (1fffa7f8 <update_cache+0x38>)
1fffa7c4:	462b      	mov	r3, r5
1fffa7c6:	f853 4f18 	ldr.w	r4, [r3, #24]!
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fffa7ca:	429c      	cmp	r4, r3
1fffa7cc:	d000      	beq.n	1fffa7d0 <update_cache+0x10>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
1fffa7ce:	b904      	cbnz	r4, 1fffa7d2 <update_cache+0x12>
1fffa7d0:	68ec      	ldr	r4, [r5, #12]
	if (z_is_thread_prevented_from_running(_current)) {
1fffa7d2:	68ab      	ldr	r3, [r5, #8]
	if (preempt_ok != 0) {
1fffa7d4:	b938      	cbnz	r0, 1fffa7e6 <update_cache+0x26>
	if (z_is_thread_prevented_from_running(_current)) {
1fffa7d6:	7b5a      	ldrb	r2, [r3, #13]
1fffa7d8:	06d2      	lsls	r2, r2, #27
1fffa7da:	d104      	bne.n	1fffa7e6 <update_cache+0x26>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
1fffa7dc:	69a2      	ldr	r2, [r4, #24]
1fffa7de:	b912      	cbnz	r2, 1fffa7e6 <update_cache+0x26>
	if (is_preempt(_current) || is_metairq(thread)) {
1fffa7e0:	89da      	ldrh	r2, [r3, #14]
1fffa7e2:	2a7f      	cmp	r2, #127	; 0x7f
1fffa7e4:	d805      	bhi.n	1fffa7f2 <update_cache+0x32>
#ifndef CONFIG_SMP
	struct k_thread *thread = next_up();

	if (should_preempt(thread, preempt_ok)) {
#ifdef CONFIG_TIMESLICING
		if (thread != _current) {
1fffa7e6:	429c      	cmp	r4, r3
1fffa7e8:	d002      	beq.n	1fffa7f0 <update_cache+0x30>
			z_reset_time_slice(thread);
1fffa7ea:	4620      	mov	r0, r4
1fffa7ec:	f7ff ffc0 	bl	1fffa770 <z_reset_time_slice>
		}
#endif
		update_metairq_preempt(thread);
		_kernel.ready_q.cache = thread;
1fffa7f0:	4623      	mov	r3, r4
1fffa7f2:	616b      	str	r3, [r5, #20]
	 * thread because if the thread gets preempted for whatever
	 * reason the scheduler will make the same decision anyway.
	 */
	_current_cpu->swap_ok = preempt_ok;
#endif
}
1fffa7f4:	bd38      	pop	{r3, r4, r5, pc}
1fffa7f6:	bf00      	nop
1fffa7f8:	200005a8 	.word	0x200005a8

1fffa7fc <move_thread_to_end_of_prio_q>:
{
1fffa7fc:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
1fffa7fe:	f990 200d 	ldrsb.w	r2, [r0, #13]
	return (thread->base.thread_state & state) != 0U;
1fffa802:	7b43      	ldrb	r3, [r0, #13]
1fffa804:	2a00      	cmp	r2, #0
{
1fffa806:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
1fffa808:	da04      	bge.n	1fffa814 <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
1fffa80a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
1fffa80e:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
1fffa810:	f001 ffc2 	bl	1fffc798 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
1fffa814:	7b4b      	ldrb	r3, [r1, #13]
	return list->head == list;
1fffa816:	4a15      	ldr	r2, [pc, #84]	; (1fffa86c <move_thread_to_end_of_prio_q+0x70>)
1fffa818:	f063 037f 	orn	r3, r3, #127	; 0x7f
1fffa81c:	4610      	mov	r0, r2
1fffa81e:	734b      	strb	r3, [r1, #13]
1fffa820:	f850 3f18 	ldr.w	r3, [r0, #24]!
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
1fffa824:	69d4      	ldr	r4, [r2, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fffa826:	4283      	cmp	r3, r0
1fffa828:	bf08      	it	eq
1fffa82a:	2300      	moveq	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
1fffa82c:	b923      	cbnz	r3, 1fffa838 <move_thread_to_end_of_prio_q+0x3c>
static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	sys_dnode_t *const tail = list->tail;

	node->next = list;
	node->prev = tail;
1fffa82e:	e9c1 0400 	strd	r0, r4, [r1]

	tail->next = node;
1fffa832:	6021      	str	r1, [r4, #0]
	list->tail = node;
1fffa834:	61d1      	str	r1, [r2, #28]
}
1fffa836:	e00c      	b.n	1fffa852 <move_thread_to_end_of_prio_q+0x56>
	int32_t b1 = thread_1->base.prio;
1fffa838:	f991 500e 	ldrsb.w	r5, [r1, #14]
	int32_t b2 = thread_2->base.prio;
1fffa83c:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
1fffa840:	42b5      	cmp	r5, r6
1fffa842:	d00e      	beq.n	1fffa862 <move_thread_to_end_of_prio_q+0x66>
		if (z_sched_prio_cmp(thread, t) > 0) {
1fffa844:	42ae      	cmp	r6, r5
1fffa846:	dd0c      	ble.n	1fffa862 <move_thread_to_end_of_prio_q+0x66>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
1fffa848:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
1fffa84a:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
1fffa84e:	6001      	str	r1, [r0, #0]
	successor->prev = node;
1fffa850:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
1fffa852:	6890      	ldr	r0, [r2, #8]
1fffa854:	1a43      	subs	r3, r0, r1
1fffa856:	4258      	negs	r0, r3
}
1fffa858:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
1fffa85c:	4158      	adcs	r0, r3
1fffa85e:	f7ff bfaf 	b.w	1fffa7c0 <update_cache>
	return (node == list->tail) ? NULL : node->next;
1fffa862:	429c      	cmp	r4, r3
1fffa864:	d0e3      	beq.n	1fffa82e <move_thread_to_end_of_prio_q+0x32>
1fffa866:	681b      	ldr	r3, [r3, #0]
1fffa868:	e7e0      	b.n	1fffa82c <move_thread_to_end_of_prio_q+0x30>
1fffa86a:	bf00      	nop
1fffa86c:	200005a8 	.word	0x200005a8

1fffa870 <ready_thread>:
{
1fffa870:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
1fffa872:	f990 300d 	ldrsb.w	r3, [r0, #13]
1fffa876:	7b42      	ldrb	r2, [r0, #13]
1fffa878:	2b00      	cmp	r3, #0
1fffa87a:	db29      	blt.n	1fffa8d0 <ready_thread+0x60>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
1fffa87c:	06d3      	lsls	r3, r2, #27
1fffa87e:	d127      	bne.n	1fffa8d0 <ready_thread+0x60>
	return node->next != NULL;
1fffa880:	6983      	ldr	r3, [r0, #24]
1fffa882:	bb2b      	cbnz	r3, 1fffa8d0 <ready_thread+0x60>
	return list->head == list;
1fffa884:	4913      	ldr	r1, [pc, #76]	; (1fffa8d4 <ready_thread+0x64>)
	thread->base.thread_state |= _THREAD_QUEUED;
1fffa886:	f062 027f 	orn	r2, r2, #127	; 0x7f
1fffa88a:	7342      	strb	r2, [r0, #13]
1fffa88c:	460a      	mov	r2, r1
1fffa88e:	f852 4f18 	ldr.w	r4, [r2, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fffa892:	4294      	cmp	r4, r2
1fffa894:	bf18      	it	ne
1fffa896:	4623      	movne	r3, r4
	return (node == list->tail) ? NULL : node->next;
1fffa898:	69cc      	ldr	r4, [r1, #28]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
1fffa89a:	b923      	cbnz	r3, 1fffa8a6 <ready_thread+0x36>
	node->prev = tail;
1fffa89c:	e9c0 2400 	strd	r2, r4, [r0]
	tail->next = node;
1fffa8a0:	6020      	str	r0, [r4, #0]
	list->tail = node;
1fffa8a2:	61c8      	str	r0, [r1, #28]
}
1fffa8a4:	e00c      	b.n	1fffa8c0 <ready_thread+0x50>
	int32_t b1 = thread_1->base.prio;
1fffa8a6:	f990 500e 	ldrsb.w	r5, [r0, #14]
	int32_t b2 = thread_2->base.prio;
1fffa8aa:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
1fffa8ae:	42b5      	cmp	r5, r6
1fffa8b0:	d00a      	beq.n	1fffa8c8 <ready_thread+0x58>
		if (z_sched_prio_cmp(thread, t) > 0) {
1fffa8b2:	42ae      	cmp	r6, r5
1fffa8b4:	dd08      	ble.n	1fffa8c8 <ready_thread+0x58>
	sys_dnode_t *const prev = successor->prev;
1fffa8b6:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
1fffa8b8:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
1fffa8bc:	6010      	str	r0, [r2, #0]
	successor->prev = node;
1fffa8be:	6058      	str	r0, [r3, #4]
}
1fffa8c0:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
1fffa8c2:	2000      	movs	r0, #0
1fffa8c4:	f7ff bf7c 	b.w	1fffa7c0 <update_cache>
	return (node == list->tail) ? NULL : node->next;
1fffa8c8:	42a3      	cmp	r3, r4
1fffa8ca:	d0e7      	beq.n	1fffa89c <ready_thread+0x2c>
1fffa8cc:	681b      	ldr	r3, [r3, #0]
1fffa8ce:	e7e4      	b.n	1fffa89a <ready_thread+0x2a>
}
1fffa8d0:	bc70      	pop	{r4, r5, r6}
1fffa8d2:	4770      	bx	lr
1fffa8d4:	200005a8 	.word	0x200005a8

1fffa8d8 <unready_thread>:
{
1fffa8d8:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
1fffa8da:	f990 200d 	ldrsb.w	r2, [r0, #13]
	return (thread->base.thread_state & state) != 0U;
1fffa8de:	7b43      	ldrb	r3, [r0, #13]
1fffa8e0:	2a00      	cmp	r2, #0
{
1fffa8e2:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
1fffa8e4:	da04      	bge.n	1fffa8f0 <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
1fffa8e6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
1fffa8ea:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
1fffa8ec:	f001 ff54 	bl	1fffc798 <sys_dlist_remove>
	update_cache(thread == _current);
1fffa8f0:	4b04      	ldr	r3, [pc, #16]	; (1fffa904 <unready_thread+0x2c>)
1fffa8f2:	6898      	ldr	r0, [r3, #8]
1fffa8f4:	1a43      	subs	r3, r0, r1
1fffa8f6:	4258      	negs	r0, r3
1fffa8f8:	4158      	adcs	r0, r3
}
1fffa8fa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
1fffa8fe:	f7ff bf5f 	b.w	1fffa7c0 <update_cache>
1fffa902:	bf00      	nop
1fffa904:	200005a8 	.word	0x200005a8

1fffa908 <pend_locked>:
{
1fffa908:	b570      	push	{r4, r5, r6, lr}
1fffa90a:	4615      	mov	r5, r2
1fffa90c:	461c      	mov	r4, r3
1fffa90e:	4606      	mov	r6, r0
	add_to_waitq_locked(thread, wait_q);
1fffa910:	f001 ff54 	bl	1fffc7bc <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
1fffa914:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
1fffa918:	bf08      	it	eq
1fffa91a:	f1b5 3fff 	cmpeq.w	r5, #4294967295	; 0xffffffff
1fffa91e:	d008      	beq.n	1fffa932 <pend_locked+0x2a>
1fffa920:	462a      	mov	r2, r5
1fffa922:	4623      	mov	r3, r4
1fffa924:	f106 0018 	add.w	r0, r6, #24
1fffa928:	4902      	ldr	r1, [pc, #8]	; (1fffa934 <pend_locked+0x2c>)
}
1fffa92a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
1fffa92e:	f000 ba73 	b.w	1fffae18 <z_add_timeout>
1fffa932:	bd70      	pop	{r4, r5, r6, pc}
1fffa934:	1fffc871 	.word	0x1fffc871

1fffa938 <k_sched_time_slice_set>:
{
1fffa938:	b510      	push	{r4, lr}
	__asm__ volatile(
1fffa93a:	f04f 0310 	mov.w	r3, #16
1fffa93e:	f3ef 8411 	mrs	r4, BASEPRI
1fffa942:	f383 8812 	msr	BASEPRI_MAX, r3
1fffa946:	f3bf 8f6f 	isb	sy
			return ((uint32_t)t) * (to_hz / from_hz);
1fffa94a:	230a      	movs	r3, #10
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
1fffa94c:	2800      	cmp	r0, #0
1fffa94e:	fb00 f303 	mul.w	r3, r0, r3
1fffa952:	dd02      	ble.n	1fffa95a <k_sched_time_slice_set+0x22>
			slice_ticks = MAX(2, slice_ticks);
1fffa954:	2b02      	cmp	r3, #2
1fffa956:	bfb8      	it	lt
1fffa958:	2302      	movlt	r3, #2
		slice_ticks = k_ms_to_ticks_ceil32(slice);
1fffa95a:	4a06      	ldr	r2, [pc, #24]	; (1fffa974 <k_sched_time_slice_set+0x3c>)
1fffa95c:	6013      	str	r3, [r2, #0]
		slice_max_prio = prio;
1fffa95e:	4b06      	ldr	r3, [pc, #24]	; (1fffa978 <k_sched_time_slice_set+0x40>)
1fffa960:	6019      	str	r1, [r3, #0]
		z_reset_time_slice(_current);
1fffa962:	4b06      	ldr	r3, [pc, #24]	; (1fffa97c <k_sched_time_slice_set+0x44>)
1fffa964:	6898      	ldr	r0, [r3, #8]
1fffa966:	f7ff ff03 	bl	1fffa770 <z_reset_time_slice>
	__asm__ volatile(
1fffa96a:	f384 8811 	msr	BASEPRI, r4
1fffa96e:	f3bf 8f6f 	isb	sy
}
1fffa972:	bd10      	pop	{r4, pc}
1fffa974:	200005d0 	.word	0x200005d0
1fffa978:	200005cc 	.word	0x200005cc
1fffa97c:	200005a8 	.word	0x200005a8

1fffa980 <z_time_slice>:
{
1fffa980:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
1fffa982:	f04f 0310 	mov.w	r3, #16
1fffa986:	f3ef 8511 	mrs	r5, BASEPRI
1fffa98a:	f383 8812 	msr	BASEPRI_MAX, r3
1fffa98e:	f3bf 8f6f 	isb	sy
	struct k_thread *curr = _current;
1fffa992:	4b10      	ldr	r3, [pc, #64]	; (1fffa9d4 <z_time_slice+0x54>)
	if (pending_current == curr) {
1fffa994:	4a10      	ldr	r2, [pc, #64]	; (1fffa9d8 <z_time_slice+0x58>)
	struct k_thread *curr = _current;
1fffa996:	689c      	ldr	r4, [r3, #8]
	if (pending_current == curr) {
1fffa998:	6810      	ldr	r0, [r2, #0]
1fffa99a:	42a0      	cmp	r0, r4
1fffa99c:	d106      	bne.n	1fffa9ac <z_time_slice+0x2c>
		z_reset_time_slice(curr);
1fffa99e:	f7ff fee7 	bl	1fffa770 <z_reset_time_slice>
	__asm__ volatile(
1fffa9a2:	f385 8811 	msr	BASEPRI, r5
1fffa9a6:	f3bf 8f6f 	isb	sy
}
1fffa9aa:	bd38      	pop	{r3, r4, r5, pc}
	pending_current = NULL;
1fffa9ac:	2100      	movs	r1, #0
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
1fffa9ae:	7c1b      	ldrb	r3, [r3, #16]
	pending_current = NULL;
1fffa9b0:	6011      	str	r1, [r2, #0]
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
1fffa9b2:	4a0a      	ldr	r2, [pc, #40]	; (1fffa9dc <z_time_slice+0x5c>)
1fffa9b4:	5cd3      	ldrb	r3, [r2, r3]
1fffa9b6:	2b00      	cmp	r3, #0
1fffa9b8:	d0f3      	beq.n	1fffa9a2 <z_time_slice+0x22>
1fffa9ba:	4620      	mov	r0, r4
1fffa9bc:	f7ff feaa 	bl	1fffa714 <sliceable>
1fffa9c0:	2800      	cmp	r0, #0
1fffa9c2:	d0ee      	beq.n	1fffa9a2 <z_time_slice+0x22>
		if (!z_is_thread_prevented_from_running(curr)) {
1fffa9c4:	7b63      	ldrb	r3, [r4, #13]
1fffa9c6:	06db      	lsls	r3, r3, #27
1fffa9c8:	d102      	bne.n	1fffa9d0 <z_time_slice+0x50>
			move_thread_to_end_of_prio_q(curr);
1fffa9ca:	4620      	mov	r0, r4
1fffa9cc:	f7ff ff16 	bl	1fffa7fc <move_thread_to_end_of_prio_q>
		z_reset_time_slice(curr);
1fffa9d0:	4620      	mov	r0, r4
1fffa9d2:	e7e4      	b.n	1fffa99e <z_time_slice+0x1e>
1fffa9d4:	200005a8 	.word	0x200005a8
1fffa9d8:	200005c8 	.word	0x200005c8
1fffa9dc:	200009ee 	.word	0x200009ee

1fffa9e0 <z_pend_curr>:
{
1fffa9e0:	b570      	push	{r4, r5, r6, lr}
	pending_current = _current;
1fffa9e2:	480c      	ldr	r0, [pc, #48]	; (1fffaa14 <z_pend_curr+0x34>)
1fffa9e4:	4d0c      	ldr	r5, [pc, #48]	; (1fffaa18 <z_pend_curr+0x38>)
1fffa9e6:	6886      	ldr	r6, [r0, #8]
1fffa9e8:	602e      	str	r6, [r5, #0]
{
1fffa9ea:	460c      	mov	r4, r1
1fffa9ec:	4611      	mov	r1, r2
1fffa9ee:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
	__asm__ volatile(
1fffa9f2:	f04f 0610 	mov.w	r6, #16
1fffa9f6:	f3ef 8511 	mrs	r5, BASEPRI
1fffa9fa:	f386 8812 	msr	BASEPRI_MAX, r6
1fffa9fe:	f3bf 8f6f 	isb	sy
	pend_locked(_current, wait_q, timeout);
1fffaa02:	6880      	ldr	r0, [r0, #8]
1fffaa04:	f7ff ff80 	bl	1fffa908 <pend_locked>
	ret = arch_swap(key);
1fffaa08:	4620      	mov	r0, r4
}
1fffaa0a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
1fffaa0e:	f7fe bc6f 	b.w	1fff92f0 <arch_swap>
1fffaa12:	bf00      	nop
1fffaa14:	200005a8 	.word	0x200005a8
1fffaa18:	200005c8 	.word	0x200005c8

1fffaa1c <z_reschedule>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
1fffaa1c:	b949      	cbnz	r1, 1fffaa32 <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
1fffaa1e:	f3ef 8005 	mrs	r0, IPSR
1fffaa22:	b930      	cbnz	r0, 1fffaa32 <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
1fffaa24:	4b05      	ldr	r3, [pc, #20]	; (1fffaa3c <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
1fffaa26:	695a      	ldr	r2, [r3, #20]
1fffaa28:	689b      	ldr	r3, [r3, #8]
1fffaa2a:	429a      	cmp	r2, r3
1fffaa2c:	d001      	beq.n	1fffaa32 <z_reschedule+0x16>
1fffaa2e:	f7fe bc5f 	b.w	1fff92f0 <arch_swap>
	__asm__ volatile(
1fffaa32:	f381 8811 	msr	BASEPRI, r1
1fffaa36:	f3bf 8f6f 	isb	sy
}
1fffaa3a:	4770      	bx	lr
1fffaa3c:	200005a8 	.word	0x200005a8

1fffaa40 <z_sched_start>:
{
1fffaa40:	b510      	push	{r4, lr}
	__asm__ volatile(
1fffaa42:	f04f 0210 	mov.w	r2, #16
1fffaa46:	f3ef 8411 	mrs	r4, BASEPRI
1fffaa4a:	f382 8812 	msr	BASEPRI_MAX, r2
1fffaa4e:	f3bf 8f6f 	isb	sy
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
1fffaa52:	7b42      	ldrb	r2, [r0, #13]
	if (z_has_thread_started(thread)) {
1fffaa54:	0751      	lsls	r1, r2, #29
1fffaa56:	d404      	bmi.n	1fffaa62 <z_sched_start+0x22>
	__asm__ volatile(
1fffaa58:	f384 8811 	msr	BASEPRI, r4
1fffaa5c:	f3bf 8f6f 	isb	sy
}
1fffaa60:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
1fffaa62:	f022 0204 	bic.w	r2, r2, #4
1fffaa66:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
1fffaa68:	f7ff ff02 	bl	1fffa870 <ready_thread>
	z_reschedule(&sched_spinlock, key);
1fffaa6c:	4621      	mov	r1, r4
1fffaa6e:	4802      	ldr	r0, [pc, #8]	; (1fffaa78 <z_sched_start+0x38>)
}
1fffaa70:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
1fffaa74:	f7ff bfd2 	b.w	1fffaa1c <z_reschedule>
1fffaa78:	200009ef 	.word	0x200009ef

1fffaa7c <z_impl_k_thread_suspend>:
{
1fffaa7c:	b570      	push	{r4, r5, r6, lr}
1fffaa7e:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
1fffaa80:	3018      	adds	r0, #24
1fffaa82:	f001 ff53 	bl	1fffc92c <z_abort_timeout>
	__asm__ volatile(
1fffaa86:	f04f 0310 	mov.w	r3, #16
1fffaa8a:	f3ef 8611 	mrs	r6, BASEPRI
1fffaa8e:	f383 8812 	msr	BASEPRI_MAX, r3
1fffaa92:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
1fffaa96:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return (thread->base.thread_state & state) != 0U;
1fffaa9a:	7b63      	ldrb	r3, [r4, #13]
1fffaa9c:	2a00      	cmp	r2, #0
1fffaa9e:	da05      	bge.n	1fffaaac <z_impl_k_thread_suspend+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
1fffaaa0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
1fffaaa4:	7363      	strb	r3, [r4, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
1fffaaa6:	4620      	mov	r0, r4
1fffaaa8:	f001 fe76 	bl	1fffc798 <sys_dlist_remove>
		update_cache(thread == _current);
1fffaaac:	4d0b      	ldr	r5, [pc, #44]	; (1fffaadc <z_impl_k_thread_suspend+0x60>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
1fffaaae:	7b63      	ldrb	r3, [r4, #13]
1fffaab0:	68a8      	ldr	r0, [r5, #8]
1fffaab2:	f043 0310 	orr.w	r3, r3, #16
1fffaab6:	7363      	strb	r3, [r4, #13]
1fffaab8:	1b03      	subs	r3, r0, r4
1fffaaba:	4258      	negs	r0, r3
1fffaabc:	4158      	adcs	r0, r3
1fffaabe:	f7ff fe7f 	bl	1fffa7c0 <update_cache>
	__asm__ volatile(
1fffaac2:	f386 8811 	msr	BASEPRI, r6
1fffaac6:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
1fffaaca:	68ab      	ldr	r3, [r5, #8]
1fffaacc:	42a3      	cmp	r3, r4
1fffaace:	d103      	bne.n	1fffaad8 <z_impl_k_thread_suspend+0x5c>
}
1fffaad0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
1fffaad4:	f001 bf10 	b.w	1fffc8f8 <z_reschedule_unlocked>
}
1fffaad8:	bd70      	pop	{r4, r5, r6, pc}
1fffaada:	bf00      	nop
1fffaadc:	200005a8 	.word	0x200005a8

1fffaae0 <k_sched_lock>:
	__asm__ volatile(
1fffaae0:	f04f 0310 	mov.w	r3, #16
1fffaae4:	f3ef 8111 	mrs	r1, BASEPRI
1fffaae8:	f383 8812 	msr	BASEPRI_MAX, r3
1fffaaec:	f3bf 8f6f 	isb	sy
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
1fffaaf0:	4b04      	ldr	r3, [pc, #16]	; (1fffab04 <k_sched_lock+0x24>)
1fffaaf2:	689a      	ldr	r2, [r3, #8]
1fffaaf4:	7bd3      	ldrb	r3, [r2, #15]
1fffaaf6:	3b01      	subs	r3, #1
1fffaaf8:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
1fffaafa:	f381 8811 	msr	BASEPRI, r1
1fffaafe:	f3bf 8f6f 	isb	sy
}
1fffab02:	4770      	bx	lr
1fffab04:	200005a8 	.word	0x200005a8

1fffab08 <k_sched_unlock>:
{
1fffab08:	b510      	push	{r4, lr}
	__asm__ volatile(
1fffab0a:	f04f 0310 	mov.w	r3, #16
1fffab0e:	f3ef 8411 	mrs	r4, BASEPRI
1fffab12:	f383 8812 	msr	BASEPRI_MAX, r3
1fffab16:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
1fffab1a:	4b08      	ldr	r3, [pc, #32]	; (1fffab3c <k_sched_unlock+0x34>)
1fffab1c:	689a      	ldr	r2, [r3, #8]
1fffab1e:	7bd3      	ldrb	r3, [r2, #15]
1fffab20:	3301      	adds	r3, #1
1fffab22:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
1fffab24:	2000      	movs	r0, #0
1fffab26:	f7ff fe4b 	bl	1fffa7c0 <update_cache>
	__asm__ volatile(
1fffab2a:	f384 8811 	msr	BASEPRI, r4
1fffab2e:	f3bf 8f6f 	isb	sy
}
1fffab32:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
1fffab36:	f001 bedf 	b.w	1fffc8f8 <z_reschedule_unlocked>
1fffab3a:	bf00      	nop
1fffab3c:	200005a8 	.word	0x200005a8

1fffab40 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
1fffab40:	4b04      	ldr	r3, [pc, #16]	; (1fffab54 <z_sched_init+0x14>)
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
1fffab42:	2100      	movs	r1, #0
1fffab44:	f103 0218 	add.w	r2, r3, #24
1fffab48:	4608      	mov	r0, r1
	list->tail = (sys_dnode_t *)list;
1fffab4a:	e9c3 2206 	strd	r2, r2, [r3, #24]
1fffab4e:	f7ff bef3 	b.w	1fffa938 <k_sched_time_slice_set>
1fffab52:	bf00      	nop
1fffab54:	200005a8 	.word	0x200005a8

1fffab58 <z_impl_k_yield>:
	return !(k_is_pre_kernel() || k_is_in_isr() ||
		 z_is_idle_thread_object(_current));
}

void z_impl_k_yield(void)
{
1fffab58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
1fffab5a:	f04f 0310 	mov.w	r3, #16
1fffab5e:	f3ef 8511 	mrs	r5, BASEPRI
1fffab62:	f383 8812 	msr	BASEPRI_MAX, r3
1fffab66:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
1fffab6a:	4919      	ldr	r1, [pc, #100]	; (1fffabd0 <z_impl_k_yield+0x78>)
1fffab6c:	6888      	ldr	r0, [r1, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
1fffab6e:	7b43      	ldrb	r3, [r0, #13]
1fffab70:	f003 037f 	and.w	r3, r3, #127	; 0x7f
1fffab74:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
1fffab76:	f001 fe0f 	bl	1fffc798 <sys_dlist_remove>
	}
	queue_thread(_current);
1fffab7a:	688b      	ldr	r3, [r1, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
1fffab7c:	7b5a      	ldrb	r2, [r3, #13]
	return list->head == list;
1fffab7e:	4608      	mov	r0, r1
1fffab80:	f062 027f 	orn	r2, r2, #127	; 0x7f
1fffab84:	735a      	strb	r2, [r3, #13]
1fffab86:	f850 2f18 	ldr.w	r2, [r0, #24]!
	return (node == list->tail) ? NULL : node->next;
1fffab8a:	69cc      	ldr	r4, [r1, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fffab8c:	4282      	cmp	r2, r0
1fffab8e:	bf08      	it	eq
1fffab90:	2200      	moveq	r2, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
1fffab92:	b922      	cbnz	r2, 1fffab9e <z_impl_k_yield+0x46>
	node->prev = tail;
1fffab94:	e9c3 0400 	strd	r0, r4, [r3]
	tail->next = node;
1fffab98:	6023      	str	r3, [r4, #0]
	list->tail = node;
1fffab9a:	61cb      	str	r3, [r1, #28]
}
1fffab9c:	e00c      	b.n	1fffabb8 <z_impl_k_yield+0x60>
	int32_t b1 = thread_1->base.prio;
1fffab9e:	f993 600e 	ldrsb.w	r6, [r3, #14]
	int32_t b2 = thread_2->base.prio;
1fffaba2:	f992 700e 	ldrsb.w	r7, [r2, #14]
	if (b1 != b2) {
1fffaba6:	42be      	cmp	r6, r7
1fffaba8:	d00e      	beq.n	1fffabc8 <z_impl_k_yield+0x70>
		if (z_sched_prio_cmp(thread, t) > 0) {
1fffabaa:	42b7      	cmp	r7, r6
1fffabac:	dd0c      	ble.n	1fffabc8 <z_impl_k_yield+0x70>
	sys_dnode_t *const prev = successor->prev;
1fffabae:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
1fffabb0:	e9c3 2100 	strd	r2, r1, [r3]
	prev->next = node;
1fffabb4:	600b      	str	r3, [r1, #0]
	successor->prev = node;
1fffabb6:	6053      	str	r3, [r2, #4]
	update_cache(1);
1fffabb8:	2001      	movs	r0, #1
1fffabba:	f7ff fe01 	bl	1fffa7c0 <update_cache>
1fffabbe:	4628      	mov	r0, r5
	z_swap(&sched_spinlock, key);
}
1fffabc0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
1fffabc4:	f7fe bb94 	b.w	1fff92f0 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
1fffabc8:	42a2      	cmp	r2, r4
1fffabca:	d0e3      	beq.n	1fffab94 <z_impl_k_yield+0x3c>
1fffabcc:	6812      	ldr	r2, [r2, #0]
1fffabce:	e7e0      	b.n	1fffab92 <z_impl_k_yield+0x3a>
1fffabd0:	200005a8 	.word	0x200005a8

1fffabd4 <z_tick_sleep>:
	__ASSERT(!arch_is_in_isr(), "");

	LOG_DBG("thread %p for %lu ticks", _current, (unsigned long)ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
1fffabd4:	ea50 0301 	orrs.w	r3, r0, r1
{
1fffabd8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
1fffabdc:	4605      	mov	r5, r0
1fffabde:	460e      	mov	r6, r1
	if (ticks == 0) {
1fffabe0:	d103      	bne.n	1fffabea <z_tick_sleep+0x16>
	z_impl_k_yield();
1fffabe2:	f7ff ffb9 	bl	1fffab58 <z_impl_k_yield>
		k_yield();
		return 0;
1fffabe6:	2000      	movs	r0, #0
1fffabe8:	e02c      	b.n	1fffac44 <z_tick_sleep+0x70>
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
	if (Z_TICK_ABS(ticks) <= 0) {
1fffabea:	1c83      	adds	r3, r0, #2
1fffabec:	f171 33ff 	sbcs.w	r3, r1, #4294967295	; 0xffffffff
1fffabf0:	db2a      	blt.n	1fffac48 <z_tick_sleep+0x74>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
1fffabf2:	f001 feb1 	bl	1fffc958 <sys_clock_tick_get_32>
1fffabf6:	182c      	adds	r4, r5, r0
1fffabf8:	f04f 0310 	mov.w	r3, #16
1fffabfc:	f3ef 8811 	mrs	r8, BASEPRI
1fffac00:	f383 8812 	msr	BASEPRI_MAX, r3
1fffac04:	f3bf 8f6f 	isb	sy
	}

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
1fffac08:	4f11      	ldr	r7, [pc, #68]	; (1fffac50 <z_tick_sleep+0x7c>)
1fffac0a:	4b12      	ldr	r3, [pc, #72]	; (1fffac54 <z_tick_sleep+0x80>)
1fffac0c:	68b8      	ldr	r0, [r7, #8]
1fffac0e:	6018      	str	r0, [r3, #0]
#endif
	unready_thread(_current);
1fffac10:	f7ff fe62 	bl	1fffa8d8 <unready_thread>
	z_add_thread_timeout(_current, timeout);
1fffac14:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
1fffac16:	4910      	ldr	r1, [pc, #64]	; (1fffac58 <z_tick_sleep+0x84>)
1fffac18:	462a      	mov	r2, r5
1fffac1a:	4633      	mov	r3, r6
1fffac1c:	3018      	adds	r0, #24
1fffac1e:	f000 f8fb 	bl	1fffae18 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
1fffac22:	68ba      	ldr	r2, [r7, #8]
	thread->base.thread_state |= _THREAD_SUSPENDED;
1fffac24:	7b53      	ldrb	r3, [r2, #13]
1fffac26:	f043 0310 	orr.w	r3, r3, #16
1fffac2a:	7353      	strb	r3, [r2, #13]
1fffac2c:	4640      	mov	r0, r8
1fffac2e:	f7fe fb5f 	bl	1fff92f0 <arch_swap>

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
1fffac32:	f001 fe91 	bl	1fffc958 <sys_clock_tick_get_32>
1fffac36:	1a20      	subs	r0, r4, r0
1fffac38:	eb63 0303 	sbc.w	r3, r3, r3
	if (ticks > 0) {
1fffac3c:	2801      	cmp	r0, #1
1fffac3e:	f173 0300 	sbcs.w	r3, r3, #0
1fffac42:	dbd0      	blt.n	1fffabe6 <z_tick_sleep+0x12>
		return ticks;
	}
#endif

	return 0;
}
1fffac44:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
1fffac48:	f06f 0401 	mvn.w	r4, #1
1fffac4c:	1a24      	subs	r4, r4, r0
1fffac4e:	e7d3      	b.n	1fffabf8 <z_tick_sleep+0x24>
1fffac50:	200005a8 	.word	0x200005a8
1fffac54:	200005c8 	.word	0x200005c8
1fffac58:	1fffc871 	.word	0x1fffc871

1fffac5c <z_impl_k_sleep>:
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
1fffac5c:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
1fffac60:	bf08      	it	eq
1fffac62:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
1fffac66:	b508      	push	{r3, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
1fffac68:	d106      	bne.n	1fffac78 <z_impl_k_sleep+0x1c>
		k_thread_suspend(_current);
1fffac6a:	4b07      	ldr	r3, [pc, #28]	; (1fffac88 <z_impl_k_sleep+0x2c>)
1fffac6c:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
1fffac6e:	f7ff ff05 	bl	1fffaa7c <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
1fffac72:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
1fffac76:	bd08      	pop	{r3, pc}
	ticks = z_tick_sleep(ticks);
1fffac78:	f7ff ffac 	bl	1fffabd4 <z_tick_sleep>
			return t / ((uint64_t)from_hz / to_hz);
1fffac7c:	220a      	movs	r2, #10
1fffac7e:	2300      	movs	r3, #0
1fffac80:	17c1      	asrs	r1, r0, #31
1fffac82:	f7fd fadb 	bl	1fff823c <__aeabi_uldivmod>
	return ret;
1fffac86:	e7f6      	b.n	1fffac76 <z_impl_k_sleep+0x1a>
1fffac88:	200005a8 	.word	0x200005a8

1fffac8c <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
1fffac8c:	4b01      	ldr	r3, [pc, #4]	; (1fffac94 <z_impl_z_current_get+0x8>)
1fffac8e:	6898      	ldr	r0, [r3, #8]
1fffac90:	4770      	bx	lr
1fffac92:	bf00      	nop
1fffac94:	200005a8 	.word	0x200005a8

1fffac98 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
1fffac98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
1fffac9c:	4604      	mov	r4, r0
1fffac9e:	f04f 0310 	mov.w	r3, #16
1fffaca2:	f3ef 8611 	mrs	r6, BASEPRI
1fffaca6:	f383 8812 	msr	BASEPRI_MAX, r3
1fffacaa:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
1fffacae:	7b03      	ldrb	r3, [r0, #12]
1fffacb0:	07d9      	lsls	r1, r3, #31
1fffacb2:	d50b      	bpl.n	1fffaccc <z_thread_abort+0x34>
	__asm__ volatile(
1fffacb4:	f386 8811 	msr	BASEPRI, r6
1fffacb8:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&sched_spinlock, key);
		__ASSERT(false, "aborting essential thread %p", thread);
		k_panic();
1fffacbc:	4040      	eors	r0, r0
1fffacbe:	f380 8811 	msr	BASEPRI, r0
1fffacc2:	f04f 0004 	mov.w	r0, #4
1fffacc6:	df02      	svc	2
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
1fffacc8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
1fffaccc:	7b43      	ldrb	r3, [r0, #13]
1fffacce:	071a      	lsls	r2, r3, #28
1fffacd0:	d504      	bpl.n	1fffacdc <z_thread_abort+0x44>
1fffacd2:	f386 8811 	msr	BASEPRI, r6
1fffacd6:	f3bf 8f6f 	isb	sy
1fffacda:	e7f5      	b.n	1fffacc8 <z_thread_abort+0x30>
		thread->base.thread_state &= ~_THREAD_ABORTING;
1fffacdc:	f023 0220 	bic.w	r2, r3, #32
1ffface0:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
1ffface4:	09d2      	lsrs	r2, r2, #7
1ffface6:	d120      	bne.n	1fffad2a <z_thread_abort+0x92>
		thread->base.thread_state &= ~_THREAD_ABORTING;
1ffface8:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
1fffacea:	68a3      	ldr	r3, [r4, #8]
1fffacec:	b113      	cbz	r3, 1fffacf4 <z_thread_abort+0x5c>
			unpend_thread_no_timeout(thread);
1fffacee:	4620      	mov	r0, r4
1fffacf0:	f001 fd5a 	bl	1fffc7a8 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
1fffacf4:	f104 0018 	add.w	r0, r4, #24
1fffacf8:	f001 fe18 	bl	1fffc92c <z_abort_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
1fffacfc:	f104 0758 	add.w	r7, r4, #88	; 0x58
1fffad00:	f04f 0800 	mov.w	r8, #0
	return list->head == list;
1fffad04:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fffad06:	42bd      	cmp	r5, r7
1fffad08:	d000      	beq.n	1fffad0c <z_thread_abort+0x74>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
1fffad0a:	b9b5      	cbnz	r5, 1fffad3a <z_thread_abort+0xa2>
		update_cache(1);
1fffad0c:	2001      	movs	r0, #1
1fffad0e:	f7ff fd57 	bl	1fffa7c0 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
1fffad12:	4b10      	ldr	r3, [pc, #64]	; (1fffad54 <z_thread_abort+0xbc>)
1fffad14:	689b      	ldr	r3, [r3, #8]
1fffad16:	42a3      	cmp	r3, r4
1fffad18:	d1db      	bne.n	1fffacd2 <z_thread_abort+0x3a>
1fffad1a:	f3ef 8305 	mrs	r3, IPSR
1fffad1e:	2b00      	cmp	r3, #0
1fffad20:	d1d7      	bne.n	1fffacd2 <z_thread_abort+0x3a>
1fffad22:	4630      	mov	r0, r6
1fffad24:	f7fe fae4 	bl	1fff92f0 <arch_swap>
	return ret;
1fffad28:	e7d3      	b.n	1fffacd2 <z_thread_abort+0x3a>
	thread->base.thread_state &= ~_THREAD_QUEUED;
1fffad2a:	f003 035f 	and.w	r3, r3, #95	; 0x5f
1fffad2e:	f043 0308 	orr.w	r3, r3, #8
1fffad32:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
1fffad34:	f001 fd30 	bl	1fffc798 <sys_dlist_remove>
}
1fffad38:	e7d7      	b.n	1fffacea <z_thread_abort+0x52>
		unpend_thread_no_timeout(thread);
1fffad3a:	4628      	mov	r0, r5
1fffad3c:	f001 fd34 	bl	1fffc7a8 <unpend_thread_no_timeout>
1fffad40:	f105 0018 	add.w	r0, r5, #24
1fffad44:	f001 fdf2 	bl	1fffc92c <z_abort_timeout>
1fffad48:	f8c5 806c 	str.w	r8, [r5, #108]	; 0x6c
		ready_thread(thread);
1fffad4c:	4628      	mov	r0, r5
1fffad4e:	f7ff fd8f 	bl	1fffa870 <ready_thread>
1fffad52:	e7d7      	b.n	1fffad04 <z_thread_abort+0x6c>
1fffad54:	200005a8 	.word	0x200005a8

1fffad58 <z_data_copy>:
 * @brief Copy the data section from ROM to RAM
 *
 * This routine copies the data section from ROM to RAM.
 */
void z_data_copy(void)
{
1fffad58:	b508      	push	{r3, lr}
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
		       __data_region_end - __data_region_start);
1fffad5a:	4806      	ldr	r0, [pc, #24]	; (1fffad74 <z_data_copy+0x1c>)
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
1fffad5c:	4a06      	ldr	r2, [pc, #24]	; (1fffad78 <z_data_copy+0x20>)
1fffad5e:	4907      	ldr	r1, [pc, #28]	; (1fffad7c <z_data_copy+0x24>)
1fffad60:	1a12      	subs	r2, r2, r0
1fffad62:	f001 fcff 	bl	1fffc764 <z_early_memcpy>
#else
	z_early_memcpy(&_app_smem_start, &_app_smem_rom_start,
		       _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
1fffad66:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_early_memcpy(&__ramfunc_start, &__ramfunc_load_start,
1fffad6a:	4a05      	ldr	r2, [pc, #20]	; (1fffad80 <z_data_copy+0x28>)
1fffad6c:	4905      	ldr	r1, [pc, #20]	; (1fffad84 <z_data_copy+0x2c>)
1fffad6e:	4806      	ldr	r0, [pc, #24]	; (1fffad88 <z_data_copy+0x30>)
1fffad70:	f001 bcf8 	b.w	1fffc764 <z_early_memcpy>
1fffad74:	20000000 	.word	0x20000000
1fffad78:	200001ac 	.word	0x200001ac
1fffad7c:	1fffd5ec 	.word	0x1fffd5ec
1fffad80:	00000000 	.word	0x00000000
1fffad84:	1fffd5ec 	.word	0x1fffd5ec
1fffad88:	20000000 	.word	0x20000000

1fffad8c <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
1fffad8c:	4b03      	ldr	r3, [pc, #12]	; (1fffad9c <elapsed+0x10>)
1fffad8e:	681b      	ldr	r3, [r3, #0]
1fffad90:	b90b      	cbnz	r3, 1fffad96 <elapsed+0xa>
1fffad92:	f7fe be69 	b.w	1fff9a68 <sys_clock_elapsed>
}
1fffad96:	2000      	movs	r0, #0
1fffad98:	4770      	bx	lr
1fffad9a:	bf00      	nop
1fffad9c:	200005d4 	.word	0x200005d4

1fffada0 <next_timeout>:

static int32_t next_timeout(void)
{
1fffada0:	b510      	push	{r4, lr}
	return list->head == list;
1fffada2:	4b0e      	ldr	r3, [pc, #56]	; (1fffaddc <next_timeout+0x3c>)
1fffada4:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fffada6:	429c      	cmp	r4, r3
1fffada8:	d104      	bne.n	1fffadb4 <next_timeout+0x14>
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
1fffadaa:	f7ff ffef 	bl	1fffad8c <elapsed>
	int32_t ret;

	if ((to == NULL) ||
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
		ret = MAX_WAIT;
1fffadae:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
	}

	return ret;
}
1fffadb2:	bd10      	pop	{r4, pc}
	int32_t ticks_elapsed = elapsed();
1fffadb4:	f7ff ffea 	bl	1fffad8c <elapsed>
	if ((to == NULL) ||
1fffadb8:	2c00      	cmp	r4, #0
1fffadba:	d0f8      	beq.n	1fffadae <next_timeout+0xe>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
1fffadbc:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
1fffadc0:	1a1b      	subs	r3, r3, r0
1fffadc2:	eb62 72e0 	sbc.w	r2, r2, r0, asr #31
	if ((to == NULL) ||
1fffadc6:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
1fffadca:	f172 0100 	sbcs.w	r1, r2, #0
1fffadce:	daee      	bge.n	1fffadae <next_timeout+0xe>
		ret = MAX(0, to->dticks - ticks_elapsed);
1fffadd0:	2a00      	cmp	r2, #0
1fffadd2:	bfac      	ite	ge
1fffadd4:	4618      	movge	r0, r3
1fffadd6:	2000      	movlt	r0, #0
	return ret;
1fffadd8:	e7eb      	b.n	1fffadb2 <next_timeout+0x12>
1fffadda:	bf00      	nop
1fffaddc:	200000cc 	.word	0x200000cc

1fffade0 <remove_timeout>:
{
1fffade0:	b530      	push	{r4, r5, lr}
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
1fffade2:	b170      	cbz	r0, 1fffae02 <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
1fffade4:	4b0b      	ldr	r3, [pc, #44]	; (1fffae14 <remove_timeout+0x34>)
1fffade6:	685b      	ldr	r3, [r3, #4]
1fffade8:	4298      	cmp	r0, r3
1fffadea:	d00a      	beq.n	1fffae02 <remove_timeout+0x22>
1fffadec:	6803      	ldr	r3, [r0, #0]
	if (next(t) != NULL) {
1fffadee:	b143      	cbz	r3, 1fffae02 <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
1fffadf0:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
1fffadf4:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
1fffadf8:	1912      	adds	r2, r2, r4
1fffadfa:	eb41 0105 	adc.w	r1, r1, r5
1fffadfe:	e9c3 2104 	strd	r2, r1, [r3, #16]
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
	sys_dnode_t *const next = node->next;
1fffae02:	e9d0 3200 	ldrd	r3, r2, [r0]

	prev->next = next;
1fffae06:	6013      	str	r3, [r2, #0]
	next->prev = prev;
1fffae08:	605a      	str	r2, [r3, #4]
	node->next = NULL;
1fffae0a:	2300      	movs	r3, #0
	node->prev = NULL;
1fffae0c:	e9c0 3300 	strd	r3, r3, [r0]
}
1fffae10:	bd30      	pop	{r4, r5, pc}
1fffae12:	bf00      	nop
1fffae14:	200000cc 	.word	0x200000cc

1fffae18 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
1fffae18:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
1fffae1c:	bf08      	it	eq
1fffae1e:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
1fffae22:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1fffae24:	4604      	mov	r4, r0
1fffae26:	461d      	mov	r5, r3
1fffae28:	4616      	mov	r6, r2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
1fffae2a:	d05c      	beq.n	1fffaee6 <z_add_timeout+0xce>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
1fffae2c:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
1fffae2e:	f04f 0310 	mov.w	r3, #16
1fffae32:	f3ef 8711 	mrs	r7, BASEPRI
1fffae36:	f383 8812 	msr	BASEPRI_MAX, r3
1fffae3a:	f3bf 8f6f 	isb	sy

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
1fffae3e:	3201      	adds	r2, #1
1fffae40:	f175 33ff 	sbcs.w	r3, r5, #4294967295	; 0xffffffff
1fffae44:	da24      	bge.n	1fffae90 <z_add_timeout+0x78>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
1fffae46:	492d      	ldr	r1, [pc, #180]	; (1fffaefc <z_add_timeout+0xe4>)
1fffae48:	e9d1 2000 	ldrd	r2, r0, [r1]
1fffae4c:	f06f 0301 	mvn.w	r3, #1
1fffae50:	1a9b      	subs	r3, r3, r2
1fffae52:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
1fffae56:	eb62 0000 	sbc.w	r0, r2, r0
1fffae5a:	1b9e      	subs	r6, r3, r6
1fffae5c:	eb60 0005 	sbc.w	r0, r0, r5

			to->dticks = MAX(1, ticks);
1fffae60:	2e01      	cmp	r6, #1
1fffae62:	f170 0300 	sbcs.w	r3, r0, #0
1fffae66:	da01      	bge.n	1fffae6c <z_add_timeout+0x54>
1fffae68:	2601      	movs	r6, #1
1fffae6a:	2000      	movs	r0, #0
1fffae6c:	e9c4 6004 	strd	r6, r0, [r4, #16]
	return list->head == list;
1fffae70:	4e23      	ldr	r6, [pc, #140]	; (1fffaf00 <z_add_timeout+0xe8>)
1fffae72:	f8d6 c000 	ldr.w	ip, [r6]
	return (node == list->tail) ? NULL : node->next;
1fffae76:	6875      	ldr	r5, [r6, #4]
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fffae78:	45b4      	cmp	ip, r6
1fffae7a:	bf08      	it	eq
1fffae7c:	f04f 0c00 	moveq.w	ip, #0
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
		}

		for (t = first(); t != NULL; t = next(t)) {
1fffae80:	f1bc 0f00 	cmp.w	ip, #0
1fffae84:	d10d      	bne.n	1fffaea2 <z_add_timeout+0x8a>
	node->prev = tail;
1fffae86:	e9c4 6500 	strd	r6, r5, [r4]
	tail->next = node;
1fffae8a:	602c      	str	r4, [r5, #0]
	list->tail = node;
1fffae8c:	6074      	str	r4, [r6, #4]
}
1fffae8e:	e01c      	b.n	1fffaeca <z_add_timeout+0xb2>
			to->dticks = timeout.ticks + 1 + elapsed();
1fffae90:	f7ff ff7c 	bl	1fffad8c <elapsed>
1fffae94:	3601      	adds	r6, #1
1fffae96:	f145 0500 	adc.w	r5, r5, #0
1fffae9a:	1836      	adds	r6, r6, r0
1fffae9c:	eb45 70e0 	adc.w	r0, r5, r0, asr #31
1fffaea0:	e7e4      	b.n	1fffae6c <z_add_timeout+0x54>
			if (t->dticks > to->dticks) {
1fffaea2:	e9dc 2004 	ldrd	r2, r0, [ip, #16]
1fffaea6:	e9d4 3104 	ldrd	r3, r1, [r4, #16]
1fffaeaa:	4293      	cmp	r3, r2
1fffaeac:	eb71 0e00 	sbcs.w	lr, r1, r0
1fffaeb0:	da1a      	bge.n	1fffaee8 <z_add_timeout+0xd0>
				t->dticks -= to->dticks;
1fffaeb2:	1ad2      	subs	r2, r2, r3
	sys_dnode_t *const prev = successor->prev;
1fffaeb4:	f8dc 3004 	ldr.w	r3, [ip, #4]
1fffaeb8:	eb60 0001 	sbc.w	r0, r0, r1
1fffaebc:	e9cc 2004 	strd	r2, r0, [ip, #16]
	node->next = successor;
1fffaec0:	e9c4 c300 	strd	ip, r3, [r4]
	prev->next = node;
1fffaec4:	601c      	str	r4, [r3, #0]
	successor->prev = node;
1fffaec6:	f8cc 4004 	str.w	r4, [ip, #4]
	return list->head == list;
1fffaeca:	6833      	ldr	r3, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fffaecc:	42b3      	cmp	r3, r6
1fffaece:	d006      	beq.n	1fffaede <z_add_timeout+0xc6>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
1fffaed0:	429c      	cmp	r4, r3
1fffaed2:	d104      	bne.n	1fffaede <z_add_timeout+0xc6>
			sys_clock_set_timeout(next_timeout(), false);
1fffaed4:	f7ff ff64 	bl	1fffada0 <next_timeout>
1fffaed8:	2100      	movs	r1, #0
1fffaeda:	f7fe fd53 	bl	1fff9984 <sys_clock_set_timeout>
	__asm__ volatile(
1fffaede:	f387 8811 	msr	BASEPRI, r7
1fffaee2:	f3bf 8f6f 	isb	sy
		}
	}
}
1fffaee6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			to->dticks -= t->dticks;
1fffaee8:	1a9b      	subs	r3, r3, r2
1fffaeea:	eb61 0100 	sbc.w	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
1fffaeee:	45ac      	cmp	ip, r5
1fffaef0:	e9c4 3104 	strd	r3, r1, [r4, #16]
1fffaef4:	d0c7      	beq.n	1fffae86 <z_add_timeout+0x6e>
1fffaef6:	f8dc c000 	ldr.w	ip, [ip]
1fffaefa:	e7c1      	b.n	1fffae80 <z_add_timeout+0x68>
1fffaefc:	200003f8 	.word	0x200003f8
1fffaf00:	200000cc 	.word	0x200000cc

1fffaf04 <sys_clock_announce>:
	}
	return ret;
}

void sys_clock_announce(int32_t ticks)
{
1fffaf04:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	__asm__ volatile(
1fffaf08:	f04f 0310 	mov.w	r3, #16
1fffaf0c:	f3ef 8c11 	mrs	ip, BASEPRI
1fffaf10:	f383 8812 	msr	BASEPRI_MAX, r3
1fffaf14:	f3bf 8f6f 	isb	sy
	return list->head == list;
1fffaf18:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 1fffafcc <sys_clock_announce+0xc8>
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
1fffaf1c:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 1fffafd0 <sys_clock_announce+0xcc>
	for (t = first();
	     (t != NULL) && (t->dticks <= announce_remaining);
	     t = first()) {
		int dt = t->dticks;

		curr_tick += dt;
1fffaf20:	4f2c      	ldr	r7, [pc, #176]	; (1fffafd4 <sys_clock_announce+0xd0>)
	announce_remaining = ticks;
1fffaf22:	f8c9 0000 	str.w	r0, [r9]
1fffaf26:	f8da 0000 	ldr.w	r0, [sl]
		t->dticks = 0;
1fffaf2a:	2400      	movs	r4, #0
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fffaf2c:	4550      	cmp	r0, sl
1fffaf2e:	bf08      	it	eq
1fffaf30:	2000      	moveq	r0, #0
1fffaf32:	2500      	movs	r5, #0
		curr_tick += dt;
1fffaf34:	e9d7 2100 	ldrd	r2, r1, [r7]
	     (t != NULL) && (t->dticks <= announce_remaining);
1fffaf38:	f8d9 3000 	ldr.w	r3, [r9]
	 * a memory barrier when used like this, and we don't have a
	 * Zephyr framework for that.
	 */
	atomic_clear(&l->locked);
#endif
	arch_irq_unlock(key.key);
1fffaf3c:	46e0      	mov	r8, ip
1fffaf3e:	b380      	cbz	r0, 1fffafa2 <sys_clock_announce+0x9e>
1fffaf40:	e9d0 6c04 	ldrd	r6, ip, [r0, #16]
1fffaf44:	ea4f 7ee3 	mov.w	lr, r3, asr #31
1fffaf48:	42b3      	cmp	r3, r6
1fffaf4a:	eb7e 0b0c 	sbcs.w	fp, lr, ip
1fffaf4e:	da05      	bge.n	1fffaf5c <sys_clock_announce+0x58>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
	}

	if (t != NULL) {
		t->dticks -= announce_remaining;
1fffaf50:	1af6      	subs	r6, r6, r3
1fffaf52:	eb6c 040e 	sbc.w	r4, ip, lr
1fffaf56:	e9c0 6404 	strd	r6, r4, [r0, #16]
1fffaf5a:	e022      	b.n	1fffafa2 <sys_clock_announce+0x9e>
		curr_tick += dt;
1fffaf5c:	18b2      	adds	r2, r6, r2
1fffaf5e:	eb41 71e6 	adc.w	r1, r1, r6, asr #31
		t->dticks = 0;
1fffaf62:	e9c0 4504 	strd	r4, r5, [r0, #16]
		curr_tick += dt;
1fffaf66:	e9c7 2100 	strd	r2, r1, [r7]
		remove_timeout(t);
1fffaf6a:	f7ff ff39 	bl	1fffade0 <remove_timeout>
	__asm__ volatile(
1fffaf6e:	f388 8811 	msr	BASEPRI, r8
1fffaf72:	f3bf 8f6f 	isb	sy
		t->fn(t);
1fffaf76:	6883      	ldr	r3, [r0, #8]
1fffaf78:	4798      	blx	r3
	__asm__ volatile(
1fffaf7a:	f04f 0310 	mov.w	r3, #16
1fffaf7e:	f3ef 8811 	mrs	r8, BASEPRI
1fffaf82:	f383 8812 	msr	BASEPRI_MAX, r3
1fffaf86:	f3bf 8f6f 	isb	sy
		announce_remaining -= dt;
1fffaf8a:	f8d9 3000 	ldr.w	r3, [r9]
	return list->head == list;
1fffaf8e:	f8da 0000 	ldr.w	r0, [sl]
1fffaf92:	1b9b      	subs	r3, r3, r6
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fffaf94:	4550      	cmp	r0, sl
	k.key = arch_irq_lock();
1fffaf96:	46c4      	mov	ip, r8
1fffaf98:	f8c9 3000 	str.w	r3, [r9]
1fffaf9c:	d1ca      	bne.n	1fffaf34 <sys_clock_announce+0x30>
		curr_tick += dt;
1fffaf9e:	e9d7 2100 	ldrd	r2, r1, [r7]
	}

	curr_tick += announce_remaining;
1fffafa2:	189a      	adds	r2, r3, r2
1fffafa4:	eb41 73e3 	adc.w	r3, r1, r3, asr #31
	announce_remaining = 0;
1fffafa8:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
1fffafaa:	e9c7 2300 	strd	r2, r3, [r7]
	announce_remaining = 0;
1fffafae:	f8c9 4000 	str.w	r4, [r9]

	sys_clock_set_timeout(next_timeout(), false);
1fffafb2:	f7ff fef5 	bl	1fffada0 <next_timeout>
1fffafb6:	4621      	mov	r1, r4
1fffafb8:	f7fe fce4 	bl	1fff9984 <sys_clock_set_timeout>
	__asm__ volatile(
1fffafbc:	f388 8811 	msr	BASEPRI, r8
1fffafc0:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&timeout_lock, key);

#ifdef CONFIG_TIMESLICING
	z_time_slice();
#endif
}
1fffafc4:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	z_time_slice();
1fffafc8:	f7ff bcda 	b.w	1fffa980 <z_time_slice>
1fffafcc:	200000cc 	.word	0x200000cc
1fffafd0:	200005d4 	.word	0x200005d4
1fffafd4:	200003f8 	.word	0x200003f8

1fffafd8 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
1fffafd8:	b510      	push	{r4, lr}
	__asm__ volatile(
1fffafda:	f04f 0310 	mov.w	r3, #16
1fffafde:	f3ef 8411 	mrs	r4, BASEPRI
1fffafe2:	f383 8812 	msr	BASEPRI_MAX, r3
1fffafe6:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + elapsed();
1fffafea:	f7ff fecf 	bl	1fffad8c <elapsed>
1fffafee:	4a06      	ldr	r2, [pc, #24]	; (1fffb008 <sys_clock_tick_get+0x30>)
1fffaff0:	4603      	mov	r3, r0
1fffaff2:	e9d2 0100 	ldrd	r0, r1, [r2]
1fffaff6:	1818      	adds	r0, r3, r0
1fffaff8:	eb41 71e3 	adc.w	r1, r1, r3, asr #31
	__asm__ volatile(
1fffaffc:	f384 8811 	msr	BASEPRI, r4
1fffb000:	f3bf 8f6f 	isb	sy
	}
	return t;
}
1fffb004:	bd10      	pop	{r4, pc}
1fffb006:	bf00      	nop
1fffb008:	200003f8 	.word	0x200003f8

1fffb00c <k_aligned_alloc>:

K_HEAP_DEFINE(_system_heap, CONFIG_HEAP_MEM_POOL_SIZE);
#define _SYSTEM_HEAP (&_system_heap)

void *k_aligned_alloc(size_t align, size_t size)
{
1fffb00c:	460a      	mov	r2, r1
	__ASSERT((align & (align - 1)) == 0,
		"align must be a power of 2");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_aligned_alloc, _SYSTEM_HEAP);

	void *ret = z_heap_aligned_alloc(_SYSTEM_HEAP, align, size);
1fffb00e:	4601      	mov	r1, r0
1fffb010:	4801      	ldr	r0, [pc, #4]	; (1fffb018 <k_aligned_alloc+0xc>)
1fffb012:	f001 bcc7 	b.w	1fffc9a4 <z_heap_aligned_alloc>
1fffb016:	bf00      	nop
1fffb018:	200000dc 	.word	0x200000dc

1fffb01c <k_thread_system_pool_assign>:
	return ret;
}

void k_thread_system_pool_assign(struct k_thread *thread)
{
	thread->resource_pool = _SYSTEM_HEAP;
1fffb01c:	4b01      	ldr	r3, [pc, #4]	; (1fffb024 <k_thread_system_pool_assign+0x8>)
1fffb01e:	6643      	str	r3, [r0, #100]	; 0x64
}
1fffb020:	4770      	bx	lr
1fffb022:	bf00      	nop
1fffb024:	200000dc 	.word	0x200000dc

1fffb028 <boot_banner>:
	printk("***** delaying boot " DELAY_STR "ms (per build configuration) *****\n");
	k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
#endif /* defined(CONFIG_BOOT_DELAY) && (CONFIG_BOOT_DELAY > 0) */

#if CONFIG_BOOT_BANNER
	printk("*** Booting Zephyr OS build " BANNER_VERSION BANNER_POSTFIX " ***\n");
1fffb028:	4801      	ldr	r0, [pc, #4]	; (1fffb030 <boot_banner+0x8>)
1fffb02a:	f000 b819 	b.w	1fffb060 <printk>
1fffb02e:	bf00      	nop
1fffb030:	1fffd5aa 	.word	0x1fffd5aa

1fffb034 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
1fffb034:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
1fffb036:	4c06      	ldr	r4, [pc, #24]	; (1fffb050 <statics_init+0x1c>)
1fffb038:	4d06      	ldr	r5, [pc, #24]	; (1fffb054 <statics_init+0x20>)
1fffb03a:	42ac      	cmp	r4, r5
1fffb03c:	d301      	bcc.n	1fffb042 <statics_init+0xe>
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
1fffb03e:	2000      	movs	r0, #0
1fffb040:	bd38      	pop	{r3, r4, r5, pc}
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
1fffb042:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
1fffb046:	4620      	mov	r0, r4
1fffb048:	f001 fcca 	bl	1fffc9e0 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
1fffb04c:	3414      	adds	r4, #20
1fffb04e:	e7f4      	b.n	1fffb03a <statics_init+0x6>
1fffb050:	200000dc 	.word	0x200000dc
1fffb054:	200000f0 	.word	0x200000f0

1fffb058 <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
1fffb058:	4770      	bx	lr

1fffb05a <new_service_cb>:
}
1fffb05a:	4770      	bx	lr

1fffb05c <arch_printk_char_out>:
}
1fffb05c:	2000      	movs	r0, #0
1fffb05e:	4770      	bx	lr

1fffb060 <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
1fffb060:	b40f      	push	{r0, r1, r2, r3}
1fffb062:	b507      	push	{r0, r1, r2, lr}
1fffb064:	a904      	add	r1, sp, #16
1fffb066:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
1fffb06a:	9101      	str	r1, [sp, #4]

	vprintk(fmt, ap);
1fffb06c:	f7fd fca2 	bl	1fff89b4 <vprintk>

	va_end(ap);
}
1fffb070:	b003      	add	sp, #12
1fffb072:	f85d eb04 	ldr.w	lr, [sp], #4
1fffb076:	b004      	add	sp, #16
1fffb078:	4770      	bx	lr

1fffb07a <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
1fffb07a:	4604      	mov	r4, r0
1fffb07c:	b508      	push	{r3, lr}
1fffb07e:	4608      	mov	r0, r1
1fffb080:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
1fffb082:	461a      	mov	r2, r3
1fffb084:	47a0      	blx	r4
	return z_impl_z_current_get();
1fffb086:	f7ff fe01 	bl	1fffac8c <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
1fffb08a:	f7fe fb2b 	bl	1fff96e4 <z_impl_k_thread_abort>

1fffb08e <chunk_size>:
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
	} else {
		return ((uint16_t *)cmem)[f];
1fffb08e:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
1fffb092:	8840      	ldrh	r0, [r0, #2]
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
}
1fffb094:	0840      	lsrs	r0, r0, #1
1fffb096:	4770      	bx	lr

1fffb098 <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
1fffb098:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1fffb09a:	4603      	mov	r3, r0
	if (!solo_free_header(h, c)) {
		int bidx = bucket_idx(h, chunk_size(h, c));
1fffb09c:	f7ff fff7 	bl	1fffb08e <chunk_size>
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
	return 31 - __builtin_clz(usable_sz);
1fffb0a0:	fab0 f080 	clz	r0, r0
1fffb0a4:	f1c0 001f 	rsb	r0, r0, #31
	if (b->next == 0U) {
1fffb0a8:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
	void *cmem = &buf[c];
1fffb0ac:	00ca      	lsls	r2, r1, #3
1fffb0ae:	f8dc 6010 	ldr.w	r6, [ip, #16]
		((uint16_t *)cmem)[f] = val;
1fffb0b2:	1d17      	adds	r7, r2, #4
{
1fffb0b4:	460c      	mov	r4, r1
1fffb0b6:	3206      	adds	r2, #6
1fffb0b8:	b28d      	uxth	r5, r1
	if (b->next == 0U) {
1fffb0ba:	b956      	cbnz	r6, 1fffb0d2 <free_list_add+0x3a>
		h->avail_buckets |= BIT(bidx);
1fffb0bc:	2101      	movs	r1, #1
1fffb0be:	fa01 f000 	lsl.w	r0, r1, r0
1fffb0c2:	68d9      	ldr	r1, [r3, #12]
1fffb0c4:	4301      	orrs	r1, r0
1fffb0c6:	60d9      	str	r1, [r3, #12]
		b->next = c;
1fffb0c8:	f8cc 4010 	str.w	r4, [ip, #16]
1fffb0cc:	53dd      	strh	r5, [r3, r7]
1fffb0ce:	529d      	strh	r5, [r3, r2]
		free_list_add_bidx(h, c, bidx);
	}
}
1fffb0d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	void *cmem = &buf[c];
1fffb0d2:	00f1      	lsls	r1, r6, #3
		return ((uint16_t *)cmem)[f];
1fffb0d4:	3104      	adds	r1, #4
1fffb0d6:	5a58      	ldrh	r0, [r3, r1]
		((uint16_t *)cmem)[f] = val;
1fffb0d8:	53d8      	strh	r0, [r3, r7]
1fffb0da:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
1fffb0de:	529e      	strh	r6, [r3, r2]
1fffb0e0:	80c5      	strh	r5, [r0, #6]
1fffb0e2:	525d      	strh	r5, [r3, r1]
1fffb0e4:	e7f4      	b.n	1fffb0d0 <free_list_add+0x38>

1fffb0e6 <free_list_remove_bidx>:
{
1fffb0e6:	b510      	push	{r4, lr}
		return ((uint16_t *)cmem)[f];
1fffb0e8:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
1fffb0ec:	88e3      	ldrh	r3, [r4, #6]
	if (next_free_chunk(h, c) == c) {
1fffb0ee:	4299      	cmp	r1, r3
1fffb0f0:	f102 0104 	add.w	r1, r2, #4
1fffb0f4:	d10a      	bne.n	1fffb10c <free_list_remove_bidx+0x26>
		h->avail_buckets &= ~BIT(bidx);
1fffb0f6:	2301      	movs	r3, #1
1fffb0f8:	fa03 f202 	lsl.w	r2, r3, r2
1fffb0fc:	68c3      	ldr	r3, [r0, #12]
1fffb0fe:	ea23 0302 	bic.w	r3, r3, r2
1fffb102:	60c3      	str	r3, [r0, #12]
		b->next = 0;
1fffb104:	2300      	movs	r3, #0
1fffb106:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
}
1fffb10a:	bd10      	pop	{r4, pc}
1fffb10c:	88a2      	ldrh	r2, [r4, #4]
		b->next = second;
1fffb10e:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
		((uint16_t *)cmem)[f] = val;
1fffb112:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
1fffb116:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
1fffb11a:	80cb      	strh	r3, [r1, #6]
1fffb11c:	8082      	strh	r2, [r0, #4]
}
1fffb11e:	e7f4      	b.n	1fffb10a <free_list_remove_bidx+0x24>

1fffb120 <free_list_remove>:
{
1fffb120:	b508      	push	{r3, lr}
1fffb122:	4603      	mov	r3, r0
		int bidx = bucket_idx(h, chunk_size(h, c));
1fffb124:	f7ff ffb3 	bl	1fffb08e <chunk_size>
	return 31 - __builtin_clz(usable_sz);
1fffb128:	fab0 f280 	clz	r2, r0
		free_list_remove_bidx(h, c, bidx);
1fffb12c:	f1c2 021f 	rsb	r2, r2, #31
1fffb130:	4618      	mov	r0, r3
}
1fffb132:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		free_list_remove_bidx(h, c, bidx);
1fffb136:	f7ff bfd6 	b.w	1fffb0e6 <free_list_remove_bidx>

1fffb13a <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
1fffb13a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
1fffb13e:	fab1 f581 	clz	r5, r1
1fffb142:	f1c5 091f 	rsb	r9, r5, #31
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
1fffb146:	eb00 0889 	add.w	r8, r0, r9, lsl #2
{
1fffb14a:	4603      	mov	r3, r0
	if (b->next) {
1fffb14c:	f8d8 2010 	ldr.w	r2, [r8, #16]
{
1fffb150:	460e      	mov	r6, r1
	if (b->next) {
1fffb152:	b1c2      	cbz	r2, 1fffb186 <alloc_chunk+0x4c>
1fffb154:	2703      	movs	r7, #3
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
1fffb156:	f8d8 4010 	ldr.w	r4, [r8, #16]
			if (chunk_size(h, c) >= sz) {
1fffb15a:	4618      	mov	r0, r3
1fffb15c:	4621      	mov	r1, r4
1fffb15e:	f7ff ff96 	bl	1fffb08e <chunk_size>
1fffb162:	42b0      	cmp	r0, r6
1fffb164:	d306      	bcc.n	1fffb174 <alloc_chunk+0x3a>
				free_list_remove_bidx(h, c, bi);
1fffb166:	464a      	mov	r2, r9

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
1fffb168:	4618      	mov	r0, r3
1fffb16a:	f7ff ffbc 	bl	1fffb0e6 <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
1fffb16e:	4620      	mov	r0, r4
1fffb170:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ((uint16_t *)cmem)[f];
1fffb174:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
		} while (--i && b->next != first);
1fffb178:	3f01      	subs	r7, #1
1fffb17a:	88e0      	ldrh	r0, [r4, #6]
			b->next = next_free_chunk(h, c);
1fffb17c:	f8c8 0010 	str.w	r0, [r8, #16]
		} while (--i && b->next != first);
1fffb180:	d001      	beq.n	1fffb186 <alloc_chunk+0x4c>
1fffb182:	4282      	cmp	r2, r0
1fffb184:	d1e7      	bne.n	1fffb156 <alloc_chunk+0x1c>
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
1fffb186:	f1c5 0220 	rsb	r2, r5, #32
1fffb18a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
1fffb18e:	4094      	lsls	r4, r2
1fffb190:	68da      	ldr	r2, [r3, #12]
	if (bmask != 0U) {
1fffb192:	4014      	ands	r4, r2
1fffb194:	d0eb      	beq.n	1fffb16e <alloc_chunk+0x34>
		int minbucket = __builtin_ctz(bmask);
1fffb196:	fa94 f2a4 	rbit	r2, r4
1fffb19a:	fab2 f282 	clz	r2, r2
		chunkid_t c = h->buckets[minbucket].next;
1fffb19e:	1d11      	adds	r1, r2, #4
1fffb1a0:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
		free_list_remove_bidx(h, c, minbucket);
1fffb1a4:	4621      	mov	r1, r4
1fffb1a6:	e7df      	b.n	1fffb168 <alloc_chunk+0x2e>

1fffb1a8 <merge_chunks>:
{
1fffb1a8:	b538      	push	{r3, r4, r5, lr}
1fffb1aa:	4603      	mov	r3, r0
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
1fffb1ac:	f7ff ff6f 	bl	1fffb08e <chunk_size>
{
1fffb1b0:	460d      	mov	r5, r1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
1fffb1b2:	4604      	mov	r4, r0
1fffb1b4:	4611      	mov	r1, r2
1fffb1b6:	4618      	mov	r0, r3
1fffb1b8:	f7ff ff69 	bl	1fffb08e <chunk_size>
		((uint16_t *)cmem)[f] = val;
1fffb1bc:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
1fffb1c0:	4404      	add	r4, r0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
1fffb1c2:	0060      	lsls	r0, r4, #1
		((uint16_t *)cmem)[f] = val;
1fffb1c4:	8068      	strh	r0, [r5, #2]
	return c + chunk_size(h, c);
1fffb1c6:	4618      	mov	r0, r3
1fffb1c8:	f7ff ff61 	bl	1fffb08e <chunk_size>
	void *cmem = &buf[c];
1fffb1cc:	4401      	add	r1, r0
		((uint16_t *)cmem)[f] = val;
1fffb1ce:	f823 4031 	strh.w	r4, [r3, r1, lsl #3]
}
1fffb1d2:	bd38      	pop	{r3, r4, r5, pc}

1fffb1d4 <split_chunks>:
{
1fffb1d4:	b538      	push	{r3, r4, r5, lr}
1fffb1d6:	4603      	mov	r3, r0
	chunksz_t sz0 = chunk_size(h, lc);
1fffb1d8:	f7ff ff59 	bl	1fffb08e <chunk_size>
{
1fffb1dc:	460c      	mov	r4, r1
	chunksz_t rsz = sz0 - lsz;
1fffb1de:	1aa5      	subs	r5, r4, r2
	chunksz_t lsz = rc - lc;
1fffb1e0:	1a51      	subs	r1, r2, r1
1fffb1e2:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
	chunksz_t rsz = sz0 - lsz;
1fffb1e6:	4405      	add	r5, r0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
1fffb1e8:	0048      	lsls	r0, r1, #1
		((uint16_t *)cmem)[f] = val;
1fffb1ea:	8060      	strh	r0, [r4, #2]
1fffb1ec:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
1fffb1f0:	006c      	lsls	r4, r5, #1
		((uint16_t *)cmem)[f] = val;
1fffb1f2:	8044      	strh	r4, [r0, #2]
1fffb1f4:	f823 1032 	strh.w	r1, [r3, r2, lsl #3]
	return c + chunk_size(h, c);
1fffb1f8:	4618      	mov	r0, r3
1fffb1fa:	4611      	mov	r1, r2
1fffb1fc:	f7ff ff47 	bl	1fffb08e <chunk_size>
	void *cmem = &buf[c];
1fffb200:	4401      	add	r1, r0
		((uint16_t *)cmem)[f] = val;
1fffb202:	f823 5031 	strh.w	r5, [r3, r1, lsl #3]
}
1fffb206:	bd38      	pop	{r3, r4, r5, pc}

1fffb208 <free_chunk>:
{
1fffb208:	b538      	push	{r3, r4, r5, lr}
1fffb20a:	4605      	mov	r5, r0
	return c + chunk_size(h, c);
1fffb20c:	f7ff ff3f 	bl	1fffb08e <chunk_size>
1fffb210:	460c      	mov	r4, r1
1fffb212:	4401      	add	r1, r0
		return ((uint16_t *)cmem)[f];
1fffb214:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
1fffb218:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, right_chunk(h, c))) {
1fffb21a:	07da      	lsls	r2, r3, #31
1fffb21c:	d40a      	bmi.n	1fffb234 <free_chunk+0x2c>
		free_list_remove(h, right_chunk(h, c));
1fffb21e:	4628      	mov	r0, r5
1fffb220:	f7ff ff7e 	bl	1fffb120 <free_list_remove>
	return c + chunk_size(h, c);
1fffb224:	4621      	mov	r1, r4
1fffb226:	4628      	mov	r0, r5
1fffb228:	f7ff ff31 	bl	1fffb08e <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
1fffb22c:	1822      	adds	r2, r4, r0
1fffb22e:	4628      	mov	r0, r5
1fffb230:	f7ff ffba 	bl	1fffb1a8 <merge_chunks>
		return ((uint16_t *)cmem)[f];
1fffb234:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
1fffb238:	1a61      	subs	r1, r4, r1
		return ((uint16_t *)cmem)[f];
1fffb23a:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
1fffb23e:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, left_chunk(h, c))) {
1fffb240:	07db      	lsls	r3, r3, #31
1fffb242:	d40c      	bmi.n	1fffb25e <free_chunk+0x56>
		free_list_remove(h, left_chunk(h, c));
1fffb244:	4628      	mov	r0, r5
1fffb246:	f7ff ff6b 	bl	1fffb120 <free_list_remove>
		return ((uint16_t *)cmem)[f];
1fffb24a:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
		merge_chunks(h, left_chunk(h, c), c);
1fffb24e:	4622      	mov	r2, r4
1fffb250:	1a61      	subs	r1, r4, r1
1fffb252:	4628      	mov	r0, r5
1fffb254:	f7ff ffa8 	bl	1fffb1a8 <merge_chunks>
1fffb258:	f835 3034 	ldrh.w	r3, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
1fffb25c:	1ae4      	subs	r4, r4, r3
	free_list_add(h, c);
1fffb25e:	4621      	mov	r1, r4
1fffb260:	4628      	mov	r0, r5
}
1fffb262:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	free_list_add(h, c);
1fffb266:	f7ff bf17 	b.w	1fffb098 <free_list_add>

1fffb26a <sys_heap_free>:
	if (mem == NULL) {
1fffb26a:	b161      	cbz	r1, 1fffb286 <sys_heap_free+0x1c>
1fffb26c:	6800      	ldr	r0, [r0, #0]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
1fffb26e:	3904      	subs	r1, #4
1fffb270:	1a09      	subs	r1, r1, r0
	void *cmem = &buf[c];
1fffb272:	f021 0307 	bic.w	r3, r1, #7
1fffb276:	4403      	add	r3, r0
	free_chunk(h, c);
1fffb278:	08c9      	lsrs	r1, r1, #3
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
1fffb27a:	885a      	ldrh	r2, [r3, #2]
1fffb27c:	f022 0201 	bic.w	r2, r2, #1
1fffb280:	805a      	strh	r2, [r3, #2]
1fffb282:	f7ff bfc1 	b.w	1fffb208 <free_chunk>
}
1fffb286:	4770      	bx	lr

1fffb288 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
1fffb288:	b570      	push	{r4, r5, r6, lr}
	struct z_heap *h = heap->heap;
1fffb28a:	6805      	ldr	r5, [r0, #0]
	void *mem;

	if (bytes == 0U || size_too_big(h, bytes)) {
1fffb28c:	b909      	cbnz	r1, 1fffb292 <sys_heap_alloc+0xa>
		return NULL;
1fffb28e:	2000      	movs	r0, #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
1fffb290:	bd70      	pop	{r4, r5, r6, pc}
	if (bytes == 0U || size_too_big(h, bytes)) {
1fffb292:	68ab      	ldr	r3, [r5, #8]
1fffb294:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
1fffb298:	d9f9      	bls.n	1fffb28e <sys_heap_alloc+0x6>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
1fffb29a:	310b      	adds	r1, #11
1fffb29c:	08cc      	lsrs	r4, r1, #3
	chunkid_t c = alloc_chunk(h, chunk_sz);
1fffb29e:	4621      	mov	r1, r4
1fffb2a0:	4628      	mov	r0, r5
1fffb2a2:	f7ff ff4a 	bl	1fffb13a <alloc_chunk>
	if (c == 0U) {
1fffb2a6:	4606      	mov	r6, r0
1fffb2a8:	2800      	cmp	r0, #0
1fffb2aa:	d0f0      	beq.n	1fffb28e <sys_heap_alloc+0x6>
	if (chunk_size(h, c) > chunk_sz) {
1fffb2ac:	4601      	mov	r1, r0
1fffb2ae:	4628      	mov	r0, r5
1fffb2b0:	f7ff feed 	bl	1fffb08e <chunk_size>
1fffb2b4:	42a0      	cmp	r0, r4
1fffb2b6:	d907      	bls.n	1fffb2c8 <sys_heap_alloc+0x40>
		split_chunks(h, c, c + chunk_sz);
1fffb2b8:	1932      	adds	r2, r6, r4
1fffb2ba:	4628      	mov	r0, r5
1fffb2bc:	f7ff ff8a 	bl	1fffb1d4 <split_chunks>
		free_list_add(h, c + chunk_sz);
1fffb2c0:	4611      	mov	r1, r2
1fffb2c2:	4628      	mov	r0, r5
1fffb2c4:	f7ff fee8 	bl	1fffb098 <free_list_add>
	void *cmem = &buf[c];
1fffb2c8:	eb05 02c6 	add.w	r2, r5, r6, lsl #3
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
1fffb2cc:	4610      	mov	r0, r2
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
1fffb2ce:	8853      	ldrh	r3, [r2, #2]
1fffb2d0:	f043 0301 	orr.w	r3, r3, #1
1fffb2d4:	8053      	strh	r3, [r2, #2]
1fffb2d6:	3004      	adds	r0, #4
	return mem;
1fffb2d8:	e7da      	b.n	1fffb290 <sys_heap_alloc+0x8>

1fffb2da <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
1fffb2da:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
1fffb2de:	f101 39ff 	add.w	r9, r1, #4294967295	; 0xffffffff
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
	if (align != rew) {
1fffb2e2:	ea19 0901 	ands.w	r9, r9, r1
	struct z_heap *h = heap->heap;
1fffb2e6:	6806      	ldr	r6, [r0, #0]
{
1fffb2e8:	460f      	mov	r7, r1
1fffb2ea:	4614      	mov	r4, r2
	if (align != rew) {
1fffb2ec:	d00c      	beq.n	1fffb308 <sys_heap_aligned_alloc+0x2e>
	rew = align & -align;
1fffb2ee:	424b      	negs	r3, r1
1fffb2f0:	400b      	ands	r3, r1
		align -= rew;
		gap = MIN(rew, chunk_header_bytes(h));
1fffb2f2:	2b04      	cmp	r3, #4
1fffb2f4:	461a      	mov	r2, r3
1fffb2f6:	464f      	mov	r7, r9
1fffb2f8:	bf28      	it	cs
1fffb2fa:	2204      	movcs	r2, #4
	rew = align & -align;
1fffb2fc:	4699      	mov	r9, r3
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (bytes == 0 || size_too_big(h, bytes)) {
1fffb2fe:	b964      	cbnz	r4, 1fffb31a <sys_heap_aligned_alloc+0x40>
		return NULL;
1fffb300:	2500      	movs	r5, #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
1fffb302:	4628      	mov	r0, r5
1fffb304:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (align <= chunk_header_bytes(h)) {
1fffb308:	2904      	cmp	r1, #4
1fffb30a:	d804      	bhi.n	1fffb316 <sys_heap_aligned_alloc+0x3c>
}
1fffb30c:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			return sys_heap_alloc(heap, bytes);
1fffb310:	4611      	mov	r1, r2
1fffb312:	f7ff bfb9 	b.w	1fffb288 <sys_heap_alloc>
		gap = chunk_header_bytes(h);
1fffb316:	2204      	movs	r2, #4
1fffb318:	e7f1      	b.n	1fffb2fe <sys_heap_aligned_alloc+0x24>
	if (bytes == 0 || size_too_big(h, bytes)) {
1fffb31a:	68b3      	ldr	r3, [r6, #8]
1fffb31c:	ebb3 0fd4 	cmp.w	r3, r4, lsr #3
1fffb320:	d9ee      	bls.n	1fffb300 <sys_heap_aligned_alloc+0x26>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
1fffb322:	f104 010b 	add.w	r1, r4, #11
1fffb326:	4439      	add	r1, r7
1fffb328:	1a89      	subs	r1, r1, r2
	chunkid_t c0 = alloc_chunk(h, padded_sz);
1fffb32a:	08c9      	lsrs	r1, r1, #3
1fffb32c:	4630      	mov	r0, r6
1fffb32e:	f7ff ff04 	bl	1fffb13a <alloc_chunk>
	if (c0 == 0) {
1fffb332:	4680      	mov	r8, r0
1fffb334:	2800      	cmp	r0, #0
1fffb336:	d0e3      	beq.n	1fffb300 <sys_heap_aligned_alloc+0x26>
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
1fffb338:	f109 0504 	add.w	r5, r9, #4
1fffb33c:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
1fffb340:	1e7b      	subs	r3, r7, #1
1fffb342:	4435      	add	r5, r6
1fffb344:	441d      	add	r5, r3
1fffb346:	427f      	negs	r7, r7
1fffb348:	403d      	ands	r5, r7
1fffb34a:	eba5 0509 	sub.w	r5, r5, r9
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
1fffb34e:	442c      	add	r4, r5
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
1fffb350:	1f2b      	subs	r3, r5, #4
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
1fffb352:	3407      	adds	r4, #7
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
1fffb354:	1b9b      	subs	r3, r3, r6
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
1fffb356:	f024 0407 	bic.w	r4, r4, #7
	chunkid_t c_end = end - chunk_buf(h);
1fffb35a:	1ba4      	subs	r4, r4, r6
	if (c > c0) {
1fffb35c:	ebb0 0fd3 	cmp.w	r0, r3, lsr #3
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
1fffb360:	ea4f 07d3 	mov.w	r7, r3, lsr #3
	chunkid_t c_end = end - chunk_buf(h);
1fffb364:	ea4f 04e4 	mov.w	r4, r4, asr #3
	if (c > c0) {
1fffb368:	d208      	bcs.n	1fffb37c <sys_heap_aligned_alloc+0xa2>
		split_chunks(h, c0, c);
1fffb36a:	4601      	mov	r1, r0
1fffb36c:	463a      	mov	r2, r7
1fffb36e:	4630      	mov	r0, r6
1fffb370:	f7ff ff30 	bl	1fffb1d4 <split_chunks>
		free_list_add(h, c0);
1fffb374:	4641      	mov	r1, r8
1fffb376:	4630      	mov	r0, r6
1fffb378:	f7ff fe8e 	bl	1fffb098 <free_list_add>
	return c + chunk_size(h, c);
1fffb37c:	4639      	mov	r1, r7
1fffb37e:	4630      	mov	r0, r6
1fffb380:	f7ff fe85 	bl	1fffb08e <chunk_size>
1fffb384:	4438      	add	r0, r7
	if (right_chunk(h, c) > c_end) {
1fffb386:	4284      	cmp	r4, r0
1fffb388:	d207      	bcs.n	1fffb39a <sys_heap_aligned_alloc+0xc0>
		split_chunks(h, c, c_end);
1fffb38a:	4630      	mov	r0, r6
1fffb38c:	4622      	mov	r2, r4
1fffb38e:	f7ff ff21 	bl	1fffb1d4 <split_chunks>
		free_list_add(h, c_end);
1fffb392:	4621      	mov	r1, r4
1fffb394:	4630      	mov	r0, r6
1fffb396:	f7ff fe7f 	bl	1fffb098 <free_list_add>
	void *cmem = &buf[c];
1fffb39a:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
1fffb39e:	8873      	ldrh	r3, [r6, #2]
1fffb3a0:	f043 0301 	orr.w	r3, r3, #1
1fffb3a4:	8073      	strh	r3, [r6, #2]
1fffb3a6:	e7ac      	b.n	1fffb302 <sys_heap_aligned_alloc+0x28>

1fffb3a8 <sys_heap_init>:
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
1fffb3a8:	3a04      	subs	r2, #4
{
1fffb3aa:	b4f0      	push	{r4, r5, r6, r7}
1fffb3ac:	4604      	mov	r4, r0

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
1fffb3ae:	1dc8      	adds	r0, r1, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
1fffb3b0:	4411      	add	r1, r2
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
1fffb3b2:	f020 0007 	bic.w	r0, r0, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
1fffb3b6:	f021 0107 	bic.w	r1, r1, #7
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
1fffb3ba:	1a0e      	subs	r6, r1, r0
1fffb3bc:	08f3      	lsrs	r3, r6, #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
1fffb3be:	6020      	str	r0, [r4, #0]
	return 31 - __builtin_clz(usable_sz);
1fffb3c0:	fab3 f283 	clz	r2, r3
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;
1fffb3c4:	4604      	mov	r4, r0
	h->allocated_bytes = 0;
	h->max_allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
1fffb3c6:	f1c2 0524 	rsb	r5, r2, #36	; 0x24
	h->avail_buckets = 0;
1fffb3ca:	2700      	movs	r7, #0
	h->end_chunk = heap_sz;
1fffb3cc:	6083      	str	r3, [r0, #8]
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
1fffb3ce:	00ad      	lsls	r5, r5, #2
	h->avail_buckets = 0;
1fffb3d0:	f844 7f0c 	str.w	r7, [r4, #12]!
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
1fffb3d4:	3507      	adds	r5, #7
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
1fffb3d6:	f1c2 0220 	rsb	r2, r2, #32
1fffb3da:	08e9      	lsrs	r1, r5, #3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
1fffb3dc:	eb04 0282 	add.w	r2, r4, r2, lsl #2
		h->buckets[i].next = 0;
1fffb3e0:	f844 7f04 	str.w	r7, [r4, #4]!
	for (int i = 0; i < nb_buckets; i++) {
1fffb3e4:	4294      	cmp	r4, r2
1fffb3e6:	d1fb      	bne.n	1fffb3e0 <sys_heap_init+0x38>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
1fffb3e8:	004a      	lsls	r2, r1, #1
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
1fffb3ea:	f042 0201 	orr.w	r2, r2, #1
1fffb3ee:	8042      	strh	r2, [r0, #2]
		((uint16_t *)cmem)[f] = val;
1fffb3f0:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
1fffb3f4:	1a5a      	subs	r2, r3, r1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
1fffb3f6:	0055      	lsls	r5, r2, #1
		((uint16_t *)cmem)[f] = val;
1fffb3f8:	8007      	strh	r7, [r0, #0]
1fffb3fa:	8065      	strh	r5, [r4, #2]
1fffb3fc:	1984      	adds	r4, r0, r6
1fffb3fe:	f820 1031 	strh.w	r1, [r0, r1, lsl #3]
	void *cmem = &buf[c];
1fffb402:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
		((uint16_t *)cmem)[f] = val;
1fffb406:	8067      	strh	r7, [r4, #2]
1fffb408:	5382      	strh	r2, [r0, r6]
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
1fffb40a:	885a      	ldrh	r2, [r3, #2]
1fffb40c:	f042 0201 	orr.w	r2, r2, #1
1fffb410:	805a      	strh	r2, [r3, #2]
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
}
1fffb412:	bcf0      	pop	{r4, r5, r6, r7}
	free_list_add(h, chunk0_size);
1fffb414:	f7ff be40 	b.w	1fffb098 <free_list_add>

1fffb418 <encode_uint>:
{
1fffb418:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
1fffb41c:	469a      	mov	sl, r3
	bool upcase = isupper((int)conv->specifier);
1fffb41e:	78d3      	ldrb	r3, [r2, #3]
	switch (specifier) {
1fffb420:	2b6f      	cmp	r3, #111	; 0x6f
{
1fffb422:	4680      	mov	r8, r0
1fffb424:	460f      	mov	r7, r1
1fffb426:	4615      	mov	r5, r2
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
1fffb428:	f1a3 0b41 	sub.w	fp, r3, #65	; 0x41
	switch (specifier) {
1fffb42c:	d029      	beq.n	1fffb482 <encode_uint+0x6a>
1fffb42e:	d824      	bhi.n	1fffb47a <encode_uint+0x62>
		return 10;
1fffb430:	2b58      	cmp	r3, #88	; 0x58
1fffb432:	bf0c      	ite	eq
1fffb434:	2610      	moveq	r6, #16
1fffb436:	260a      	movne	r6, #10
	char *bp = bps + (bpe - bps);
1fffb438:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
		unsigned int lsv = (unsigned int)(value % radix);
1fffb43c:	4632      	mov	r2, r6
1fffb43e:	2300      	movs	r3, #0
1fffb440:	4640      	mov	r0, r8
1fffb442:	4639      	mov	r1, r7
1fffb444:	f7fc fefa 	bl	1fff823c <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
1fffb448:	2a09      	cmp	r2, #9
1fffb44a:	b2d4      	uxtb	r4, r2
1fffb44c:	d81e      	bhi.n	1fffb48c <encode_uint+0x74>
1fffb44e:	3430      	adds	r4, #48	; 0x30
	} while ((value != 0) && (bps < bp));
1fffb450:	45b0      	cmp	r8, r6
		*--bp = (lsv <= 9) ? ('0' + lsv)
1fffb452:	b2e4      	uxtb	r4, r4
	} while ((value != 0) && (bps < bp));
1fffb454:	f177 0700 	sbcs.w	r7, r7, #0
		*--bp = (lsv <= 9) ? ('0' + lsv)
1fffb458:	f809 4d01 	strb.w	r4, [r9, #-1]!
	} while ((value != 0) && (bps < bp));
1fffb45c:	d301      	bcc.n	1fffb462 <encode_uint+0x4a>
1fffb45e:	45d1      	cmp	r9, sl
1fffb460:	d811      	bhi.n	1fffb486 <encode_uint+0x6e>
	if (conv->flag_hash) {
1fffb462:	782b      	ldrb	r3, [r5, #0]
1fffb464:	069b      	lsls	r3, r3, #26
1fffb466:	d505      	bpl.n	1fffb474 <encode_uint+0x5c>
		if (radix == 8) {
1fffb468:	2e08      	cmp	r6, #8
1fffb46a:	d115      	bne.n	1fffb498 <encode_uint+0x80>
			conv->altform_0 = true;
1fffb46c:	78ab      	ldrb	r3, [r5, #2]
1fffb46e:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
1fffb472:	70ab      	strb	r3, [r5, #2]
}
1fffb474:	4648      	mov	r0, r9
1fffb476:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
1fffb47a:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 10;
1fffb47e:	2b70      	cmp	r3, #112	; 0x70
1fffb480:	e7d7      	b.n	1fffb432 <encode_uint+0x1a>
	switch (specifier) {
1fffb482:	2608      	movs	r6, #8
1fffb484:	e7d8      	b.n	1fffb438 <encode_uint+0x20>
		value /= radix;
1fffb486:	4680      	mov	r8, r0
1fffb488:	460f      	mov	r7, r1
1fffb48a:	e7d7      	b.n	1fffb43c <encode_uint+0x24>
		*--bp = (lsv <= 9) ? ('0' + lsv)
1fffb48c:	f1bb 0f19 	cmp.w	fp, #25
1fffb490:	bf94      	ite	ls
1fffb492:	3437      	addls	r4, #55	; 0x37
1fffb494:	3457      	addhi	r4, #87	; 0x57
1fffb496:	e7db      	b.n	1fffb450 <encode_uint+0x38>
		} else if (radix == 16) {
1fffb498:	2e10      	cmp	r6, #16
1fffb49a:	d1eb      	bne.n	1fffb474 <encode_uint+0x5c>
			conv->altform_0c = true;
1fffb49c:	78ab      	ldrb	r3, [r5, #2]
1fffb49e:	f043 0310 	orr.w	r3, r3, #16
1fffb4a2:	e7e6      	b.n	1fffb472 <encode_uint+0x5a>

1fffb4a4 <outs>:
{
1fffb4a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
1fffb4a8:	4607      	mov	r7, r0
1fffb4aa:	4688      	mov	r8, r1
1fffb4ac:	4615      	mov	r5, r2
1fffb4ae:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
1fffb4b0:	4614      	mov	r4, r2
1fffb4b2:	42b4      	cmp	r4, r6
1fffb4b4:	d305      	bcc.n	1fffb4c2 <outs+0x1e>
1fffb4b6:	b10e      	cbz	r6, 1fffb4bc <outs+0x18>
	return (int)count;
1fffb4b8:	1b60      	subs	r0, r4, r5
1fffb4ba:	e008      	b.n	1fffb4ce <outs+0x2a>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
1fffb4bc:	7823      	ldrb	r3, [r4, #0]
1fffb4be:	2b00      	cmp	r3, #0
1fffb4c0:	d0fa      	beq.n	1fffb4b8 <outs+0x14>
		int rc = out((int)*sp++, ctx);
1fffb4c2:	f814 0b01 	ldrb.w	r0, [r4], #1
1fffb4c6:	4641      	mov	r1, r8
1fffb4c8:	47b8      	blx	r7
		if (rc < 0) {
1fffb4ca:	2800      	cmp	r0, #0
1fffb4cc:	daf1      	bge.n	1fffb4b2 <outs+0xe>
}
1fffb4ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

1fffb4d2 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_ENFORCE_ZEPHYR_STDINT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
1fffb4d2:	4770      	bx	lr

1fffb4d4 <z_arm_fatal_error>:
{

	if (esf != NULL) {
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
1fffb4d4:	f001 b929 	b.w	1fffc72a <z_fatal_error>

1fffb4d8 <z_do_kernel_oops>:
 *
 * @param esf exception frame
 * @param callee_regs Callee-saved registers (R4-R11)
 */
void z_do_kernel_oops(const z_arch_esf_t *esf, _callee_saved_t *callee_regs)
{
1fffb4d8:	4601      	mov	r1, r0
	z_fatal_error(reason, esf);
1fffb4da:	6800      	ldr	r0, [r0, #0]
1fffb4dc:	f001 b925 	b.w	1fffc72a <z_fatal_error>

1fffb4e0 <z_irq_spurious>:
 */
void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
1fffb4e0:	2100      	movs	r1, #0
1fffb4e2:	2001      	movs	r0, #1
1fffb4e4:	f7ff bff6 	b.w	1fffb4d4 <z_arm_fatal_error>

1fffb4e8 <z_arm_nmi>:
 * Simply call what is installed in 'static void(*handler)(void)'.
 *
 */

void z_arm_nmi(void)
{
1fffb4e8:	b508      	push	{r3, lr}
	handler();
1fffb4ea:	f7fd fed9 	bl	1fff92a0 <z_SysNmiOnReset>
	z_arm_int_exit();
}
1fffb4ee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
1fffb4f2:	f7fd bf8d 	b.w	1fff9410 <z_arm_exc_exit>

1fffb4f6 <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *ZRESTRICT d, const char *ZRESTRICT s, size_t n)
{
1fffb4f6:	b510      	push	{r4, lr}
1fffb4f8:	3901      	subs	r1, #1
	char *dest = d;

	while ((n > 0) && *s != '\0') {
1fffb4fa:	4603      	mov	r3, r0
1fffb4fc:	b922      	cbnz	r2, 1fffb508 <strncpy+0x12>
1fffb4fe:	441a      	add	r2, r3
		d++;
		n--;
	}

	while (n > 0) {
		*d = '\0';
1fffb500:	2100      	movs	r1, #0
	while (n > 0) {
1fffb502:	4293      	cmp	r3, r2
1fffb504:	d108      	bne.n	1fffb518 <strncpy+0x22>
		d++;
		n--;
	}

	return dest;
}
1fffb506:	bd10      	pop	{r4, pc}
	while ((n > 0) && *s != '\0') {
1fffb508:	f811 4f01 	ldrb.w	r4, [r1, #1]!
1fffb50c:	2c00      	cmp	r4, #0
1fffb50e:	d0f6      	beq.n	1fffb4fe <strncpy+0x8>
		*d = *s;
1fffb510:	f803 4b01 	strb.w	r4, [r3], #1
		n--;
1fffb514:	3a01      	subs	r2, #1
1fffb516:	e7f1      	b.n	1fffb4fc <strncpy+0x6>
		*d = '\0';
1fffb518:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
1fffb51c:	e7f1      	b.n	1fffb502 <strncpy+0xc>

1fffb51e <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
1fffb51e:	4603      	mov	r3, r0
	size_t n = 0;
1fffb520:	2000      	movs	r0, #0

	while (*s != '\0') {
1fffb522:	5c1a      	ldrb	r2, [r3, r0]
1fffb524:	b902      	cbnz	r2, 1fffb528 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
1fffb526:	4770      	bx	lr
		n++;
1fffb528:	3001      	adds	r0, #1
1fffb52a:	e7fa      	b.n	1fffb522 <strlen+0x4>

1fffb52c <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
1fffb52c:	4603      	mov	r3, r0
	size_t n = 0;
1fffb52e:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
1fffb530:	5c1a      	ldrb	r2, [r3, r0]
1fffb532:	b10a      	cbz	r2, 1fffb538 <strnlen+0xc>
1fffb534:	4288      	cmp	r0, r1
1fffb536:	d100      	bne.n	1fffb53a <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
1fffb538:	4770      	bx	lr
		n++;
1fffb53a:	3001      	adds	r0, #1
1fffb53c:	e7f8      	b.n	1fffb530 <strnlen+0x4>

1fffb53e <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
1fffb53e:	1e43      	subs	r3, r0, #1
1fffb540:	3901      	subs	r1, #1
1fffb542:	f813 2f01 	ldrb.w	r2, [r3, #1]!
1fffb546:	f811 0f01 	ldrb.w	r0, [r1, #1]!
1fffb54a:	4282      	cmp	r2, r0
1fffb54c:	d101      	bne.n	1fffb552 <strcmp+0x14>
1fffb54e:	2a00      	cmp	r2, #0
1fffb550:	d1f7      	bne.n	1fffb542 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
1fffb552:	1a10      	subs	r0, r2, r0
1fffb554:	4770      	bx	lr

1fffb556 <strncmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
1fffb556:	b570      	push	{r4, r5, r6, lr}
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
1fffb558:	460b      	mov	r3, r1
1fffb55a:	4605      	mov	r5, r0
1fffb55c:	b16a      	cbz	r2, 1fffb57a <strncmp+0x24>
1fffb55e:	f810 6b01 	ldrb.w	r6, [r0], #1
1fffb562:	781c      	ldrb	r4, [r3, #0]
1fffb564:	42b4      	cmp	r4, r6
1fffb566:	f101 0101 	add.w	r1, r1, #1
1fffb56a:	d100      	bne.n	1fffb56e <strncmp+0x18>
1fffb56c:	b91c      	cbnz	r4, 1fffb576 <strncmp+0x20>
		s1++;
		s2++;
		n--;
	}

	return (n == 0) ? 0 : (*s1 - *s2);
1fffb56e:	782a      	ldrb	r2, [r5, #0]
1fffb570:	781b      	ldrb	r3, [r3, #0]
1fffb572:	1ad0      	subs	r0, r2, r3
1fffb574:	e002      	b.n	1fffb57c <strncmp+0x26>
		n--;
1fffb576:	3a01      	subs	r2, #1
1fffb578:	e7ee      	b.n	1fffb558 <strncmp+0x2>
	return (n == 0) ? 0 : (*s1 - *s2);
1fffb57a:	4610      	mov	r0, r2
}
1fffb57c:	bd70      	pop	{r4, r5, r6, pc}

1fffb57e <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
1fffb57e:	b510      	push	{r4, lr}
1fffb580:	1e43      	subs	r3, r0, #1
1fffb582:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
1fffb584:	4291      	cmp	r1, r2
1fffb586:	d100      	bne.n	1fffb58a <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
1fffb588:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
1fffb58a:	f811 4b01 	ldrb.w	r4, [r1], #1
1fffb58e:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
1fffb592:	e7f7      	b.n	1fffb584 <memcpy+0x6>

1fffb594 <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
1fffb594:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
1fffb596:	4402      	add	r2, r0
	unsigned char *d_byte = (unsigned char *)buf;
1fffb598:	4603      	mov	r3, r0
	while (n > 0) {
1fffb59a:	4293      	cmp	r3, r2
1fffb59c:	d100      	bne.n	1fffb5a0 <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
1fffb59e:	4770      	bx	lr
		*(d_byte++) = c_byte;
1fffb5a0:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
1fffb5a4:	e7f9      	b.n	1fffb59a <memset+0x6>

1fffb5a6 <_stdout_hook_default>:
}
1fffb5a6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
1fffb5aa:	4770      	bx	lr

1fffb5ac <sprintf_out>:
	if (p->len > 1) { /* need to reserve a byte for EOS */
1fffb5ac:	684b      	ldr	r3, [r1, #4]
1fffb5ae:	2b01      	cmp	r3, #1
1fffb5b0:	dd07      	ble.n	1fffb5c2 <sprintf_out+0x16>
		*(p->ptr) = c;
1fffb5b2:	680b      	ldr	r3, [r1, #0]
1fffb5b4:	7018      	strb	r0, [r3, #0]
		p->ptr += 1;
1fffb5b6:	680b      	ldr	r3, [r1, #0]
1fffb5b8:	3301      	adds	r3, #1
1fffb5ba:	600b      	str	r3, [r1, #0]
		p->len -= 1;
1fffb5bc:	684b      	ldr	r3, [r1, #4]
1fffb5be:	3b01      	subs	r3, #1
1fffb5c0:	604b      	str	r3, [r1, #4]
}
1fffb5c2:	2000      	movs	r0, #0
1fffb5c4:	4770      	bx	lr

1fffb5c6 <imx_gpio_port_get_raw>:
}

static int imx_gpio_port_get_raw(const struct device *port, uint32_t *value)
{
	const struct imx_gpio_config *config = port->config;
	GPIO_Type *base = config->base;
1fffb5c6:	6843      	ldr	r3, [r0, #4]
1fffb5c8:	685b      	ldr	r3, [r3, #4]
 * @param base GPIO base pointer.
 * @return GPIO port input data.
 */
static inline uint32_t GPIO_ReadPortInput(GPIO_Type* base)
{
    return GPIO_DR_REG(base);
1fffb5ca:	681b      	ldr	r3, [r3, #0]

	*value = GPIO_ReadPortInput(base);
1fffb5cc:	600b      	str	r3, [r1, #0]

	return 0;
}
1fffb5ce:	2000      	movs	r0, #0
1fffb5d0:	4770      	bx	lr

1fffb5d2 <imx_gpio_port_set_masked_raw>:
static int imx_gpio_port_set_masked_raw(const struct device *port,
					gpio_port_pins_t mask,
					gpio_port_value_t value)
{
	const struct imx_gpio_config *config = port->config;
	GPIO_Type *base = config->base;
1fffb5d2:	6843      	ldr	r3, [r0, #4]
1fffb5d4:	685b      	ldr	r3, [r3, #4]
1fffb5d6:	6818      	ldr	r0, [r3, #0]

	GPIO_WritePortOutput(base,
1fffb5d8:	4042      	eors	r2, r0
1fffb5da:	400a      	ands	r2, r1
1fffb5dc:	4042      	eors	r2, r0
 * @param base GPIO base pointer.
 * @param portVal data to configure the GPIO output.
 */
static inline void GPIO_WritePortOutput(GPIO_Type* base, uint32_t portVal)
{
    GPIO_DR_REG(base) = portVal;
1fffb5de:	601a      	str	r2, [r3, #0]
			(GPIO_ReadPortInput(base) & ~mask) | (value & mask));

	return 0;
}
1fffb5e0:	2000      	movs	r0, #0
1fffb5e2:	4770      	bx	lr

1fffb5e4 <imx_gpio_port_set_bits_raw>:

static int imx_gpio_port_set_bits_raw(const struct device *port,
				      gpio_port_pins_t pins)
{
	const struct imx_gpio_config *config = port->config;
	GPIO_Type *base = config->base;
1fffb5e4:	6843      	ldr	r3, [r0, #4]
1fffb5e6:	685b      	ldr	r3, [r3, #4]
    return GPIO_DR_REG(base);
1fffb5e8:	681a      	ldr	r2, [r3, #0]

	GPIO_WritePortOutput(base, GPIO_ReadPortInput(base) | pins);
1fffb5ea:	4311      	orrs	r1, r2
    GPIO_DR_REG(base) = portVal;
1fffb5ec:	6019      	str	r1, [r3, #0]

	return 0;
}
1fffb5ee:	2000      	movs	r0, #0
1fffb5f0:	4770      	bx	lr

1fffb5f2 <imx_gpio_port_clear_bits_raw>:

static int imx_gpio_port_clear_bits_raw(const struct device *port,
					gpio_port_pins_t pins)
{
	const struct imx_gpio_config *config = port->config;
	GPIO_Type *base = config->base;
1fffb5f2:	6843      	ldr	r3, [r0, #4]
1fffb5f4:	685a      	ldr	r2, [r3, #4]
    return GPIO_DR_REG(base);
1fffb5f6:	6813      	ldr	r3, [r2, #0]

	GPIO_WritePortOutput(base, GPIO_ReadPortInput(base) & ~pins);
1fffb5f8:	ea23 0301 	bic.w	r3, r3, r1
    GPIO_DR_REG(base) = portVal;
1fffb5fc:	6013      	str	r3, [r2, #0]

	return 0;
}
1fffb5fe:	2000      	movs	r0, #0
1fffb600:	4770      	bx	lr

1fffb602 <imx_gpio_port_toggle_bits>:

static int imx_gpio_port_toggle_bits(const struct device *port,
				     gpio_port_pins_t pins)
{
	const struct imx_gpio_config *config = port->config;
	GPIO_Type *base = config->base;
1fffb602:	6843      	ldr	r3, [r0, #4]
1fffb604:	685b      	ldr	r3, [r3, #4]
    return GPIO_DR_REG(base);
1fffb606:	681a      	ldr	r2, [r3, #0]

	GPIO_WritePortOutput(base, GPIO_ReadPortInput(base) ^ pins);
1fffb608:	4051      	eors	r1, r2
    GPIO_DR_REG(base) = portVal;
1fffb60a:	6019      	str	r1, [r3, #0]

	return 0;
}
1fffb60c:	2000      	movs	r0, #0
1fffb60e:	4770      	bx	lr

1fffb610 <imx_gpio_pin_interrupt_configure>:

static int imx_gpio_pin_interrupt_configure(const struct device *port,
					    gpio_pin_t pin,
					    enum gpio_int_mode mode,
					    enum gpio_int_trig trig)
{
1fffb610:	b5f0      	push	{r4, r5, r6, r7, lr}
	const struct imx_gpio_config *config = port->config;
	GPIO_Type *base = config->base;
1fffb612:	6840      	ldr	r0, [r0, #4]
1fffb614:	6845      	ldr	r5, [r0, #4]
	volatile uint32_t *icr_reg;
	unsigned int key;
	uint32_t icr_val;
	uint8_t shift;

	if (((base->GDIR & BIT(pin)) != 0U)
1fffb616:	6868      	ldr	r0, [r5, #4]
1fffb618:	40c8      	lsrs	r0, r1
1fffb61a:	f010 0001 	ands.w	r0, r0, #1
1fffb61e:	d03d      	beq.n	1fffb69c <imx_gpio_pin_interrupt_configure+0x8c>
	    && (mode != GPIO_INT_MODE_DISABLED)) {
1fffb620:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
1fffb624:	d159      	bne.n	1fffb6da <imx_gpio_pin_interrupt_configure+0xca>
		icr_val = 2U;
	} else if ((mode == GPIO_INT_MODE_LEVEL) &&
		   (trig == GPIO_INT_TRIG_HIGH)) {
		icr_val = 1U;
	} else {
		icr_val = 0U;
1fffb626:	2000      	movs	r0, #0
	}

	if (pin < 16U) {
1fffb628:	290f      	cmp	r1, #15
1fffb62a:	d84d      	bhi.n	1fffb6c8 <imx_gpio_pin_interrupt_configure+0xb8>
		shift = 2U * pin;
1fffb62c:	004c      	lsls	r4, r1, #1
1fffb62e:	b2e4      	uxtb	r4, r4
		icr_reg = &(base->ICR1);
1fffb630:	f105 0c0c 	add.w	ip, r5, #12
	__asm__ volatile(
1fffb634:	f04f 0710 	mov.w	r7, #16
1fffb638:	f3ef 8611 	mrs	r6, BASEPRI
1fffb63c:	f387 8812 	msr	BASEPRI_MAX, r7
1fffb640:	f3bf 8f6f 	isb	sy
		return -EINVAL;
	}

	key = irq_lock();

	*icr_reg = (*icr_reg & ~(3U << shift)) | (icr_val << shift);
1fffb644:	f04f 0e03 	mov.w	lr, #3
1fffb648:	f8dc 7000 	ldr.w	r7, [ip]
1fffb64c:	fa0e fe04 	lsl.w	lr, lr, r4
1fffb650:	ea27 070e 	bic.w	r7, r7, lr
1fffb654:	40a0      	lsls	r0, r4
1fffb656:	4338      	orrs	r0, r7
1fffb658:	f8cc 0000 	str.w	r0, [ip]

	WRITE_BIT(base->EDGE_SEL, pin, trig == GPIO_INT_TRIG_BOTH);
1fffb65c:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
1fffb660:	f04f 0001 	mov.w	r0, #1
1fffb664:	69eb      	ldr	r3, [r5, #28]
1fffb666:	fa00 f101 	lsl.w	r1, r0, r1
1fffb66a:	bf0c      	ite	eq
1fffb66c:	430b      	orreq	r3, r1
1fffb66e:	438b      	bicne	r3, r1
1fffb670:	61eb      	str	r3, [r5, #28]
	WRITE_BIT(base->ISR, pin, mode != GPIO_INT_MODE_DISABLED);
1fffb672:	69ab      	ldr	r3, [r5, #24]
1fffb674:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
1fffb678:	bf15      	itete	ne
1fffb67a:	430b      	orrne	r3, r1
1fffb67c:	438b      	biceq	r3, r1
1fffb67e:	61ab      	strne	r3, [r5, #24]
1fffb680:	61ab      	streq	r3, [r5, #24]
	WRITE_BIT(base->IMR, pin, mode != GPIO_INT_MODE_DISABLED);
1fffb682:	bf15      	itete	ne
1fffb684:	696b      	ldrne	r3, [r5, #20]
1fffb686:	696b      	ldreq	r3, [r5, #20]
1fffb688:	4319      	orrne	r1, r3
1fffb68a:	ea23 0101 	biceq.w	r1, r3, r1
1fffb68e:	6169      	str	r1, [r5, #20]
	__asm__ volatile(
1fffb690:	f386 8811 	msr	BASEPRI, r6
1fffb694:	f3bf 8f6f 	isb	sy

	irq_unlock(key);

	return 0;
1fffb698:	2000      	movs	r0, #0
}
1fffb69a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if ((mode == GPIO_INT_MODE_EDGE) && (trig == GPIO_INT_TRIG_LOW)) {
1fffb69c:	f1b2 7fa0 	cmp.w	r2, #20971520	; 0x1400000
1fffb6a0:	d108      	bne.n	1fffb6b4 <imx_gpio_pin_interrupt_configure+0xa4>
1fffb6a2:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
1fffb6a6:	d00d      	beq.n	1fffb6c4 <imx_gpio_pin_interrupt_configure+0xb4>
	} else if ((mode == GPIO_INT_MODE_EDGE) &&
1fffb6a8:	f103 467c 	add.w	r6, r3, #4227858432	; 0xfc000000
1fffb6ac:	4270      	negs	r0, r6
1fffb6ae:	4170      	adcs	r0, r6
1fffb6b0:	0040      	lsls	r0, r0, #1
1fffb6b2:	e7b9      	b.n	1fffb628 <imx_gpio_pin_interrupt_configure+0x18>
	} else if ((mode == GPIO_INT_MODE_LEVEL) &&
1fffb6b4:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
1fffb6b8:	d1b6      	bne.n	1fffb628 <imx_gpio_pin_interrupt_configure+0x18>
1fffb6ba:	f103 447c 	add.w	r4, r3, #4227858432	; 0xfc000000
1fffb6be:	4260      	negs	r0, r4
1fffb6c0:	4160      	adcs	r0, r4
1fffb6c2:	e7b1      	b.n	1fffb628 <imx_gpio_pin_interrupt_configure+0x18>
		icr_val = 3U;
1fffb6c4:	2003      	movs	r0, #3
1fffb6c6:	e7af      	b.n	1fffb628 <imx_gpio_pin_interrupt_configure+0x18>
	} else if (pin < 32U) {
1fffb6c8:	291f      	cmp	r1, #31
1fffb6ca:	d809      	bhi.n	1fffb6e0 <imx_gpio_pin_interrupt_configure+0xd0>
		shift = 2U * (pin - 16U);
1fffb6cc:	f1a1 0410 	sub.w	r4, r1, #16
1fffb6d0:	0064      	lsls	r4, r4, #1
1fffb6d2:	b2e4      	uxtb	r4, r4
		icr_reg = &(base->ICR2);
1fffb6d4:	f105 0c10 	add.w	ip, r5, #16
1fffb6d8:	e7ac      	b.n	1fffb634 <imx_gpio_pin_interrupt_configure+0x24>
		return -ENOTSUP;
1fffb6da:	f06f 0085 	mvn.w	r0, #133	; 0x85
1fffb6de:	e7dc      	b.n	1fffb69a <imx_gpio_pin_interrupt_configure+0x8a>
		return -EINVAL;
1fffb6e0:	f06f 0015 	mvn.w	r0, #21
1fffb6e4:	e7d9      	b.n	1fffb69a <imx_gpio_pin_interrupt_configure+0x8a>

1fffb6e6 <imx_gpio_manage_callback>:

static int imx_gpio_manage_callback(const struct device *port,
				    struct gpio_callback *cb, bool set)
{
1fffb6e6:	b510      	push	{r4, lr}
	struct imx_gpio_data *data = port->data;
1fffb6e8:	6903      	ldr	r3, [r0, #16]
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
1fffb6ea:	6858      	ldr	r0, [r3, #4]
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
1fffb6ec:	b1f8      	cbz	r0, 1fffb72e <imx_gpio_manage_callback+0x48>
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
1fffb6ee:	4288      	cmp	r0, r1
1fffb6f0:	d119      	bne.n	1fffb726 <imx_gpio_manage_callback+0x40>
Z_GENLIST_REMOVE(slist, snode)
1fffb6f2:	689c      	ldr	r4, [r3, #8]
	return node->next;
1fffb6f4:	6808      	ldr	r0, [r1, #0]
	list->head = node;
1fffb6f6:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
1fffb6f8:	42a1      	cmp	r1, r4
1fffb6fa:	d100      	bne.n	1fffb6fe <imx_gpio_manage_callback+0x18>
	list->tail = node;
1fffb6fc:	6098      	str	r0, [r3, #8]
	parent->next = child;
1fffb6fe:	2000      	movs	r0, #0
1fffb700:	6008      	str	r0, [r1, #0]
		}
	} else if (!set) {
		return -EINVAL;
	}

	if (set) {
1fffb702:	b12a      	cbz	r2, 1fffb710 <imx_gpio_manage_callback+0x2a>
	return list->head;
1fffb704:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
1fffb706:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
1fffb708:	689a      	ldr	r2, [r3, #8]
	list->head = node;
1fffb70a:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
1fffb70c:	b902      	cbnz	r2, 1fffb710 <imx_gpio_manage_callback+0x2a>
	list->tail = node;
1fffb70e:	6099      	str	r1, [r3, #8]
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
1fffb710:	2000      	movs	r0, #0

	return gpio_manage_callback(&data->callbacks, cb, set);
1fffb712:	e010      	b.n	1fffb736 <imx_gpio_manage_callback+0x50>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
1fffb714:	4281      	cmp	r1, r0
1fffb716:	d106      	bne.n	1fffb726 <imx_gpio_manage_callback+0x40>
	return node->next;
1fffb718:	6808      	ldr	r0, [r1, #0]
	parent->next = child;
1fffb71a:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
1fffb71c:	6898      	ldr	r0, [r3, #8]
1fffb71e:	4281      	cmp	r1, r0
1fffb720:	d1ed      	bne.n	1fffb6fe <imx_gpio_manage_callback+0x18>
	list->tail = node;
1fffb722:	609c      	str	r4, [r3, #8]
}
1fffb724:	e7eb      	b.n	1fffb6fe <imx_gpio_manage_callback+0x18>
	return node->next;
1fffb726:	4604      	mov	r4, r0
1fffb728:	6800      	ldr	r0, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
1fffb72a:	2800      	cmp	r0, #0
1fffb72c:	d1f2      	bne.n	1fffb714 <imx_gpio_manage_callback+0x2e>
			if (!set) {
1fffb72e:	2a00      	cmp	r2, #0
1fffb730:	d1e8      	bne.n	1fffb704 <imx_gpio_manage_callback+0x1e>
				return -EINVAL;
1fffb732:	f06f 0015 	mvn.w	r0, #21
}
1fffb736:	bd10      	pop	{r4, pc}

1fffb738 <imx_gpio_configure>:
{
1fffb738:	b5f0      	push	{r4, r5, r6, r7, lr}
1fffb73a:	4614      	mov	r4, r2
	const struct imx_gpio_config *config = port->config;
1fffb73c:	6843      	ldr	r3, [r0, #4]
	if (((flags & GPIO_INPUT) != 0U) && ((flags & GPIO_OUTPUT) != 0U)) {
1fffb73e:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
1fffb742:	f5b2 3f40 	cmp.w	r2, #196608	; 0x30000
	GPIO_Type *base = config->base;
1fffb746:	685e      	ldr	r6, [r3, #4]
{
1fffb748:	b087      	sub	sp, #28
1fffb74a:	460f      	mov	r7, r1
	if (((flags & GPIO_INPUT) != 0U) && ((flags & GPIO_OUTPUT) != 0U)) {
1fffb74c:	d041      	beq.n	1fffb7d2 <imx_gpio_configure+0x9a>
		(volatile uint32_t *)config->pin_muxes[pin].config_register;
1fffb74e:	6899      	ldr	r1, [r3, #8]
1fffb750:	eb01 1107 	add.w	r1, r1, r7, lsl #4
	if ((flags & GPIO_SINGLE_ENDED) != 0) {
1fffb754:	07a2      	lsls	r2, r4, #30
	volatile uint32_t *gpio_cfg_reg =
1fffb756:	684b      	ldr	r3, [r1, #4]
	uint32_t reg = *gpio_cfg_reg;
1fffb758:	681d      	ldr	r5, [r3, #0]
	if ((flags & GPIO_SINGLE_ENDED) != 0) {
1fffb75a:	d43a      	bmi.n	1fffb7d2 <imx_gpio_configure+0x9a>
	if (((flags & GPIO_PULL_UP) != 0) || ((flags & GPIO_PULL_DOWN) != 0)) {
1fffb75c:	f014 0f30 	tst.w	r4, #48	; 0x30
1fffb760:	d028      	beq.n	1fffb7b4 <imx_gpio_configure+0x7c>
		if (((flags & GPIO_PULL_UP) != 0)) {
1fffb762:	06e3      	lsls	r3, r4, #27
			reg |= BIT(MCUX_IMX_BIAS_PULL_UP_SHIFT);
1fffb764:	bf56      	itet	pl
1fffb766:	f025 0520 	bicpl.w	r5, r5, #32
1fffb76a:	f045 0530 	orrmi.w	r5, r5, #48	; 0x30
			reg &= ~BIT(MCUX_IMX_BIAS_PULL_UP_SHIFT);
1fffb76e:	f045 0510 	orrpl.w	r5, r5, #16
	memcpy(&pin_cfg.pinmux, &config->pin_muxes[pin], sizeof(pin_cfg));
1fffb772:	2214      	movs	r2, #20
1fffb774:	a801      	add	r0, sp, #4
1fffb776:	f7ff ff02 	bl	1fffb57e <memcpy>
	pinctrl_configure_pins(&pin_cfg, 1, PINCTRL_REG_NONE);
1fffb77a:	2200      	movs	r2, #0
1fffb77c:	2101      	movs	r1, #1
1fffb77e:	a801      	add	r0, sp, #4
	pin_cfg.pin_ctrl_flags = reg;
1fffb780:	9505      	str	r5, [sp, #20]
	pinctrl_configure_pins(&pin_cfg, 1, PINCTRL_REG_NONE);
1fffb782:	f000 f95b 	bl	1fffba3c <pinctrl_configure_pins>
	GPIO_SetPinIntMode(base, pin, false);
1fffb786:	2200      	movs	r2, #0
1fffb788:	4639      	mov	r1, r7
1fffb78a:	4630      	mov	r0, r6
1fffb78c:	f000 fa27 	bl	1fffbbde <GPIO_SetPinIntMode>
	GPIO_SetIntEdgeSelect(base, pin, false);
1fffb790:	2200      	movs	r2, #0
1fffb792:	4630      	mov	r0, r6
1fffb794:	4639      	mov	r1, r7
1fffb796:	f000 fa2d 	bl	1fffbbf4 <GPIO_SetIntEdgeSelect>
		WRITE_BIT(base->GDIR, pin, 1U);
1fffb79a:	2201      	movs	r2, #1
	if ((flags & GPIO_OUTPUT) != 0U) {
1fffb79c:	03a0      	lsls	r0, r4, #14
		WRITE_BIT(base->GDIR, pin, 1U);
1fffb79e:	fa02 f507 	lsl.w	r5, r2, r7
	if ((flags & GPIO_OUTPUT) != 0U) {
1fffb7a2:	d512      	bpl.n	1fffb7ca <imx_gpio_configure+0x92>
		if ((flags & GPIO_OUTPUT_INIT_LOW) != 0U) {
1fffb7a4:	0361      	lsls	r1, r4, #13
1fffb7a6:	d508      	bpl.n	1fffb7ba <imx_gpio_configure+0x82>
			GPIO_WritePinOutput(base, pin, gpioPinClear);
1fffb7a8:	2200      	movs	r2, #0
			GPIO_WritePinOutput(base, pin, gpioPinSet);
1fffb7aa:	4639      	mov	r1, r7
1fffb7ac:	4630      	mov	r0, r6
1fffb7ae:	f000 fa0c 	bl	1fffbbca <GPIO_WritePinOutput>
1fffb7b2:	e004      	b.n	1fffb7be <imx_gpio_configure+0x86>
		reg &= ~BIT(MCUX_IMX_PULL_ENABLE_SHIFT);
1fffb7b4:	f025 0510 	bic.w	r5, r5, #16
1fffb7b8:	e7db      	b.n	1fffb772 <imx_gpio_configure+0x3a>
		} else if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0U) {
1fffb7ba:	0323      	lsls	r3, r4, #12
1fffb7bc:	d4f5      	bmi.n	1fffb7aa <imx_gpio_configure+0x72>
		WRITE_BIT(base->GDIR, pin, 1U);
1fffb7be:	6873      	ldr	r3, [r6, #4]
1fffb7c0:	432b      	orrs	r3, r5
		WRITE_BIT(base->GDIR, pin, 0U);
1fffb7c2:	6073      	str	r3, [r6, #4]
	return 0;
1fffb7c4:	2000      	movs	r0, #0
}
1fffb7c6:	b007      	add	sp, #28
1fffb7c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		WRITE_BIT(base->GDIR, pin, 0U);
1fffb7ca:	6873      	ldr	r3, [r6, #4]
1fffb7cc:	ea23 0305 	bic.w	r3, r3, r5
1fffb7d0:	e7f7      	b.n	1fffb7c2 <imx_gpio_configure+0x8a>
		return -ENOTSUP;
1fffb7d2:	f06f 0085 	mvn.w	r0, #133	; 0x85
1fffb7d6:	e7f6      	b.n	1fffb7c6 <imx_gpio_configure+0x8e>

1fffb7d8 <imx_gpio_0_init>:
		irq_enable(DT_INST_IRQ_BY_IDX(n, 1, irq));		\
									\
		return 0;						\
	}

DT_INST_FOREACH_STATUS_OKAY(GPIO_IMX_INIT)
1fffb7d8:	2200      	movs	r2, #0
1fffb7da:	b508      	push	{r3, lr}
1fffb7dc:	4611      	mov	r1, r2
1fffb7de:	2042      	movs	r0, #66	; 0x42
1fffb7e0:	f7fd fd46 	bl	1fff9270 <z_arm_irq_priority_set>
1fffb7e4:	2042      	movs	r0, #66	; 0x42
1fffb7e6:	f7fd fd35 	bl	1fff9254 <arch_irq_enable>
1fffb7ea:	2200      	movs	r2, #0
1fffb7ec:	4611      	mov	r1, r2
1fffb7ee:	2043      	movs	r0, #67	; 0x43
1fffb7f0:	f7fd fd3e 	bl	1fff9270 <z_arm_irq_priority_set>
1fffb7f4:	2043      	movs	r0, #67	; 0x43
1fffb7f6:	f7fd fd2d 	bl	1fff9254 <arch_irq_enable>
1fffb7fa:	2000      	movs	r0, #0
1fffb7fc:	bd08      	pop	{r3, pc}

1fffb7fe <imx_gpio_port_isr>:
{
1fffb7fe:	b570      	push	{r4, r5, r6, lr}
	int_status = config->base->ISR;
1fffb800:	6843      	ldr	r3, [r0, #4]
	struct imx_gpio_data *data = port->data;
1fffb802:	6902      	ldr	r2, [r0, #16]
	int_status = config->base->ISR;
1fffb804:	685b      	ldr	r3, [r3, #4]
1fffb806:	699e      	ldr	r6, [r3, #24]
	config->base->ISR = int_status;
1fffb808:	619e      	str	r6, [r3, #24]
	gpio_fire_callbacks(&data->callbacks, port, int_status);
1fffb80a:	6851      	ldr	r1, [r2, #4]
{
1fffb80c:	4605      	mov	r5, r0
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
1fffb80e:	b109      	cbz	r1, 1fffb814 <imx_gpio_port_isr+0x16>
	return node->next;
1fffb810:	680c      	ldr	r4, [r1, #0]
1fffb812:	b901      	cbnz	r1, 1fffb816 <imx_gpio_port_isr+0x18>
}
1fffb814:	bd70      	pop	{r4, r5, r6, pc}
		if (cb->pin_mask & pins) {
1fffb816:	688a      	ldr	r2, [r1, #8]
1fffb818:	4032      	ands	r2, r6
1fffb81a:	d002      	beq.n	1fffb822 <imx_gpio_port_isr+0x24>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
1fffb81c:	684b      	ldr	r3, [r1, #4]
1fffb81e:	4628      	mov	r0, r5
1fffb820:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
1fffb822:	b11c      	cbz	r4, 1fffb82c <imx_gpio_port_isr+0x2e>
1fffb824:	6823      	ldr	r3, [r4, #0]
1fffb826:	4621      	mov	r1, r4
1fffb828:	461c      	mov	r4, r3
1fffb82a:	e7f2      	b.n	1fffb812 <imx_gpio_port_isr+0x14>
1fffb82c:	4623      	mov	r3, r4
1fffb82e:	e7fa      	b.n	1fffb826 <imx_gpio_port_isr+0x28>

1fffb830 <imx_mu_ipm_max_data_size_get>:
static int imx_mu_ipm_max_data_size_get(const struct device *dev)
{
	ARG_UNUSED(dev);

	return CONFIG_IPM_IMX_MAX_DATA_SIZE;
}
1fffb830:	2010      	movs	r0, #16
1fffb832:	4770      	bx	lr

1fffb834 <imx_mu_ipm_max_id_val_get>:
static uint32_t imx_mu_ipm_max_id_val_get(const struct device *dev)
{
	ARG_UNUSED(dev);

	return CONFIG_IPM_IMX_MAX_ID_VAL;
}
1fffb834:	2000      	movs	r0, #0
1fffb836:	4770      	bx	lr

1fffb838 <imx_mu_ipm_register_callback>:

static void imx_mu_ipm_register_callback(const struct device *dev,
					 ipm_callback_t cb,
					 void *user_data)
{
	struct imx_mu_data *driver_data = dev->data;
1fffb838:	6903      	ldr	r3, [r0, #16]

	driver_data->callback = cb;
	driver_data->user_data = user_data;
1fffb83a:	e9c3 1200 	strd	r1, r2, [r3]
}
1fffb83e:	4770      	bx	lr

1fffb840 <imx_mu_ipm_set_enabled>:

static int imx_mu_ipm_set_enabled(const struct device *dev, int enable)
{
	const struct imx_mu_config *config = dev->config;
	MU_Type *base = MU(config);
1fffb840:	6843      	ldr	r3, [r0, #4]
1fffb842:	681a      	ldr	r2, [r3, #0]
   MU_EnableRxFullInt(MU0_BASE, 0U);
   @endcode
 */
static inline void MU_EnableRxFullInt(MU_Type * base, uint32_t index)
{
    base->CR = (base->CR & ~MU_CR_GIRn_MASK)  // Clear GIRn
1fffb844:	6a53      	ldr	r3, [r2, #36]	; 0x24
	} else {
		MU_DisableRxFullInt(base, 1U);
		MU_DisableRxFullInt(base, 3U);
	}
#elif CONFIG_IPM_IMX_MAX_DATA_SIZE_16
	if (enable) {
1fffb846:	b131      	cbz	r1, 1fffb856 <imx_mu_ipm_set_enabled+0x16>
1fffb848:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
                         | (MU_CR_RIE0_MASK>>index); // Set RIEn
1fffb84c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   MU_DisableRxFullInt(MU0_BASE, 0U);
   @endcode
 */
static inline void MU_DisableRxFullInt(MU_Type * base, uint32_t index)
{
    base->CR &= ~(MU_CR_GIRn_MASK | (MU_CR_RIE0_MASK>>index)); // Clear GIRn, clear RIEn
1fffb850:	6253      	str	r3, [r2, #36]	; 0x24
#error "CONFIG_IPM_IMX_MAX_DATA_SIZE_n is not set"
#endif
#endif

	return 0;
}
1fffb852:	2000      	movs	r0, #0
1fffb854:	4770      	bx	lr
1fffb856:	f023 7387 	bic.w	r3, r3, #17694720	; 0x10e0000
1fffb85a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
1fffb85e:	e7f7      	b.n	1fffb850 <imx_mu_ipm_set_enabled+0x10>

1fffb860 <imx_mu_init>:

static int imx_mu_init(const struct device *dev)
{
1fffb860:	b508      	push	{r3, lr}
	const struct imx_mu_config *config = dev->config;
1fffb862:	6842      	ldr	r2, [r0, #4]

	MU_Init(MU(config));
1fffb864:	6811      	ldr	r1, [r2, #0]
    base->CR &= ~(MU_CR_GIEn_MASK | MU_CR_RIEn_MASK | MU_CR_TIEn_MASK | MU_CR_GIRn_MASK | MU_CR_Fn_MASK);
1fffb866:	6a4b      	ldr	r3, [r1, #36]	; 0x24
1fffb868:	f023 0307 	bic.w	r3, r3, #7
1fffb86c:	041b      	lsls	r3, r3, #16
1fffb86e:	0c1b      	lsrs	r3, r3, #16
1fffb870:	624b      	str	r3, [r1, #36]	; 0x24
	config->irq_config_func(dev);
1fffb872:	6853      	ldr	r3, [r2, #4]
1fffb874:	4798      	blx	r3

	return 0;
}
1fffb876:	2000      	movs	r0, #0
1fffb878:	bd08      	pop	{r3, pc}

1fffb87a <imx_mu_ipm_send>:
{
1fffb87a:	b5f0      	push	{r4, r5, r6, r7, lr}
1fffb87c:	460d      	mov	r5, r1
1fffb87e:	b085      	sub	sp, #20
1fffb880:	4619      	mov	r1, r3
	MU_Type *base = MU(config);
1fffb882:	6843      	ldr	r3, [r0, #4]
{
1fffb884:	4614      	mov	r4, r2
	MU_Type *base = MU(config);
1fffb886:	681f      	ldr	r7, [r3, #0]
{
1fffb888:	9a0a      	ldr	r2, [sp, #40]	; 0x28
	if (id > CONFIG_IPM_IMX_MAX_ID_VAL) {
1fffb88a:	b9c4      	cbnz	r4, 1fffb8be <imx_mu_ipm_send+0x44>
	if (size > CONFIG_IPM_IMX_MAX_DATA_SIZE) {
1fffb88c:	2a10      	cmp	r2, #16
1fffb88e:	dc19      	bgt.n	1fffb8c4 <imx_mu_ipm_send+0x4a>
	memcpy(data32, data, size);
1fffb890:	4668      	mov	r0, sp
1fffb892:	f7ff fe74 	bl	1fffb57e <memcpy>
	for (i = 0; i < IMX_IPM_DATA_REGS; i++) {
1fffb896:	466e      	mov	r6, sp
		status = MU_TrySendMsg(base, id * IMX_IPM_DATA_REGS + i,
1fffb898:	f856 2b04 	ldr.w	r2, [r6], #4
1fffb89c:	4621      	mov	r1, r4
1fffb89e:	4638      	mov	r0, r7
1fffb8a0:	f000 f9b3 	bl	1fffbc0a <MU_TrySendMsg>
		if (status == kStatus_MU_TxNotEmpty) {
1fffb8a4:	2801      	cmp	r0, #1
1fffb8a6:	d010      	beq.n	1fffb8ca <imx_mu_ipm_send+0x50>
	for (i = 0; i < IMX_IPM_DATA_REGS; i++) {
1fffb8a8:	3401      	adds	r4, #1
1fffb8aa:	2c04      	cmp	r4, #4
1fffb8ac:	d1f4      	bne.n	1fffb898 <imx_mu_ipm_send+0x1e>
	if (wait) {
1fffb8ae:	b11d      	cbz	r5, 1fffb8b8 <imx_mu_ipm_send+0x3e>
    return (bool)(base->SR & (MU_SR_TE0_MASK >> index));
1fffb8b0:	6a3b      	ldr	r3, [r7, #32]
		while (!MU_IsTxEmpty(base,
1fffb8b2:	02db      	lsls	r3, r3, #11
1fffb8b4:	d5fc      	bpl.n	1fffb8b0 <imx_mu_ipm_send+0x36>
	return 0;
1fffb8b6:	2500      	movs	r5, #0
}
1fffb8b8:	4628      	mov	r0, r5
1fffb8ba:	b005      	add	sp, #20
1fffb8bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -EINVAL;
1fffb8be:	f06f 0515 	mvn.w	r5, #21
1fffb8c2:	e7f9      	b.n	1fffb8b8 <imx_mu_ipm_send+0x3e>
		return -EMSGSIZE;
1fffb8c4:	f06f 0579 	mvn.w	r5, #121	; 0x79
1fffb8c8:	e7f6      	b.n	1fffb8b8 <imx_mu_ipm_send+0x3e>
			return -EBUSY;
1fffb8ca:	f06f 050f 	mvn.w	r5, #15
1fffb8ce:	e7f3      	b.n	1fffb8b8 <imx_mu_ipm_send+0x3e>

1fffb8d0 <imx_mu_config_func_b>:
		    &imx_mu_b_data, &imx_mu_b_config,
		    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT,
		    &imx_mu_driver_api);

static void imx_mu_config_func_b(const struct device *dev)
{
1fffb8d0:	b508      	push	{r3, lr}
	IRQ_CONNECT(DT_INST_IRQN(0),
1fffb8d2:	2200      	movs	r2, #0
1fffb8d4:	2061      	movs	r0, #97	; 0x61
1fffb8d6:	4611      	mov	r1, r2
1fffb8d8:	f7fd fcca 	bl	1fff9270 <z_arm_irq_priority_set>
		    DT_INST_IRQ(0, priority),
		    imx_mu_isr, DEVICE_DT_INST_GET(0), 0);

	irq_enable(DT_INST_IRQN(0));
}
1fffb8dc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(DT_INST_IRQN(0));
1fffb8e0:	2061      	movs	r0, #97	; 0x61
1fffb8e2:	f7fd bcb7 	b.w	1fff9254 <arch_irq_enable>

1fffb8e6 <imx_mu_isr>:
{
1fffb8e6:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	MU_Type *base = MU(config);
1fffb8ea:	6843      	ldr	r3, [r0, #4]
	struct imx_mu_data *data = dev->data;
1fffb8ec:	f8d0 8010 	ldr.w	r8, [r0, #16]
	MU_Type *base = MU(config);
1fffb8f0:	681c      	ldr	r4, [r3, #0]
	status_reg = base->SR >>= MU_SR_RFn_SHIFT;
1fffb8f2:	6a23      	ldr	r3, [r4, #32]
1fffb8f4:	0e1b      	lsrs	r3, r3, #24
		if (status_reg & 0x1U) {
1fffb8f6:	07de      	lsls	r6, r3, #31
{
1fffb8f8:	b085      	sub	sp, #20
1fffb8fa:	4605      	mov	r5, r0
	status_reg = base->SR >>= MU_SR_RFn_SHIFT;
1fffb8fc:	6223      	str	r3, [r4, #32]
		if (status_reg & 0x1U) {
1fffb8fe:	d521      	bpl.n	1fffb944 <imx_mu_isr+0x5e>
    return (bool)(base->SR & (MU_SR_RF0_MASK >> index));
1fffb900:	6a23      	ldr	r3, [r4, #32]
				if (!MU_IsRxFull(base,
1fffb902:	0118      	lsls	r0, r3, #4
1fffb904:	d51e      	bpl.n	1fffb944 <imx_mu_isr+0x5e>
1fffb906:	6a23      	ldr	r3, [r4, #32]
1fffb908:	0159      	lsls	r1, r3, #5
1fffb90a:	d51b      	bpl.n	1fffb944 <imx_mu_isr+0x5e>
1fffb90c:	6a23      	ldr	r3, [r4, #32]
1fffb90e:	019a      	lsls	r2, r3, #6
1fffb910:	d518      	bpl.n	1fffb944 <imx_mu_isr+0x5e>
1fffb912:	6a23      	ldr	r3, [r4, #32]
1fffb914:	01db      	lsls	r3, r3, #7
1fffb916:	d515      	bpl.n	1fffb944 <imx_mu_isr+0x5e>
			if (all_registers_full) {
1fffb918:	466f      	mov	r7, sp
				for (i = 0; i < IMX_IPM_DATA_REGS; i++) {
1fffb91a:	2600      	movs	r6, #0
1fffb91c:	46b9      	mov	r9, r7
					MU_ReceiveMsg(base,
1fffb91e:	463a      	mov	r2, r7
1fffb920:	4631      	mov	r1, r6
1fffb922:	4620      	mov	r0, r4
				for (i = 0; i < IMX_IPM_DATA_REGS; i++) {
1fffb924:	3601      	adds	r6, #1
					MU_ReceiveMsg(base,
1fffb926:	f000 f97c 	bl	1fffbc22 <MU_ReceiveMsg>
				for (i = 0; i < IMX_IPM_DATA_REGS; i++) {
1fffb92a:	2e04      	cmp	r6, #4
1fffb92c:	f107 0704 	add.w	r7, r7, #4
1fffb930:	d1f5      	bne.n	1fffb91e <imx_mu_isr+0x38>
				if (data->callback) {
1fffb932:	f8d8 4000 	ldr.w	r4, [r8]
1fffb936:	b12c      	cbz	r4, 1fffb944 <imx_mu_isr+0x5e>
					data->callback(dev, data->user_data,
1fffb938:	f8d8 1004 	ldr.w	r1, [r8, #4]
1fffb93c:	464b      	mov	r3, r9
1fffb93e:	2200      	movs	r2, #0
1fffb940:	4628      	mov	r0, r5
1fffb942:	47a0      	blx	r4
  __ASM volatile ("dsb 0xF":::"memory");
1fffb944:	f3bf 8f4f 	dsb	sy
}
1fffb948:	b005      	add	sp, #20
1fffb94a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

1fffb94e <led_gpio_set_brightness>:
	size_t num_leds;
	const struct gpio_dt_spec *led;
};

static int led_gpio_set_brightness(const struct device *dev, uint32_t led, uint8_t value)
{
1fffb94e:	b410      	push	{r4}

	const struct led_gpio_config *config = dev->config;
1fffb950:	6843      	ldr	r3, [r0, #4]
	const struct gpio_dt_spec *led_gpio;

	if ((led >= config->num_leds) || (value > 100)) {
1fffb952:	6818      	ldr	r0, [r3, #0]
1fffb954:	4288      	cmp	r0, r1
1fffb956:	d917      	bls.n	1fffb988 <led_gpio_set_brightness+0x3a>
1fffb958:	2a64      	cmp	r2, #100	; 0x64
1fffb95a:	d815      	bhi.n	1fffb988 <led_gpio_set_brightness+0x3a>
		return -EINVAL;
	}

	led_gpio = &config->led[led];
1fffb95c:	685b      	ldr	r3, [r3, #4]
1fffb95e:	eb03 04c1 	add.w	r4, r3, r1, lsl #3
 * @param value Value assigned to the pin.
 * @return a value from gpio_pin_set()
 */
static inline int gpio_pin_set_dt(const struct gpio_dt_spec *spec, int value)
{
	return gpio_pin_set(spec->port, spec->pin, value);
1fffb962:	f853 0031 	ldr.w	r0, [r3, r1, lsl #3]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
1fffb966:	7923      	ldrb	r3, [r4, #4]
1fffb968:	2101      	movs	r1, #1
1fffb96a:	4099      	lsls	r1, r3
1fffb96c:	6903      	ldr	r3, [r0, #16]
1fffb96e:	681b      	ldr	r3, [r3, #0]
1fffb970:	4219      	tst	r1, r3
1fffb972:	d103      	bne.n	1fffb97c <led_gpio_set_brightness+0x2e>
	if (value != 0)	{
1fffb974:	b922      	cbnz	r2, 1fffb980 <led_gpio_set_brightness+0x32>
	return api->port_clear_bits_raw(port, pins);
1fffb976:	6883      	ldr	r3, [r0, #8]
1fffb978:	691b      	ldr	r3, [r3, #16]
1fffb97a:	e003      	b.n	1fffb984 <led_gpio_set_brightness+0x36>
	if (value != 0)	{
1fffb97c:	2a00      	cmp	r2, #0
1fffb97e:	d1fa      	bne.n	1fffb976 <led_gpio_set_brightness+0x28>
	return api->port_set_bits_raw(port, pins);
1fffb980:	6883      	ldr	r3, [r0, #8]
1fffb982:	68db      	ldr	r3, [r3, #12]

	return gpio_pin_set_dt(led_gpio, value > 0);
}
1fffb984:	bc10      	pop	{r4}
	return api->port_clear_bits_raw(port, pins);
1fffb986:	4718      	bx	r3
1fffb988:	f06f 0015 	mvn.w	r0, #21
1fffb98c:	bc10      	pop	{r4}
1fffb98e:	4770      	bx	lr

1fffb990 <led_gpio_on>:

static int led_gpio_on(const struct device *dev, uint32_t led)
{
	return led_gpio_set_brightness(dev, led, 100);
1fffb990:	2264      	movs	r2, #100	; 0x64
1fffb992:	f7ff bfdc 	b.w	1fffb94e <led_gpio_set_brightness>

1fffb996 <led_gpio_off>:
}

static int led_gpio_off(const struct device *dev, uint32_t led)
{
	return led_gpio_set_brightness(dev, led, 0);
1fffb996:	2200      	movs	r2, #0
1fffb998:	f7ff bfd9 	b.w	1fffb94e <led_gpio_set_brightness>

1fffb99c <led_gpio_init>:
}

static int led_gpio_init(const struct device *dev)
{
1fffb99c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct led_gpio_config *config = dev->config;
1fffb9a0:	6847      	ldr	r7, [r0, #4]
	int err = 0;

	if (!config->num_leds) {
1fffb9a2:	683b      	ldr	r3, [r7, #0]
1fffb9a4:	b173      	cbz	r3, 1fffb9c4 <led_gpio_init+0x28>
1fffb9a6:	2400      	movs	r4, #0
	int err = 0;
1fffb9a8:	4620      	mov	r0, r4
		data->invert |= (gpio_port_pins_t)BIT(pin);
1fffb9aa:	2601      	movs	r6, #1
		LOG_ERR("%s: no LEDs found (DT child nodes missing)", dev->name);
		err = -ENODEV;
	}

	for (size_t i = 0; (i < config->num_leds) && !err; i++) {
1fffb9ac:	683b      	ldr	r3, [r7, #0]
1fffb9ae:	429c      	cmp	r4, r3
1fffb9b0:	d20a      	bcs.n	1fffb9c8 <led_gpio_init+0x2c>
1fffb9b2:	b948      	cbnz	r0, 1fffb9c8 <led_gpio_init+0x2c>
		const struct gpio_dt_spec *led = &config->led[i];
1fffb9b4:	687d      	ldr	r5, [r7, #4]

		if (device_is_ready(led->port)) {
1fffb9b6:	f855 0034 	ldr.w	r0, [r5, r4, lsl #3]
		const struct gpio_dt_spec *led = &config->led[i];
1fffb9ba:	eb05 08c4 	add.w	r8, r5, r4, lsl #3
1fffb9be:	f000 fe9d 	bl	1fffc6fc <z_device_is_ready>
		if (device_is_ready(led->port)) {
1fffb9c2:	b918      	cbnz	r0, 1fffb9cc <led_gpio_init+0x30>
			if (err) {
				LOG_ERR("Cannot configure GPIO (err %d)", err);
			}
		} else {
			LOG_ERR("%s: GPIO device not ready", dev->name);
			err = -ENODEV;
1fffb9c4:	f06f 0012 	mvn.w	r0, #18
		}
	}

	return err;
}
1fffb9c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return gpio_pin_configure(spec->port,
1fffb9cc:	f855 0034 	ldr.w	r0, [r5, r4, lsl #3]
				  spec->pin,
1fffb9d0:	f898 1004 	ldrb.w	r1, [r8, #4]
				  spec->dt_flags | extra_flags);
1fffb9d4:	f8b8 3006 	ldrh.w	r3, [r8, #6]
	struct gpio_driver_data *data =
1fffb9d8:	f8d0 c010 	ldr.w	ip, [r0, #16]
	const struct gpio_driver_api *api =
1fffb9dc:	f8d0 8008 	ldr.w	r8, [r0, #8]
		data->invert |= (gpio_port_pins_t)BIT(pin);
1fffb9e0:	f8dc 5000 	ldr.w	r5, [ip]
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
1fffb9e4:	07da      	lsls	r2, r3, #31
	return gpio_pin_configure(spec->port,
1fffb9e6:	bf54      	ite	pl
1fffb9e8:	f443 13b0 	orrpl.w	r3, r3, #1441792	; 0x160000
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
1fffb9ec:	f483 13d0 	eormi.w	r3, r3, #1703936	; 0x1a0000
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
1fffb9f0:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
		data->invert |= (gpio_port_pins_t)BIT(pin);
1fffb9f4:	fa06 fe01 	lsl.w	lr, r6, r1
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
1fffb9f8:	07db      	lsls	r3, r3, #31
		data->invert |= (gpio_port_pins_t)BIT(pin);
1fffb9fa:	bf4c      	ite	mi
1fffb9fc:	ea45 050e 	orrmi.w	r5, r5, lr
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
1fffba00:	ea25 050e 	bicpl.w	r5, r5, lr
1fffba04:	f8cc 5000 	str.w	r5, [ip]
	return api->pin_configure(port, pin, flags);
1fffba08:	f8d8 3000 	ldr.w	r3, [r8]
1fffba0c:	4798      	blx	r3
	for (size_t i = 0; (i < config->num_leds) && !err; i++) {
1fffba0e:	3401      	adds	r4, #1
1fffba10:	e7cc      	b.n	1fffb9ac <led_gpio_init+0x10>

1fffba12 <pinctrl_lookup_state>:

#include <zephyr/drivers/pinctrl.h>

int pinctrl_lookup_state(const struct pinctrl_dev_config *config, uint8_t id,
			 const struct pinctrl_state **state)
{
1fffba12:	b530      	push	{r4, r5, lr}
	*state = &config->states[0];
1fffba14:	6803      	ldr	r3, [r0, #0]
1fffba16:	6013      	str	r3, [r2, #0]
	while (*state < &config->states[config->state_cnt]) {
1fffba18:	7905      	ldrb	r5, [r0, #4]
1fffba1a:	6804      	ldr	r4, [r0, #0]
1fffba1c:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
1fffba20:	42a3      	cmp	r3, r4
1fffba22:	d302      	bcc.n	1fffba2a <pinctrl_lookup_state+0x18>
		}

		(*state)++;
	}

	return -ENOENT;
1fffba24:	f06f 0001 	mvn.w	r0, #1
}
1fffba28:	bd30      	pop	{r4, r5, pc}
		if (id == (*state)->id) {
1fffba2a:	795c      	ldrb	r4, [r3, #5]
1fffba2c:	428c      	cmp	r4, r1
1fffba2e:	d001      	beq.n	1fffba34 <pinctrl_lookup_state+0x22>
		(*state)++;
1fffba30:	3308      	adds	r3, #8
1fffba32:	e7f0      	b.n	1fffba16 <pinctrl_lookup_state+0x4>
			return 0;
1fffba34:	2000      	movs	r0, #0
1fffba36:	e7f7      	b.n	1fffba28 <pinctrl_lookup_state+0x16>

1fffba38 <imx_pinctrl_init>:
#elif defined(CONFIG_SOC_MIMX8MQ6)
	CLOCK_EnableClock(kCLOCK_Iomux);
#endif /* CONFIG_SOC_SERIES_IMX_RT */

	return 0;
}
1fffba38:	2000      	movs	r0, #0
1fffba3a:	4770      	bx	lr

1fffba3c <pinctrl_configure_pins>:
{
1fffba3c:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (uint8_t i = 0U; i < pin_cnt; i++) {
1fffba3e:	2400      	movs	r4, #0
1fffba40:	b2e3      	uxtb	r3, r4
1fffba42:	4299      	cmp	r1, r3
1fffba44:	d801      	bhi.n	1fffba4a <pinctrl_configure_pins+0xe>
}
1fffba46:	2000      	movs	r0, #0
1fffba48:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uint32_t input_daisy = pins[i].pinmux.input_daisy;
1fffba4a:	7b03      	ldrb	r3, [r0, #12]
		uint32_t pin_ctrl_flags = pins[i].pin_ctrl_flags;
1fffba4c:	6902      	ldr	r2, [r0, #16]
		uint32_t input_register = pins[i].pinmux.input_register;
1fffba4e:	6885      	ldr	r5, [r0, #8]
		*((volatile uint32_t *)((uintptr_t)mux_register)) =
1fffba50:	f8d0 c000 	ldr.w	ip, [r0]
		uint32_t config_register = pins[i].pinmux.config_register;
1fffba54:	6847      	ldr	r7, [r0, #4]
		uint32_t input_daisy = pins[i].pinmux.input_daisy;
1fffba56:	091e      	lsrs	r6, r3, #4
			IOMUXC_SW_MUX_CTL_PAD_SION(MCUX_IMX_INPUT_ENABLE(pin_ctrl_flags));
1fffba58:	ea4f 7ed2 	mov.w	lr, r2, lsr #31
		uint32_t mux_mode = pins[i].pinmux.mux_mode;
1fffba5c:	f003 030f 	and.w	r3, r3, #15
			IOMUXC_SW_MUX_CTL_PAD_MUX_MODE(mux_mode) |
1fffba60:	ea43 130e 	orr.w	r3, r3, lr, lsl #4
		*((volatile uint32_t *)((uintptr_t)mux_register)) =
1fffba64:	f8cc 3000 	str.w	r3, [ip]
		if (input_register) {
1fffba68:	b115      	cbz	r5, 1fffba70 <pinctrl_configure_pins+0x34>
				IOMUXC_SELECT_INPUT_DAISY(input_daisy);
1fffba6a:	f006 0607 	and.w	r6, r6, #7
			*((volatile uint32_t *)((uintptr_t)input_register)) =
1fffba6e:	602e      	str	r6, [r5, #0]
		if (config_register) {
1fffba70:	b117      	cbz	r7, 1fffba78 <pinctrl_configure_pins+0x3c>
				pin_ctrl_flags & (~(0x1 << MCUX_IMX_INPUT_ENABLE_SHIFT));
1fffba72:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
			*((volatile uint32_t *)((uintptr_t)config_register)) =
1fffba76:	603a      	str	r2, [r7, #0]
	for (uint8_t i = 0U; i < pin_cnt; i++) {
1fffba78:	3401      	adds	r4, #1
1fffba7a:	3014      	adds	r0, #20
1fffba7c:	e7e0      	b.n	1fffba40 <pinctrl_configure_pins+0x4>

1fffba7e <uart_imx_poll_out>:
	UART_Type *uart = UART_STRUCT(dev);
1fffba7e:	6843      	ldr	r3, [r0, #4]
1fffba80:	681b      	ldr	r3, [r3, #0]
1fffba82:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
	while (!UART_GetStatusFlag(uart, uartStatusTxReady)) {
1fffba86:	0492      	lsls	r2, r2, #18
1fffba88:	d5fb      	bpl.n	1fffba82 <uart_imx_poll_out+0x4>
    UART_UTXD_REG(base) = (data & UART_UTXD_TX_DATA_MASK);
1fffba8a:	6419      	str	r1, [r3, #64]	; 0x40
}
1fffba8c:	4770      	bx	lr

1fffba8e <uart_imx_fifo_fill>:
{
1fffba8e:	b510      	push	{r4, lr}
	UART_Type *uart = UART_STRUCT(dev);
1fffba90:	6843      	ldr	r3, [r0, #4]
1fffba92:	681b      	ldr	r3, [r3, #0]
	unsigned int num_tx = 0U;
1fffba94:	2000      	movs	r0, #0
	while (((size - num_tx) > 0) &&
1fffba96:	4290      	cmp	r0, r2
1fffba98:	d003      	beq.n	1fffbaa2 <uart_imx_fifo_fill+0x14>
    return (bool)((*uart_reg >> (flag & 0x0000FFFF)) & 0x1);
1fffba9a:	f8d3 4094 	ldr.w	r4, [r3, #148]	; 0x94
1fffba9e:	04a4      	lsls	r4, r4, #18
1fffbaa0:	d400      	bmi.n	1fffbaa4 <uart_imx_fifo_fill+0x16>
}
1fffbaa2:	bd10      	pop	{r4, pc}
    UART_UTXD_REG(base) = (data & UART_UTXD_TX_DATA_MASK);
1fffbaa4:	5c0c      	ldrb	r4, [r1, r0]
1fffbaa6:	641c      	str	r4, [r3, #64]	; 0x40
		num_tx++;
1fffbaa8:	3001      	adds	r0, #1
1fffbaaa:	e7f4      	b.n	1fffba96 <uart_imx_fifo_fill+0x8>

1fffbaac <uart_imx_irq_tx_ready>:
	UART_Type *uart = UART_STRUCT(dev);
1fffbaac:	6843      	ldr	r3, [r0, #4]
    uart_reg = (uint32_t *)((uint32_t)base + (flag >> 16));
1fffbaae:	681b      	ldr	r3, [r3, #0]
    return (bool)((*uart_reg >> (flag & 0x0000FFFF)) & 0x1);
1fffbab0:	f8d3 0094 	ldr.w	r0, [r3, #148]	; 0x94
}
1fffbab4:	f3c0 3040 	ubfx	r0, r0, #13, #1
1fffbab8:	4770      	bx	lr

1fffbaba <uart_imx_irq_rx_ready>:
	UART_Type *uart = UART_STRUCT(dev);
1fffbaba:	6843      	ldr	r3, [r0, #4]
    uart_reg = (uint32_t *)((uint32_t)base + (flag >> 16));
1fffbabc:	681b      	ldr	r3, [r3, #0]
    return (bool)((*uart_reg >> (flag & 0x0000FFFF)) & 0x1);
1fffbabe:	f8d3 0094 	ldr.w	r0, [r3, #148]	; 0x94
}
1fffbac2:	f3c0 2040 	ubfx	r0, r0, #9, #1
1fffbac6:	4770      	bx	lr

1fffbac8 <uart_imx_irq_is_pending>:

static int uart_imx_irq_is_pending(const struct device *dev)
{
	UART_Type *uart = UART_STRUCT(dev);
1fffbac8:	6843      	ldr	r3, [r0, #4]
    uart_reg = (uint32_t *)((uint32_t)base + (flag >> 16));
1fffbaca:	681b      	ldr	r3, [r3, #0]
    return (bool)((*uart_reg >> (flag & 0x0000FFFF)) & 0x1);
1fffbacc:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94

	return UART_GetStatusFlag(uart, uartStatusRxReady) ||
1fffbad0:	0592      	lsls	r2, r2, #22
1fffbad2:	bf5a      	itte	pl
1fffbad4:	f8d3 0094 	ldrpl.w	r0, [r3, #148]	; 0x94
1fffbad8:	f3c0 3040 	ubfxpl	r0, r0, #13, #1
1fffbadc:	2001      	movmi	r0, #1
		UART_GetStatusFlag(uart, uartStatusTxReady);
}
1fffbade:	4770      	bx	lr

1fffbae0 <uart_imx_irq_update>:

static int uart_imx_irq_update(const struct device *dev)
{
	return 1;
}
1fffbae0:	2001      	movs	r0, #1
1fffbae2:	4770      	bx	lr

1fffbae4 <uart_imx_irq_callback_set>:

static void uart_imx_irq_callback_set(const struct device *dev,
				      uart_irq_callback_user_data_t cb,
				      void *cb_data)
{
	struct imx_uart_data *data = dev->data;
1fffbae4:	6903      	ldr	r3, [r0, #16]

	data->callback = cb;
	data->cb_data = cb_data;
1fffbae6:	e9c3 1200 	strd	r1, r2, [r3]
}
1fffbaea:	4770      	bx	lr

1fffbaec <uart_imx_isr>:
 *
 * @param arg Argument to ISR.
 */
void uart_imx_isr(const struct device *dev)
{
	struct imx_uart_data *data = dev->data;
1fffbaec:	6902      	ldr	r2, [r0, #16]

	if (data->callback) {
1fffbaee:	6813      	ldr	r3, [r2, #0]
1fffbaf0:	b10b      	cbz	r3, 1fffbaf6 <uart_imx_isr+0xa>
		data->callback(dev, data->cb_data);
1fffbaf2:	6851      	ldr	r1, [r2, #4]
1fffbaf4:	4718      	bx	r3
	}
}
1fffbaf6:	4770      	bx	lr

1fffbaf8 <irq_config_func_0>:
									\
	UART_IMX_CONFIG_FUNC(n)						\
									\
	UART_IMX_INIT_CFG(n);

DT_INST_FOREACH_STATUS_OKAY(UART_IMX_INIT)
1fffbaf8:	b508      	push	{r3, lr}
1fffbafa:	2010      	movs	r0, #16
1fffbafc:	2200      	movs	r2, #0
1fffbafe:	2103      	movs	r1, #3
1fffbb00:	f7fd fbb6 	bl	1fff9270 <z_arm_irq_priority_set>
1fffbb04:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
1fffbb08:	2010      	movs	r0, #16
1fffbb0a:	f7fd bba3 	b.w	1fff9254 <arch_irq_enable>

1fffbb0e <uart_imx_init>:
{
1fffbb0e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	UART_Type *uart = UART_STRUCT(dev);
1fffbb12:	6846      	ldr	r6, [r0, #4]
{
1fffbb14:	b088      	sub	sp, #32
	UART_Type *uart = UART_STRUCT(dev);
1fffbb16:	6834      	ldr	r4, [r6, #0]
{
1fffbb18:	4607      	mov	r7, r0
	__asm__ volatile(
1fffbb1a:	f04f 0310 	mov.w	r3, #16
1fffbb1e:	f3ef 8811 	mrs	r8, BASEPRI
1fffbb22:	f383 8812 	msr	BASEPRI_MAX, r3
1fffbb26:	f3bf 8f6f 	isb	sy
	uart_init_config_t initConfig = {
1fffbb2a:	2218      	movs	r2, #24
1fffbb2c:	2100      	movs	r1, #0
1fffbb2e:	a802      	add	r0, sp, #8
1fffbb30:	f7ff fd30 	bl	1fffb594 <memset>
		.baudRate	= config->baud_rate,
1fffbb34:	6873      	ldr	r3, [r6, #4]
	uart_init_config_t initConfig = {
1fffbb36:	9303      	str	r3, [sp, #12]
1fffbb38:	2320      	movs	r3, #32
1fffbb3a:	9304      	str	r3, [sp, #16]
1fffbb3c:	2306      	movs	r3, #6
1fffbb3e:	9307      	str	r3, [sp, #28]
				      uint8_t id)
{
	int ret;
	const struct pinctrl_state *state;

	ret = pinctrl_lookup_state(config, id, &state);
1fffbb40:	68f0      	ldr	r0, [r6, #12]
1fffbb42:	aa01      	add	r2, sp, #4
1fffbb44:	2100      	movs	r1, #0
1fffbb46:	f7ff ff64 	bl	1fffba12 <pinctrl_lookup_state>
	if (ret < 0) {
1fffbb4a:	1e05      	subs	r5, r0, #0
1fffbb4c:	db30      	blt.n	1fffbbb0 <uart_imx_init+0xa2>
		return ret;
	}

	return pinctrl_apply_state_direct(config, state);
1fffbb4e:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
1fffbb50:	2200      	movs	r2, #0
1fffbb52:	7919      	ldrb	r1, [r3, #4]
1fffbb54:	6818      	ldr	r0, [r3, #0]
1fffbb56:	f7ff ff71 	bl	1fffba3c <pinctrl_configure_pins>
	if (err) {
1fffbb5a:	4605      	mov	r5, r0
1fffbb5c:	bb40      	cbnz	r0, 1fffbbb0 <uart_imx_init+0xa2>
	initConfig.clockRate  = get_uart_clock_freq(uart);
1fffbb5e:	4620      	mov	r0, r4
1fffbb60:	f7fe f83a 	bl	1fff9bd8 <get_uart_clock_freq>
	UART_Init(uart, &initConfig);
1fffbb64:	a902      	add	r1, sp, #8
	initConfig.clockRate  = get_uart_clock_freq(uart);
1fffbb66:	9002      	str	r0, [sp, #8]
	UART_Init(uart, &initConfig);
1fffbb68:	4620      	mov	r0, r4
1fffbb6a:	f000 f895 	bl	1fffbc98 <UART_Init>
 * @param watermark The Tx FIFO watermark.
 */
static inline void UART_SetTxFifoWatermark(UART_Type* base, uint8_t watermark)
{
    assert((watermark >= 2) && (watermark <= 32));
    UART_UFCR_REG(base) = (UART_UFCR_REG(base) & ~UART_UFCR_TXTL_MASK) | UART_UFCR_TXTL(watermark);
1fffbb6e:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
1fffbb72:	f423 437c 	bic.w	r3, r3, #64512	; 0xfc00
1fffbb76:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
1fffbb7a:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
 * @param watermark The Rx FIFO watermark.
 */
static inline void UART_SetRxFifoWatermark(UART_Type* base, uint8_t watermark)
{
    assert(watermark <= 32);
    UART_UFCR_REG(base) = (UART_UFCR_REG(base) & ~UART_UFCR_RXTL_MASK) | UART_UFCR_RXTL(watermark);
1fffbb7e:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
1fffbb82:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
1fffbb86:	f043 0301 	orr.w	r3, r3, #1
1fffbb8a:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
	__asm__ volatile(
1fffbb8e:	f388 8811 	msr	BASEPRI, r8
1fffbb92:	f3bf 8f6f 	isb	sy
	config->irq_config_func(dev);
1fffbb96:	6933      	ldr	r3, [r6, #16]
1fffbb98:	4638      	mov	r0, r7
1fffbb9a:	4798      	blx	r3
	UART_SetModemMode(uart, config->modem_mode);
1fffbb9c:	7a31      	ldrb	r1, [r6, #8]
1fffbb9e:	4620      	mov	r0, r4
1fffbba0:	f000 f8b2 	bl	1fffbd08 <UART_SetModemMode>
    UART_UCR1_REG(base) |= UART_UCR1_UARTEN_MASK;
1fffbba4:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
1fffbba8:	f043 0301 	orr.w	r3, r3, #1
1fffbbac:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
}
1fffbbb0:	4628      	mov	r0, r5
1fffbbb2:	b008      	add	sp, #32
1fffbbb4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

1fffbbb8 <CCM_GetRootDivider>:
    *pre = (CCM_REG(ccmRoot) & CCM_TARGET_ROOT_PRE_PODF_MASK) >> CCM_TARGET_ROOT_PRE_PODF_SHIFT;
1fffbbb8:	6808      	ldr	r0, [r1, #0]
1fffbbba:	f3c0 4002 	ubfx	r0, r0, #16, #3
1fffbbbe:	6010      	str	r0, [r2, #0]
    *post = (CCM_REG(ccmRoot) & CCM_TARGET_ROOT_POST_PODF_MASK) >> CCM_TARGET_ROOT_POST_PODF_SHIFT;
1fffbbc0:	680a      	ldr	r2, [r1, #0]
1fffbbc2:	f002 023f 	and.w	r2, r2, #63	; 0x3f
1fffbbc6:	601a      	str	r2, [r3, #0]
}
1fffbbc8:	4770      	bx	lr

1fffbbca <GPIO_WritePinOutput>:
void GPIO_WritePinOutput(GPIO_Type* base, uint32_t pin, gpio_pin_action_t pinVal)
{
    assert(pin < 32);
    if (pinVal == gpioPinSet)
    {
        GPIO_DR_REG(base) |= (1U << pin);  /* Set pin output to high level.*/
1fffbbca:	2301      	movs	r3, #1
1fffbbcc:	fa03 f101 	lsl.w	r1, r3, r1
    if (pinVal == gpioPinSet)
1fffbbd0:	429a      	cmp	r2, r3
        GPIO_DR_REG(base) |= (1U << pin);  /* Set pin output to high level.*/
1fffbbd2:	6803      	ldr	r3, [r0, #0]
1fffbbd4:	bf0c      	ite	eq
1fffbbd6:	430b      	orreq	r3, r1
    }
    else
    {
        GPIO_DR_REG(base) &= ~(1U << pin);  /* Set pin output to low level.*/
1fffbbd8:	438b      	bicne	r3, r1
1fffbbda:	6003      	str	r3, [r0, #0]
    }
}
1fffbbdc:	4770      	bx	lr

1fffbbde <GPIO_SetPinIntMode>:
void GPIO_SetPinIntMode(GPIO_Type* base, uint32_t pin, bool enable)
{
    assert(pin < 32);

    if(enable)
        GPIO_IMR_REG(base) |= (1U << pin);
1fffbbde:	2301      	movs	r3, #1
1fffbbe0:	fa03 f101 	lsl.w	r1, r3, r1
1fffbbe4:	6943      	ldr	r3, [r0, #20]
    if(enable)
1fffbbe6:	b112      	cbz	r2, 1fffbbee <GPIO_SetPinIntMode+0x10>
        GPIO_IMR_REG(base) |= (1U << pin);
1fffbbe8:	430b      	orrs	r3, r1
    else
        GPIO_IMR_REG(base) &= ~(1U << pin);
1fffbbea:	6143      	str	r3, [r0, #20]
}
1fffbbec:	4770      	bx	lr
        GPIO_IMR_REG(base) &= ~(1U << pin);
1fffbbee:	ea23 0301 	bic.w	r3, r3, r1
1fffbbf2:	e7fa      	b.n	1fffbbea <GPIO_SetPinIntMode+0xc>

1fffbbf4 <GPIO_SetIntEdgeSelect>:
void GPIO_SetIntEdgeSelect(GPIO_Type* base, uint32_t pin, bool enable)
{
    assert(pin < 32);

    if(enable)
        GPIO_EDGE_SEL_REG(base) |= (1U << pin);
1fffbbf4:	2301      	movs	r3, #1
1fffbbf6:	fa03 f101 	lsl.w	r1, r3, r1
1fffbbfa:	69c3      	ldr	r3, [r0, #28]
    if(enable)
1fffbbfc:	b112      	cbz	r2, 1fffbc04 <GPIO_SetIntEdgeSelect+0x10>
        GPIO_EDGE_SEL_REG(base) |= (1U << pin);
1fffbbfe:	430b      	orrs	r3, r1
    else
        GPIO_EDGE_SEL_REG(base) &= ~(1U << pin);
1fffbc00:	61c3      	str	r3, [r0, #28]
}
1fffbc02:	4770      	bx	lr
        GPIO_EDGE_SEL_REG(base) &= ~(1U << pin);
1fffbc04:	ea23 0301 	bic.w	r3, r3, r1
1fffbc08:	e7fa      	b.n	1fffbc00 <GPIO_SetIntEdgeSelect+0xc>

1fffbc0a <MU_TrySendMsg>:
 * Function Name : MU_TrySendMsg
 * Description   : Try to send message to the other core.
 *
 *END**************************************************************************/
mu_status_t MU_TrySendMsg(MU_Type * base, uint32_t regIndex, uint32_t msg)
{
1fffbc0a:	b510      	push	{r4, lr}
 * @retval true TX register is empty.
 * @retval false TX register is not empty.
 */
static inline bool MU_IsTxEmpty(MU_Type * base, uint32_t index)
{
    return (bool)(base->SR & (MU_SR_TE0_MASK >> index));
1fffbc0c:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
1fffbc10:	6a04      	ldr	r4, [r0, #32]
1fffbc12:	40cb      	lsrs	r3, r1
    assert(regIndex < MU_TR_COUNT);

    // TX register is empty.
    if(MU_IsTxEmpty(base, regIndex))
1fffbc14:	4223      	tst	r3, r4
    {
        base->TR[regIndex] = msg;
1fffbc16:	bf16      	itet	ne
1fffbc18:	f840 2021 	strne.w	r2, [r0, r1, lsl #2]
        return kStatus_MU_Success;
    }

    return kStatus_MU_TxNotEmpty;
1fffbc1c:	2001      	moveq	r0, #1
        return kStatus_MU_Success;
1fffbc1e:	2000      	movne	r0, #0
}
1fffbc20:	bd10      	pop	{r4, pc}

1fffbc22 <MU_ReceiveMsg>:
 * Function Name : MU_ReceiveMsg
 * Description   : Wait to receive message from the other core.
 *
 *END**************************************************************************/
void MU_ReceiveMsg(MU_Type * base, uint32_t regIndex, uint32_t *msg)
{
1fffbc22:	b510      	push	{r4, lr}
    assert(regIndex < MU_TR_COUNT);
    uint32_t mask = MU_SR_RF0_MASK >> regIndex;
1fffbc24:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
1fffbc28:	40cb      	lsrs	r3, r1

    // Wait RX register to be full.
    while (!(base->SR & mask)) { }
1fffbc2a:	6a04      	ldr	r4, [r0, #32]
1fffbc2c:	421c      	tst	r4, r3
1fffbc2e:	d0fc      	beq.n	1fffbc2a <MU_ReceiveMsg+0x8>
    *msg = base->RR[regIndex];
1fffbc30:	3104      	adds	r1, #4
1fffbc32:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
1fffbc36:	6013      	str	r3, [r2, #0]
}
1fffbc38:	bd10      	pop	{r4, pc}

1fffbc3a <UART_Deinit>:
    UART_UCR1_REG(base) &= ~UART_UCR1_UARTEN_MASK;
1fffbc3a:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
1fffbc3e:	f023 0301 	bic.w	r3, r3, #1
1fffbc42:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
    UART_UCR2_REG(base)  = UART_UCR2_SRST_MASK;
1fffbc46:	2201      	movs	r2, #1
    UART_UCR1_REG(base)  = 0x0;
1fffbc48:	2300      	movs	r3, #0
1fffbc4a:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
    UART_UCR2_REG(base)  = UART_UCR2_SRST_MASK;
1fffbc4e:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
    UART_UCR3_REG(base)  = UART_UCR3_DSR_MASK |
1fffbc52:	f44f 62e0 	mov.w	r2, #1792	; 0x700
1fffbc56:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
    UART_UCR4_REG(base)  = UART_UCR4_CTSTL(32);
1fffbc5a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
1fffbc5e:	f8c0 208c 	str.w	r2, [r0, #140]	; 0x8c
    UART_UFCR_REG(base)  = UART_UFCR_TXTL(2) | UART_UFCR_RXTL(1);
1fffbc62:	f640 0201 	movw	r2, #2049	; 0x801
1fffbc66:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
    UART_UESC_REG(base)  = UART_UESC_ESC_CHAR(0x2B);
1fffbc6a:	222b      	movs	r2, #43	; 0x2b
1fffbc6c:	f8c0 209c 	str.w	r2, [r0, #156]	; 0x9c
    UART_UTS_REG(base)   = UART_UTS_TXEMPTY_MASK | UART_UTS_RXEMPTY_MASK;
1fffbc70:	2260      	movs	r2, #96	; 0x60
    UART_UTIM_REG(base)  = 0x0;
1fffbc72:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
    UART_ONEMS_REG(base) = 0x0;
1fffbc76:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
    UART_UTS_REG(base)   = UART_UTS_TXEMPTY_MASK | UART_UTS_RXEMPTY_MASK;
1fffbc7a:	f8c0 20b4 	str.w	r2, [r0, #180]	; 0xb4
    UART_UMCR_REG(base)  = 0x0;
1fffbc7e:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
    UART_UCR2_REG(base) &= ~UART_UCR2_SRST_MASK;
1fffbc82:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
1fffbc86:	f023 0301 	bic.w	r3, r3, #1
1fffbc8a:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    while (!(UART_UCR2_REG(base) & UART_UCR2_SRST_MASK));
1fffbc8e:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
1fffbc92:	07db      	lsls	r3, r3, #31
1fffbc94:	d5fb      	bpl.n	1fffbc8e <UART_Deinit+0x54>
}
1fffbc96:	4770      	bx	lr

1fffbc98 <UART_Init>:
{
1fffbc98:	b538      	push	{r3, r4, r5, lr}
    UART_UCR1_REG(base) &= ~UART_UCR1_UARTEN_MASK;
1fffbc9a:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
1fffbc9e:	f023 0301 	bic.w	r3, r3, #1
1fffbca2:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
    UART_Deinit(base);
1fffbca6:	f7ff ffc8 	bl	1fffbc3a <UART_Deinit>
    UART_UCR2_REG(base) |= (initConfig->wordLength |
1fffbcaa:	e9d1 3502 	ldrd	r3, r5, [r1, #8]
1fffbcae:	f8d0 2084 	ldr.w	r2, [r0, #132]	; 0x84
1fffbcb2:	432b      	orrs	r3, r5
1fffbcb4:	4313      	orrs	r3, r2
1fffbcb6:	690a      	ldr	r2, [r1, #16]
1fffbcb8:	4313      	orrs	r3, r2
1fffbcba:	694a      	ldr	r2, [r1, #20]
1fffbcbc:	4313      	orrs	r3, r2
1fffbcbe:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
1fffbcc2:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    UART_UCR3_REG(base) |= UART_UCR3_RXDMUXSEL_MASK;
1fffbcc6:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
1fffbcca:	f043 0304 	orr.w	r3, r3, #4
1fffbcce:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
    UART_SetBaudRate(base, initConfig->clockRate, initConfig->baudRate);
1fffbcd2:	e9d1 1200 	ldrd	r1, r2, [r1]
}
1fffbcd6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    UART_SetBaudRate(base, initConfig->clockRate, initConfig->baudRate);
1fffbcda:	f7fd bf0f 	b.w	1fff9afc <UART_SetBaudRate>

1fffbcde <UART_SetIntCmd>:
 *                 specific UART interrupt source. The available interrupt
 *                 source can be select from uart_int_source enumeration.
 *
 *END**************************************************************************/
void UART_SetIntCmd(UART_Type* base, uint32_t intSource, bool enable)
{
1fffbcde:	b510      	push	{r4, lr}
    volatile uint32_t* uart_reg = 0;
    uint32_t uart_mask = 0;

    uart_reg = (uint32_t *)((uint32_t)base + (intSource >> 16));
1fffbce0:	0c0b      	lsrs	r3, r1, #16
    uart_mask = (1 << (intSource & 0x0000FFFF));
1fffbce2:	2401      	movs	r4, #1
1fffbce4:	b289      	uxth	r1, r1
1fffbce6:	fa04 f101 	lsl.w	r1, r4, r1

    if (enable)
1fffbcea:	b11a      	cbz	r2, 1fffbcf4 <UART_SetIntCmd+0x16>
        *uart_reg |= uart_mask;
1fffbcec:	58c2      	ldr	r2, [r0, r3]
1fffbcee:	430a      	orrs	r2, r1
    else
        *uart_reg &= ~uart_mask;
1fffbcf0:	50c2      	str	r2, [r0, r3]
}
1fffbcf2:	bd10      	pop	{r4, pc}
        *uart_reg &= ~uart_mask;
1fffbcf4:	58c2      	ldr	r2, [r0, r3]
1fffbcf6:	ea22 0201 	bic.w	r2, r2, r1
1fffbcfa:	e7f9      	b.n	1fffbcf0 <UART_SetIntCmd+0x12>

1fffbcfc <UART_ClearStatusFlag>:
void UART_ClearStatusFlag(UART_Type* base, uint32_t flag)
{
    volatile uint32_t* uart_reg = 0;
    uint32_t uart_mask = 0;

    uart_reg = (uint32_t *)((uint32_t)base + (flag >> 16));
1fffbcfc:	0c0a      	lsrs	r2, r1, #16
    uart_mask = (1 << (flag & 0x0000FFFF));
1fffbcfe:	2301      	movs	r3, #1
1fffbd00:	b289      	uxth	r1, r1
1fffbd02:	408b      	lsls	r3, r1

    /* write 1 to clear. */
    *uart_reg = uart_mask;
1fffbd04:	5083      	str	r3, [r0, r2]
}
1fffbd06:	4770      	bx	lr

1fffbd08 <UART_SetModemMode>:
void UART_SetModemMode(UART_Type* base, uint32_t mode)
{
    assert((mode == uartModemModeDce) || (mode == uartModemModeDte));

    if (uartModemModeDce == mode)
        UART_UFCR_REG(base) &= ~UART_UFCR_DCEDTE_MASK;
1fffbd08:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
    if (uartModemModeDce == mode)
1fffbd0c:	b921      	cbnz	r1, 1fffbd18 <UART_SetModemMode+0x10>
        UART_UFCR_REG(base) &= ~UART_UFCR_DCEDTE_MASK;
1fffbd0e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    else
        UART_UFCR_REG(base) |= UART_UFCR_DCEDTE_MASK;
1fffbd12:	f8c0 3090 	str.w	r3, [r0, #144]	; 0x90
}
1fffbd16:	4770      	bx	lr
        UART_UFCR_REG(base) |= UART_UFCR_DCEDTE_MASK;
1fffbd18:	f043 0340 	orr.w	r3, r3, #64	; 0x40
1fffbd1c:	e7f9      	b.n	1fffbd12 <UART_SetModemMode+0xa>

1fffbd1e <metal_device_open>:
{
1fffbd1e:	b573      	push	{r0, r1, r4, r5, r6, lr}
1fffbd20:	460c      	mov	r4, r1
1fffbd22:	4615      	mov	r5, r2
	if (!bus_name || !strlen(bus_name) ||
1fffbd24:	4606      	mov	r6, r0
1fffbd26:	b918      	cbnz	r0, 1fffbd30 <metal_device_open+0x12>
		return -EINVAL;
1fffbd28:	f06f 0015 	mvn.w	r0, #21
}
1fffbd2c:	b002      	add	sp, #8
1fffbd2e:	bd70      	pop	{r4, r5, r6, pc}
	if (!bus_name || !strlen(bus_name) ||
1fffbd30:	f7ff fbf5 	bl	1fffb51e <strlen>
1fffbd34:	2800      	cmp	r0, #0
1fffbd36:	d0f7      	beq.n	1fffbd28 <metal_device_open+0xa>
1fffbd38:	2c00      	cmp	r4, #0
1fffbd3a:	d0f5      	beq.n	1fffbd28 <metal_device_open+0xa>
	    !dev_name || !strlen(dev_name) ||
1fffbd3c:	4620      	mov	r0, r4
1fffbd3e:	f7ff fbee 	bl	1fffb51e <strlen>
1fffbd42:	2800      	cmp	r0, #0
1fffbd44:	d0f0      	beq.n	1fffbd28 <metal_device_open+0xa>
1fffbd46:	2d00      	cmp	r5, #0
1fffbd48:	d0ee      	beq.n	1fffbd28 <metal_device_open+0xa>
	error = metal_bus_find(bus_name, &bus);
1fffbd4a:	a901      	add	r1, sp, #4
1fffbd4c:	4630      	mov	r0, r6
1fffbd4e:	f7fe f813 	bl	1fff9d78 <metal_bus_find>
	if (error)
1fffbd52:	2800      	cmp	r0, #0
1fffbd54:	d1ea      	bne.n	1fffbd2c <metal_device_open+0xe>
	if (!bus->ops.dev_open)
1fffbd56:	9801      	ldr	r0, [sp, #4]
1fffbd58:	6883      	ldr	r3, [r0, #8]
1fffbd5a:	b12b      	cbz	r3, 1fffbd68 <metal_device_open+0x4a>
	error = (*bus->ops.dev_open)(bus, dev_name, device);
1fffbd5c:	462a      	mov	r2, r5
1fffbd5e:	4621      	mov	r1, r4
}
1fffbd60:	b002      	add	sp, #8
1fffbd62:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	error = (*bus->ops.dev_open)(bus, dev_name, device);
1fffbd66:	4718      	bx	r3
		return -ENODEV;
1fffbd68:	f06f 0012 	mvn.w	r0, #18
1fffbd6c:	e7de      	b.n	1fffbd2c <metal_device_open+0xe>

1fffbd6e <metal_io_init>:

void metal_io_init(struct metal_io_region *io, void *virt,
	      const metal_phys_addr_t *physmap, size_t size,
	      unsigned int page_shift, unsigned int mem_flags,
	      const struct metal_io_ops *ops)
{
1fffbd6e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
1fffbd72:	b089      	sub	sp, #36	; 0x24
1fffbd74:	4604      	mov	r4, r0
1fffbd76:	9e10      	ldr	r6, [sp, #64]	; 0x40
1fffbd78:	9d12      	ldr	r5, [sp, #72]	; 0x48
1fffbd7a:	4689      	mov	r9, r1
1fffbd7c:	4690      	mov	r8, r2
	const struct metal_io_ops nops = {
1fffbd7e:	2100      	movs	r1, #0
1fffbd80:	2220      	movs	r2, #32
1fffbd82:	4668      	mov	r0, sp
{
1fffbd84:	461f      	mov	r7, r3
	const struct metal_io_ops nops = {
1fffbd86:	f7ff fc05 	bl	1fffb594 <memset>

	io->virt = virt;
	io->physmap = physmap;
	io->size = size;
	io->page_shift = page_shift;
	if (page_shift >= sizeof(io->page_mask) * CHAR_BIT)
1fffbd8a:	2e1f      	cmp	r6, #31
		/* avoid overflow */
		io->page_mask = -1UL;
	else
		io->page_mask = (1UL << page_shift) - 1UL;
1fffbd8c:	bf9d      	ittte	ls
1fffbd8e:	2301      	movls	r3, #1
1fffbd90:	40b3      	lslls	r3, r6
1fffbd92:	f103 33ff 	addls.w	r3, r3, #4294967295	; 0xffffffff
		io->page_mask = -1UL;
1fffbd96:	f04f 33ff 	movhi.w	r3, #4294967295	; 0xffffffff
1fffbd9a:	6123      	str	r3, [r4, #16]
	io->mem_flags = mem_flags;
1fffbd9c:	9b11      	ldr	r3, [sp, #68]	; 0x44
1fffbd9e:	6163      	str	r3, [r4, #20]
	io->physmap = physmap;
1fffbda0:	e9c4 9800 	strd	r9, r8, [r4]
	io->page_shift = page_shift;
1fffbda4:	e9c4 7602 	strd	r7, r6, [r4, #8]
	io->ops = ops ? *ops : nops;
1fffbda8:	3418      	adds	r4, #24
1fffbdaa:	b145      	cbz	r5, 1fffbdbe <metal_io_init+0x50>
1fffbdac:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1fffbdae:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1fffbdb0:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
1fffbdb4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	metal_sys_io_mem_map(io);
}
1fffbdb8:	b009      	add	sp, #36	; 0x24
1fffbdba:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	io->ops = ops ? *ops : nops;
1fffbdbe:	466d      	mov	r5, sp
1fffbdc0:	e7f4      	b.n	1fffbdac <metal_io_init+0x3e>

1fffbdc2 <metal_io_block_read>:

int metal_io_block_read(struct metal_io_region *io, unsigned long offset,
	       void *restrict dst, int len)
{
1fffbdc2:	b573      	push	{r0, r1, r4, r5, r6, lr}
	return (io->virt != METAL_BAD_VA && offset < io->size
1fffbdc4:	6804      	ldr	r4, [r0, #0]
		: NULL);
1fffbdc6:	1c66      	adds	r6, r4, #1
1fffbdc8:	d031      	beq.n	1fffbe2e <metal_io_block_read+0x6c>
	return (io->virt != METAL_BAD_VA && offset < io->size
1fffbdca:	6885      	ldr	r5, [r0, #8]
1fffbdcc:	42a9      	cmp	r1, r5
1fffbdce:	d22e      	bcs.n	1fffbe2e <metal_io_block_read+0x6c>
	unsigned char *ptr = metal_io_virt(io, offset);
	unsigned char *dest = dst;
	int retlen;

	if (!ptr)
1fffbdd0:	1864      	adds	r4, r4, r1
1fffbdd2:	d02c      	beq.n	1fffbe2e <metal_io_block_read+0x6c>
		return -ERANGE;
	if ((offset + len) > io->size)
1fffbdd4:	185e      	adds	r6, r3, r1
1fffbdd6:	42ae      	cmp	r6, r5
		len = io->size - offset;
1fffbdd8:	bf88      	it	hi
1fffbdda:	1a6b      	subhi	r3, r5, r1
	retlen = len;
	if (io->ops.block_read) {
1fffbddc:	6a05      	ldr	r5, [r0, #32]
1fffbdde:	b135      	cbz	r5, 1fffbdee <metal_io_block_read+0x2c>
		retlen = (*io->ops.block_read)(
1fffbde0:	9300      	str	r3, [sp, #0]
1fffbde2:	2305      	movs	r3, #5
1fffbde4:	47a8      	blx	r5
1fffbde6:	4603      	mov	r3, r0
		for (; len != 0; dest++, ptr++, len--)
			*(unsigned char *)dest =
				*(const unsigned char *)ptr;
	}
	return retlen;
}
1fffbde8:	4618      	mov	r0, r3
1fffbdea:	b002      	add	sp, #8
1fffbdec:	bd70      	pop	{r4, r5, r6, pc}
		while ( len && (
1fffbdee:	4619      	mov	r1, r3
1fffbdf0:	1aa4      	subs	r4, r4, r2
		atomic_thread_fence(memory_order_seq_cst);
1fffbdf2:	f3bf 8f5b 	dmb	ish
		while ( len && (
1fffbdf6:	1910      	adds	r0, r2, r4
1fffbdf8:	b119      	cbz	r1, 1fffbe02 <metal_io_block_read+0x40>
			((uintptr_t)dest % sizeof(int)) ||
1fffbdfa:	ea40 0502 	orr.w	r5, r0, r2
1fffbdfe:	07ad      	lsls	r5, r5, #30
1fffbe00:	d10a      	bne.n	1fffbe18 <metal_io_block_read+0x56>
		for (; len >= (int)sizeof(int); dest += sizeof(int),
1fffbe02:	2903      	cmp	r1, #3
1fffbe04:	dc0d      	bgt.n	1fffbe22 <metal_io_block_read+0x60>
1fffbe06:	3801      	subs	r0, #1
1fffbe08:	4411      	add	r1, r2
		for (; len != 0; dest++, ptr++, len--)
1fffbe0a:	428a      	cmp	r2, r1
1fffbe0c:	d0ec      	beq.n	1fffbde8 <metal_io_block_read+0x26>
				*(const unsigned char *)ptr;
1fffbe0e:	f810 4f01 	ldrb.w	r4, [r0, #1]!
			*(unsigned char *)dest =
1fffbe12:	f802 4b01 	strb.w	r4, [r2], #1
		for (; len != 0; dest++, ptr++, len--)
1fffbe16:	e7f8      	b.n	1fffbe0a <metal_io_block_read+0x48>
				*(const unsigned char *)ptr;
1fffbe18:	7800      	ldrb	r0, [r0, #0]
			*(unsigned char *)dest =
1fffbe1a:	f802 0b01 	strb.w	r0, [r2], #1
			len--;
1fffbe1e:	3901      	subs	r1, #1
1fffbe20:	e7e9      	b.n	1fffbdf6 <metal_io_block_read+0x34>
			*(unsigned int *)dest = *(const unsigned int *)ptr;
1fffbe22:	f850 4b04 	ldr.w	r4, [r0], #4
1fffbe26:	f842 4b04 	str.w	r4, [r2], #4
					ptr += sizeof(int),
1fffbe2a:	3904      	subs	r1, #4
1fffbe2c:	e7e9      	b.n	1fffbe02 <metal_io_block_read+0x40>
		return -ERANGE;
1fffbe2e:	f06f 0321 	mvn.w	r3, #33	; 0x21
1fffbe32:	e7d9      	b.n	1fffbde8 <metal_io_block_read+0x26>

1fffbe34 <metal_io_block_write>:

int metal_io_block_write(struct metal_io_region *io, unsigned long offset,
	       const void *restrict src, int len)
{
1fffbe34:	b573      	push	{r0, r1, r4, r5, r6, lr}
1fffbe36:	6804      	ldr	r4, [r0, #0]
		: NULL);
1fffbe38:	1c65      	adds	r5, r4, #1
1fffbe3a:	d032      	beq.n	1fffbea2 <metal_io_block_write+0x6e>
	return (io->virt != METAL_BAD_VA && offset < io->size
1fffbe3c:	6885      	ldr	r5, [r0, #8]
1fffbe3e:	42a9      	cmp	r1, r5
1fffbe40:	d22f      	bcs.n	1fffbea2 <metal_io_block_write+0x6e>
	unsigned char *ptr = metal_io_virt(io, offset);
	const unsigned char *source = src;
	int retlen;

	if (!ptr)
1fffbe42:	1864      	adds	r4, r4, r1
1fffbe44:	d02d      	beq.n	1fffbea2 <metal_io_block_write+0x6e>
		return -ERANGE;
	if ((offset + len) > io->size)
1fffbe46:	185e      	adds	r6, r3, r1
1fffbe48:	42ae      	cmp	r6, r5
		len = io->size - offset;
1fffbe4a:	bf88      	it	hi
1fffbe4c:	1a6b      	subhi	r3, r5, r1
	retlen = len;
	if (io->ops.block_write) {
1fffbe4e:	6a45      	ldr	r5, [r0, #36]	; 0x24
1fffbe50:	b1cd      	cbz	r5, 1fffbe86 <metal_io_block_write+0x52>
		retlen = (*io->ops.block_write)(
1fffbe52:	9300      	str	r3, [sp, #0]
1fffbe54:	2305      	movs	r3, #5
1fffbe56:	47a8      	blx	r5
			*(unsigned char *)ptr =
				*(const unsigned char *)source;
		atomic_thread_fence(memory_order_seq_cst);
	}
	return retlen;
}
1fffbe58:	b002      	add	sp, #8
1fffbe5a:	bd70      	pop	{r4, r5, r6, pc}
				*(const unsigned char *)source;
1fffbe5c:	f812 5b01 	ldrb.w	r5, [r2], #1
			*(unsigned char *)ptr =
1fffbe60:	7005      	strb	r5, [r0, #0]
			len--;
1fffbe62:	3901      	subs	r1, #1
1fffbe64:	4615      	mov	r5, r2
1fffbe66:	18a0      	adds	r0, r4, r2
		while ( len && (
1fffbe68:	b119      	cbz	r1, 1fffbe72 <metal_io_block_write+0x3e>
			((uintptr_t)ptr % sizeof(int)) ||
1fffbe6a:	ea40 0602 	orr.w	r6, r0, r2
1fffbe6e:	07b6      	lsls	r6, r6, #30
1fffbe70:	d1f4      	bne.n	1fffbe5c <metal_io_block_write+0x28>
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
1fffbe72:	2903      	cmp	r1, #3
1fffbe74:	dc0a      	bgt.n	1fffbe8c <metal_io_block_write+0x58>
1fffbe76:	3d01      	subs	r5, #1
1fffbe78:	4401      	add	r1, r0
		for (; len != 0; ptr++, source++, len--)
1fffbe7a:	4288      	cmp	r0, r1
1fffbe7c:	d10c      	bne.n	1fffbe98 <metal_io_block_write+0x64>
		atomic_thread_fence(memory_order_seq_cst);
1fffbe7e:	f3bf 8f5b 	dmb	ish
	retlen = len;
1fffbe82:	4618      	mov	r0, r3
1fffbe84:	e7e8      	b.n	1fffbe58 <metal_io_block_write+0x24>
1fffbe86:	4619      	mov	r1, r3
1fffbe88:	1aa4      	subs	r4, r4, r2
1fffbe8a:	e7eb      	b.n	1fffbe64 <metal_io_block_write+0x30>
			*(unsigned int *)ptr = *(const unsigned int *)source;
1fffbe8c:	f855 2b04 	ldr.w	r2, [r5], #4
1fffbe90:	f840 2b04 	str.w	r2, [r0], #4
					source += sizeof(int),
1fffbe94:	3904      	subs	r1, #4
1fffbe96:	e7ec      	b.n	1fffbe72 <metal_io_block_write+0x3e>
				*(const unsigned char *)source;
1fffbe98:	f815 2f01 	ldrb.w	r2, [r5, #1]!
			*(unsigned char *)ptr =
1fffbe9c:	f800 2b01 	strb.w	r2, [r0], #1
		for (; len != 0; ptr++, source++, len--)
1fffbea0:	e7eb      	b.n	1fffbe7a <metal_io_block_write+0x46>
		return -ERANGE;
1fffbea2:	f06f 0021 	mvn.w	r0, #33	; 0x21
1fffbea6:	e7d7      	b.n	1fffbe58 <metal_io_block_write+0x24>

1fffbea8 <metal_generic_dev_sys_open>:

	/* Since Zephyr runs bare-metal there is no mapping that needs to be
	 * done of IO regions
	 */
	return 0;
}
1fffbea8:	2000      	movs	r0, #0
1fffbeaa:	4770      	bx	lr

1fffbeac <metal_io_phys>:
 * @return	METAL_BAD_PHYS if offset is out of range, or physical address
 *		of offset.
 */
static inline metal_phys_addr_t
metal_io_phys(struct metal_io_region *io, unsigned long offset)
{
1fffbeac:	b410      	push	{r4}
	if (!io->ops.offset_to_phys) {
1fffbeae:	6b04      	ldr	r4, [r0, #48]	; 0x30
{
1fffbeb0:	4602      	mov	r2, r0
1fffbeb2:	460b      	mov	r3, r1
	if (!io->ops.offset_to_phys) {
1fffbeb4:	b984      	cbnz	r4, 1fffbed8 <metal_io_phys+0x2c>
		unsigned long page = (io->page_shift >=
1fffbeb6:	68c1      	ldr	r1, [r0, #12]
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
1fffbeb8:	291f      	cmp	r1, #31
1fffbeba:	bf98      	it	ls
1fffbebc:	fa23 f401 	lsrls.w	r4, r3, r1
		return (io->physmap && offset < io->size
1fffbec0:	6841      	ldr	r1, [r0, #4]
			? io->physmap[page] + (offset & io->page_mask)
			: METAL_BAD_PHYS);
1fffbec2:	b161      	cbz	r1, 1fffbede <metal_io_phys+0x32>
		return (io->physmap && offset < io->size
1fffbec4:	6880      	ldr	r0, [r0, #8]
1fffbec6:	4283      	cmp	r3, r0
1fffbec8:	d209      	bcs.n	1fffbede <metal_io_phys+0x32>
			? io->physmap[page] + (offset & io->page_mask)
1fffbeca:	6910      	ldr	r0, [r2, #16]
1fffbecc:	4018      	ands	r0, r3
			: METAL_BAD_PHYS);
1fffbece:	f851 3024 	ldr.w	r3, [r1, r4, lsl #2]
1fffbed2:	4418      	add	r0, r3
	}

	return io->ops.offset_to_phys(io, offset);
}
1fffbed4:	bc10      	pop	{r4}
1fffbed6:	4770      	bx	lr
	return io->ops.offset_to_phys(io, offset);
1fffbed8:	4623      	mov	r3, r4
}
1fffbeda:	bc10      	pop	{r4}
	return io->ops.offset_to_phys(io, offset);
1fffbedc:	4718      	bx	r3
			: METAL_BAD_PHYS);
1fffbede:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
1fffbee2:	e7f7      	b.n	1fffbed4 <metal_io_phys+0x28>

1fffbee4 <metal_io_phys_to_virt>:
 * @param[in]	phys	Physical address within segment.
 * @return	NULL if out of range, or corresponding virtual address.
 */
static inline void *
metal_io_phys_to_virt(struct metal_io_region *io, metal_phys_addr_t phys)
{
1fffbee4:	b570      	push	{r4, r5, r6, lr}
	if (!io->ops.phys_to_offset) {
1fffbee6:	6b43      	ldr	r3, [r0, #52]	; 0x34
{
1fffbee8:	4605      	mov	r5, r0
1fffbeea:	460e      	mov	r6, r1
	if (!io->ops.phys_to_offset) {
1fffbeec:	b9e3      	cbnz	r3, 1fffbf28 <metal_io_phys_to_virt+0x44>
			(io->page_mask == (metal_phys_addr_t)(-1) ?
1fffbeee:	6904      	ldr	r4, [r0, #16]
			phys - io->physmap[0] :  phys & io->page_mask);
1fffbef0:	1c62      	adds	r2, r4, #1
1fffbef2:	bf05      	ittet	eq
1fffbef4:	6843      	ldreq	r3, [r0, #4]
1fffbef6:	681c      	ldreq	r4, [r3, #0]
1fffbef8:	400c      	andne	r4, r1
1fffbefa:	1b0c      	subeq	r4, r1, r4
			if (metal_io_phys(io, offset) == phys)
1fffbefc:	4621      	mov	r1, r4
1fffbefe:	4628      	mov	r0, r5
1fffbf00:	f7ff ffd4 	bl	1fffbeac <metal_io_phys>
1fffbf04:	4286      	cmp	r6, r0
1fffbf06:	d007      	beq.n	1fffbf18 <metal_io_phys_to_virt+0x34>
			offset += io->page_mask + 1;
1fffbf08:	692b      	ldr	r3, [r5, #16]
1fffbf0a:	3301      	adds	r3, #1
1fffbf0c:	441c      	add	r4, r3
		} while (offset < io->size);
1fffbf0e:	68ab      	ldr	r3, [r5, #8]
1fffbf10:	429c      	cmp	r4, r3
1fffbf12:	d3f3      	bcc.n	1fffbefc <metal_io_phys_to_virt+0x18>
		return METAL_BAD_OFFSET;
1fffbf14:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
	return (io->virt != METAL_BAD_VA && offset < io->size
1fffbf18:	6828      	ldr	r0, [r5, #0]
		: NULL);
1fffbf1a:	1c43      	adds	r3, r0, #1
1fffbf1c:	d007      	beq.n	1fffbf2e <metal_io_phys_to_virt+0x4a>
	return (io->virt != METAL_BAD_VA && offset < io->size
1fffbf1e:	68ab      	ldr	r3, [r5, #8]
1fffbf20:	42a3      	cmp	r3, r4
1fffbf22:	d904      	bls.n	1fffbf2e <metal_io_phys_to_virt+0x4a>
		? (void *)((uintptr_t)io->virt + offset)
1fffbf24:	4420      	add	r0, r4
	return metal_io_virt(io, metal_io_phys_to_offset(io, phys));
}
1fffbf26:	bd70      	pop	{r4, r5, r6, pc}
	return (*io->ops.phys_to_offset)(io, phys);
1fffbf28:	4798      	blx	r3
1fffbf2a:	4604      	mov	r4, r0
1fffbf2c:	e7f4      	b.n	1fffbf18 <metal_io_phys_to_virt+0x34>
		: NULL);
1fffbf2e:	2000      	movs	r0, #0
	return metal_io_virt(io, metal_io_phys_to_offset(io, phys));
1fffbf30:	e7f9      	b.n	1fffbf26 <metal_io_phys_to_virt+0x42>

1fffbf32 <virtqueue_create>:
{
1fffbf32:	b510      	push	{r4, lr}
1fffbf34:	9c04      	ldr	r4, [sp, #16]
		vq->vq_name = name;
1fffbf36:	e9c4 0200 	strd	r0, r2, [r4]
		vq->vq_queue_index = id;
1fffbf3a:	8121      	strh	r1, [r4, #8]
		vq->callback = callback;
1fffbf3c:	9a02      	ldr	r2, [sp, #8]
		vq->vq_nentries = ring->num_descs;
1fffbf3e:	8919      	ldrh	r1, [r3, #8]
		vq->callback = callback;
1fffbf40:	60e2      	str	r2, [r4, #12]
		vq->notify = notify;
1fffbf42:	9a03      	ldr	r2, [sp, #12]
		vq->vq_nentries = ring->num_descs;
1fffbf44:	8161      	strh	r1, [r4, #10]
		vq->vq_free_cnt = vq->vq_nentries;
1fffbf46:	84a1      	strh	r1, [r4, #36]	; 0x24
		vq->notify = notify;
1fffbf48:	6122      	str	r2, [r4, #16]
		vq_ring_init(vq, ring->vaddr, ring->align);
1fffbf4a:	e9d3 2000 	ldrd	r2, r0, [r3]
static inline void
vring_init(struct vring *vr, unsigned int num, uint8_t *p, unsigned long align)
{
	vr->num = num;
	vr->desc = (struct vring_desc *)p;
	vr->avail = (struct vring_avail *)(p + num * sizeof(struct vring_desc));
1fffbf4e:	eb02 1301 	add.w	r3, r2, r1, lsl #4
	vr->desc = (struct vring_desc *)p;
1fffbf52:	e9c4 1205 	strd	r1, r2, [r4, #20]
	vr->used = (struct vring_used *)
	    (((unsigned long)&vr->avail->ring[num] + sizeof(uint16_t) +
1fffbf56:	3102      	adds	r1, #2
	      align - 1) & ~(align - 1));
1fffbf58:	1c42      	adds	r2, r0, #1
	vr->avail = (struct vring_avail *)(p + num * sizeof(struct vring_desc));
1fffbf5a:	61e3      	str	r3, [r4, #28]
	    (((unsigned long)&vr->avail->ring[num] + sizeof(uint16_t) +
1fffbf5c:	eb03 0341 	add.w	r3, r3, r1, lsl #1
	      align - 1) & ~(align - 1));
1fffbf60:	4413      	add	r3, r2
1fffbf62:	4240      	negs	r0, r0
1fffbf64:	4003      	ands	r3, r0
	vr->used = (struct vring_used *)
1fffbf66:	6223      	str	r3, [r4, #32]
}
1fffbf68:	2000      	movs	r0, #0
1fffbf6a:	bd10      	pop	{r4, pc}

1fffbf6c <virtqueue_get_buffer_length>:
	return vq->vq_ring.desc[idx].len;
1fffbf6c:	6983      	ldr	r3, [r0, #24]
1fffbf6e:	eb03 1301 	add.w	r3, r3, r1, lsl #4
}
1fffbf72:	6898      	ldr	r0, [r3, #8]
1fffbf74:	4770      	bx	lr

1fffbf76 <virtqueue_get_available_buffer>:
{
1fffbf76:	b570      	push	{r4, r5, r6, lr}
1fffbf78:	460d      	mov	r5, r1
	atomic_thread_fence(memory_order_seq_cst);
1fffbf7a:	f3bf 8f5b 	dmb	ish
	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
1fffbf7e:	69c1      	ldr	r1, [r0, #28]
1fffbf80:	8e03      	ldrh	r3, [r0, #48]	; 0x30
{
1fffbf82:	4616      	mov	r6, r2
	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
1fffbf84:	884a      	ldrh	r2, [r1, #2]
1fffbf86:	429a      	cmp	r2, r3
{
1fffbf88:	4604      	mov	r4, r0
	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
1fffbf8a:	d016      	beq.n	1fffbfba <virtqueue_get_available_buffer+0x44>
	head_idx = vq->vq_available_idx++ & (vq->vq_nentries - 1);
1fffbf8c:	1c5a      	adds	r2, r3, #1
1fffbf8e:	8602      	strh	r2, [r0, #48]	; 0x30
1fffbf90:	8942      	ldrh	r2, [r0, #10]
1fffbf92:	3a01      	subs	r2, #1
	*avail_idx = vq->vq_ring.avail->ring[head_idx];
1fffbf94:	4013      	ands	r3, r2
1fffbf96:	eb01 0143 	add.w	r1, r1, r3, lsl #1
1fffbf9a:	888a      	ldrh	r2, [r1, #4]
1fffbf9c:	802a      	strh	r2, [r5, #0]
1fffbf9e:	b293      	uxth	r3, r2
	buffer = virtqueue_phys_to_virt(vq, vq->vq_ring.desc[*avail_idx].addr);
1fffbfa0:	011b      	lsls	r3, r3, #4
1fffbfa2:	6982      	ldr	r2, [r0, #24]
	return metal_io_phys_to_virt(io, phys);
1fffbfa4:	6a80      	ldr	r0, [r0, #40]	; 0x28
1fffbfa6:	58d1      	ldr	r1, [r2, r3]
1fffbfa8:	f7ff ff9c 	bl	1fffbee4 <metal_io_phys_to_virt>
	*len = vq->vq_ring.desc[*avail_idx].len;
1fffbfac:	882a      	ldrh	r2, [r5, #0]
1fffbfae:	69a3      	ldr	r3, [r4, #24]
1fffbfb0:	eb03 1302 	add.w	r3, r3, r2, lsl #4
1fffbfb4:	689b      	ldr	r3, [r3, #8]
1fffbfb6:	6033      	str	r3, [r6, #0]
}
1fffbfb8:	bd70      	pop	{r4, r5, r6, pc}
		return NULL;
1fffbfba:	2000      	movs	r0, #0
1fffbfbc:	e7fc      	b.n	1fffbfb8 <virtqueue_get_available_buffer+0x42>

1fffbfbe <virtqueue_disable_cb>:
 */
void virtqueue_disable_cb(struct virtqueue *vq)
{
	VQUEUE_BUSY(vq);

	if (vq->vq_dev->features & VIRTIO_RING_F_EVENT_IDX) {
1fffbfbe:	6802      	ldr	r2, [r0, #0]
			    vq->vq_used_cons_idx - vq->vq_nentries - 1;
			VRING_FLUSH(vring_used_event(&vq->vq_ring));
		}
#endif /*VIRTIO_DEVICE_ONLY*/
#ifndef VIRTIO_DRIVER_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_DEVICE) {
1fffbfc0:	6993      	ldr	r3, [r2, #24]
	if (vq->vq_dev->features & VIRTIO_RING_F_EVENT_IDX) {
1fffbfc2:	6912      	ldr	r2, [r2, #16]
1fffbfc4:	0092      	lsls	r2, r2, #2
1fffbfc6:	d50b      	bpl.n	1fffbfe0 <virtqueue_disable_cb+0x22>
		if (vq->vq_dev->role == VIRTIO_DEV_DEVICE) {
1fffbfc8:	2b01      	cmp	r3, #1
1fffbfca:	d110      	bne.n	1fffbfee <virtqueue_disable_cb+0x30>
			vring_avail_event(&vq->vq_ring) =
1fffbfcc:	6a02      	ldr	r2, [r0, #32]
1fffbfce:	6941      	ldr	r1, [r0, #20]
			    vq->vq_available_idx - vq->vq_nentries - 1;
1fffbfd0:	8e03      	ldrh	r3, [r0, #48]	; 0x30
1fffbfd2:	8940      	ldrh	r0, [r0, #10]
1fffbfd4:	3b01      	subs	r3, #1
			vring_avail_event(&vq->vq_ring) =
1fffbfd6:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
			    vq->vq_available_idx - vq->vq_nentries - 1;
1fffbfda:	1a1b      	subs	r3, r3, r0
			vring_avail_event(&vq->vq_ring) =
1fffbfdc:	8093      	strh	r3, [r2, #4]
1fffbfde:	4770      	bx	lr
			vq->vq_ring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
			VRING_FLUSH(vq->vq_ring.avail->flags);
		}
#endif /*VIRTIO_DEVICE_ONLY*/
#ifndef VIRTIO_DRIVER_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_DEVICE) {
1fffbfe0:	2b01      	cmp	r3, #1
			vq->vq_ring.used->flags |= VRING_USED_F_NO_NOTIFY;
1fffbfe2:	bf01      	itttt	eq
1fffbfe4:	6a02      	ldreq	r2, [r0, #32]
1fffbfe6:	8813      	ldrheq	r3, [r2, #0]
1fffbfe8:	f043 0301 	orreq.w	r3, r3, #1
1fffbfec:	8013      	strheq	r3, [r2, #0]
		}
#endif /*VIRTIO_DRIVER_ONLY*/
	}

	VQUEUE_IDLE(vq);
}
1fffbfee:	4770      	bx	lr

1fffbff0 <virtqueue_kick>:
 * virtqueue_kick - Notifies other side that there is buffer available for it.
 *
 * @param vq      - Pointer to VirtIO queue control block
 */
void virtqueue_kick(struct virtqueue *vq)
{
1fffbff0:	b510      	push	{r4, lr}
	VQUEUE_BUSY(vq);

	/* Ensure updated avail->idx is visible to host. */
	atomic_thread_fence(memory_order_seq_cst);
1fffbff2:	f3bf 8f5b 	dmb	ish
 */
static int vq_ring_must_notify(struct virtqueue *vq)
{
	uint16_t new_idx, prev_idx, event_idx;

	if (vq->vq_dev->features & VIRTIO_RING_F_EVENT_IDX) {
1fffbff6:	6803      	ldr	r3, [r0, #0]
1fffbff8:	691a      	ldr	r2, [r3, #16]
1fffbffa:	699b      	ldr	r3, [r3, #24]
1fffbffc:	f012 5f00 	tst.w	r2, #536870912	; 0x20000000
{
1fffc000:	4604      	mov	r4, r0
	if (vq->vq_dev->features & VIRTIO_RING_F_EVENT_IDX) {
1fffc002:	d011      	beq.n	1fffc028 <virtqueue_kick+0x38>
			return vring_need_event(event_idx, new_idx,
						prev_idx) != 0;
		}
#endif /*VIRTIO_DEVICE_ONLY*/
#ifndef VIRTIO_DRIVER_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_DEVICE) {
1fffc004:	2b01      	cmp	r3, #1
1fffc006:	d10c      	bne.n	1fffc022 <virtqueue_kick+0x32>
			/* CACHE: no need to invalidate used */
			new_idx = vq->vq_ring.used->idx;
			prev_idx = new_idx - vq->vq_queued_cnt;
			VRING_INVALIDATE(vring_used_event(&vq->vq_ring));
			event_idx = vring_used_event(&vq->vq_ring);
1fffc008:	69c2      	ldr	r2, [r0, #28]
1fffc00a:	6941      	ldr	r1, [r0, #20]
			new_idx = vq->vq_ring.used->idx;
1fffc00c:	6a03      	ldr	r3, [r0, #32]
			event_idx = vring_used_event(&vq->vq_ring);
1fffc00e:	eb02 0241 	add.w	r2, r2, r1, lsl #1
			new_idx = vq->vq_ring.used->idx;
1fffc012:	885b      	ldrh	r3, [r3, #2]
			event_idx = vring_used_event(&vq->vq_ring);
1fffc014:	8892      	ldrh	r2, [r2, #4]
 * event?
 */
static inline int
vring_need_event(uint16_t event_idx, uint16_t new_idx, uint16_t old)
{
	return (uint16_t)(new_idx - event_idx - 1) <
1fffc016:	3b01      	subs	r3, #1
1fffc018:	1a9b      	subs	r3, r3, r2
	if (vq_ring_must_notify(vq))
1fffc01a:	8cc2      	ldrh	r2, [r0, #38]	; 0x26
1fffc01c:	b29b      	uxth	r3, r3
1fffc01e:	429a      	cmp	r2, r3
1fffc020:	d808      	bhi.n	1fffc034 <virtqueue_kick+0x44>
	vq->vq_queued_cnt = 0;
1fffc022:	2300      	movs	r3, #0
1fffc024:	84e3      	strh	r3, [r4, #38]	; 0x26
}
1fffc026:	bd10      	pop	{r4, pc}
			return (vq->vq_ring.used->flags &
				VRING_USED_F_NO_NOTIFY) == 0;
		}
#endif /*VIRTIO_DEVICE_ONLY*/
#ifndef VIRTIO_DRIVER_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_DEVICE) {
1fffc028:	2b01      	cmp	r3, #1
1fffc02a:	d1fa      	bne.n	1fffc022 <virtqueue_kick+0x32>
			VRING_INVALIDATE(vq->vq_ring.avail->flags);
			return (vq->vq_ring.avail->flags &
1fffc02c:	69c3      	ldr	r3, [r0, #28]
1fffc02e:	881b      	ldrh	r3, [r3, #0]
	if (vq_ring_must_notify(vq))
1fffc030:	07db      	lsls	r3, r3, #31
1fffc032:	d4f6      	bmi.n	1fffc022 <virtqueue_kick+0x32>
 * vq_ring_notify
 *
 */
static void vq_ring_notify(struct virtqueue *vq)
{
	if (vq->notify)
1fffc034:	6923      	ldr	r3, [r4, #16]
1fffc036:	2b00      	cmp	r3, #0
1fffc038:	d0f3      	beq.n	1fffc022 <virtqueue_kick+0x32>
		vq->notify(vq);
1fffc03a:	4620      	mov	r0, r4
1fffc03c:	4798      	blx	r3
1fffc03e:	e7f0      	b.n	1fffc022 <virtqueue_kick+0x32>

1fffc040 <virtqueue_notification>:
	atomic_thread_fence(memory_order_seq_cst);
1fffc040:	f3bf 8f5b 	dmb	ish
	if (vq->callback)
1fffc044:	68c3      	ldr	r3, [r0, #12]
1fffc046:	b103      	cbz	r3, 1fffc04a <virtqueue_notification+0xa>
		vq->callback(vq);
1fffc048:	4718      	bx	r3
}
1fffc04a:	4770      	bx	lr

1fffc04c <__metal_mutex_acquire>:
	return z_impl_k_sem_take(sem, timeout);
1fffc04c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
1fffc050:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
1fffc054:	f7fe bb36 	b.w	1fffa6c4 <z_impl_k_sem_take>

1fffc058 <rpmsg_unregister_endpoint>:
{
1fffc058:	b570      	push	{r4, r5, r6, lr}
	struct rpmsg_device *rdev = ept->rdev;
1fffc05a:	6a05      	ldr	r5, [r0, #32]
{
1fffc05c:	4604      	mov	r4, r0
	metal_mutex_acquire(&rdev->lock);
1fffc05e:	f105 0658 	add.w	r6, r5, #88	; 0x58
1fffc062:	4630      	mov	r0, r6
1fffc064:	f7ff fff2 	bl	1fffc04c <__metal_mutex_acquire>
	if (ept->addr != RPMSG_ADDR_ANY)
1fffc068:	6a63      	ldr	r3, [r4, #36]	; 0x24
1fffc06a:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
1fffc06e:	2b7f      	cmp	r3, #127	; 0x7f
1fffc070:	d80b      	bhi.n	1fffc08a <rpmsg_unregister_endpoint+0x32>
	bitmap[bit / METAL_BITS_PER_ULONG] &=
1fffc072:	0959      	lsrs	r1, r3, #5
		rpmsg_release_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE,
1fffc074:	3548      	adds	r5, #72	; 0x48
		~metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
1fffc076:	f003 031f 	and.w	r3, r3, #31
1fffc07a:	2201      	movs	r2, #1
1fffc07c:	409a      	lsls	r2, r3
	bitmap[bit / METAL_BITS_PER_ULONG] &=
1fffc07e:	f855 3021 	ldr.w	r3, [r5, r1, lsl #2]
1fffc082:	ea23 0302 	bic.w	r3, r3, r2
1fffc086:	f845 3021 	str.w	r3, [r5, r1, lsl #2]
	node->next->prev = node->prev;
1fffc08a:	e9d4 120d 	ldrd	r1, r2, [r4, #52]	; 0x34
1fffc08e:	604a      	str	r2, [r1, #4]
	node->prev->next = node->next;
1fffc090:	6b61      	ldr	r1, [r4, #52]	; 0x34
1fffc092:	6011      	str	r1, [r2, #0]
	metal_list_del(&ept->node);
1fffc094:	f104 0334 	add.w	r3, r4, #52	; 0x34
	node->next = node;
1fffc098:	e9c4 330d 	strd	r3, r3, [r4, #52]	; 0x34
	ept->rdev = NULL;
1fffc09c:	2300      	movs	r3, #0
1fffc09e:	6223      	str	r3, [r4, #32]
	z_impl_k_sem_give(sem);
1fffc0a0:	4630      	mov	r0, r6
}
1fffc0a2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
1fffc0a6:	f7fe baed 	b.w	1fffa684 <z_impl_k_sem_give>

1fffc0aa <rpmsg_send_ns_message>:
{
1fffc0aa:	b510      	push	{r4, lr}
1fffc0ac:	b08c      	sub	sp, #48	; 0x30
	ns_msg.addr = ept->addr;
1fffc0ae:	6a43      	ldr	r3, [r0, #36]	; 0x24
	ns_msg.flags = flags;
1fffc0b0:	910b      	str	r1, [sp, #44]	; 0x2c
{
1fffc0b2:	4604      	mov	r4, r0
	strncpy(ns_msg.name, ept->name, sizeof(ns_msg.name));
1fffc0b4:	4601      	mov	r1, r0
1fffc0b6:	2220      	movs	r2, #32
1fffc0b8:	a802      	add	r0, sp, #8
	ns_msg.addr = ept->addr;
1fffc0ba:	930a      	str	r3, [sp, #40]	; 0x28
	strncpy(ns_msg.name, ept->name, sizeof(ns_msg.name));
1fffc0bc:	f7ff fa1b 	bl	1fffb4f6 <strncpy>
	ret = rpmsg_send_offchannel_raw(ept, ept->addr,
1fffc0c0:	2328      	movs	r3, #40	; 0x28
1fffc0c2:	2201      	movs	r2, #1
1fffc0c4:	e9cd 3200 	strd	r3, r2, [sp]
1fffc0c8:	4620      	mov	r0, r4
1fffc0ca:	6a61      	ldr	r1, [r4, #36]	; 0x24
1fffc0cc:	ab02      	add	r3, sp, #8
1fffc0ce:	2235      	movs	r2, #53	; 0x35
1fffc0d0:	f7fd ff6a 	bl	1fff9fa8 <rpmsg_send_offchannel_raw>
}
1fffc0d4:	ea00 70e0 	and.w	r0, r0, r0, asr #31
1fffc0d8:	b00c      	add	sp, #48	; 0x30
1fffc0da:	bd10      	pop	{r4, pc}

1fffc0dc <rpmsg_hold_rx_buffer>:
	if (!ept || !ept->rdev || !rxbuf)
1fffc0dc:	b128      	cbz	r0, 1fffc0ea <rpmsg_hold_rx_buffer+0xe>
1fffc0de:	6a00      	ldr	r0, [r0, #32]
1fffc0e0:	b118      	cbz	r0, 1fffc0ea <rpmsg_hold_rx_buffer+0xe>
1fffc0e2:	b111      	cbz	r1, 1fffc0ea <rpmsg_hold_rx_buffer+0xe>
	if (rdev->ops.hold_rx_buffer)
1fffc0e4:	6f43      	ldr	r3, [r0, #116]	; 0x74
1fffc0e6:	b103      	cbz	r3, 1fffc0ea <rpmsg_hold_rx_buffer+0xe>
		rdev->ops.hold_rx_buffer(rdev, rxbuf);
1fffc0e8:	4718      	bx	r3
}
1fffc0ea:	4770      	bx	lr

1fffc0ec <rpmsg_release_rx_buffer>:
	if (!ept || !ept->rdev || !rxbuf)
1fffc0ec:	b128      	cbz	r0, 1fffc0fa <rpmsg_release_rx_buffer+0xe>
1fffc0ee:	6a00      	ldr	r0, [r0, #32]
1fffc0f0:	b118      	cbz	r0, 1fffc0fa <rpmsg_release_rx_buffer+0xe>
1fffc0f2:	b111      	cbz	r1, 1fffc0fa <rpmsg_release_rx_buffer+0xe>
	if (rdev->ops.release_rx_buffer)
1fffc0f4:	6f83      	ldr	r3, [r0, #120]	; 0x78
1fffc0f6:	b103      	cbz	r3, 1fffc0fa <rpmsg_release_rx_buffer+0xe>
		rdev->ops.release_rx_buffer(rdev, rxbuf);
1fffc0f8:	4718      	bx	r3
}
1fffc0fa:	4770      	bx	lr

1fffc0fc <rpmsg_get_endpoint>:
{
1fffc0fc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	metal_list_for_each(&rdev->endpoints, node) {
1fffc100:	6804      	ldr	r4, [r0, #0]
{
1fffc102:	4606      	mov	r6, r0
1fffc104:	4688      	mov	r8, r1
1fffc106:	4617      	mov	r7, r2
1fffc108:	4699      	mov	r9, r3
	metal_list_for_each(&rdev->endpoints, node) {
1fffc10a:	42a6      	cmp	r6, r4
1fffc10c:	d101      	bne.n	1fffc112 <rpmsg_get_endpoint+0x16>
	return NULL;
1fffc10e:	2500      	movs	r5, #0
1fffc110:	e023      	b.n	1fffc15a <rpmsg_get_endpoint+0x5e>
		if (addr != RPMSG_ADDR_ANY && ept->addr == addr)
1fffc112:	1c7a      	adds	r2, r7, #1
		ept = metal_container_of(node, struct rpmsg_endpoint, node);
1fffc114:	f1a4 0534 	sub.w	r5, r4, #52	; 0x34
		if (addr != RPMSG_ADDR_ANY && ept->addr == addr)
1fffc118:	d002      	beq.n	1fffc120 <rpmsg_get_endpoint+0x24>
1fffc11a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
1fffc11c:	42bb      	cmp	r3, r7
1fffc11e:	d01c      	beq.n	1fffc15a <rpmsg_get_endpoint+0x5e>
		if (name)
1fffc120:	f1b8 0f00 	cmp.w	r8, #0
1fffc124:	d101      	bne.n	1fffc12a <rpmsg_get_endpoint+0x2e>
	metal_list_for_each(&rdev->endpoints, node) {
1fffc126:	6824      	ldr	r4, [r4, #0]
1fffc128:	e7ef      	b.n	1fffc10a <rpmsg_get_endpoint+0xe>
			name_match = !strncmp(ept->name, name,
1fffc12a:	2220      	movs	r2, #32
1fffc12c:	4641      	mov	r1, r8
1fffc12e:	4628      	mov	r0, r5
1fffc130:	f7ff fa11 	bl	1fffb556 <strncmp>
		if (!name || !name_match)
1fffc134:	2800      	cmp	r0, #0
1fffc136:	d1f6      	bne.n	1fffc126 <rpmsg_get_endpoint+0x2a>
		if (dest_addr != RPMSG_ADDR_ANY && ept->dest_addr == dest_addr)
1fffc138:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
1fffc13c:	d002      	beq.n	1fffc144 <rpmsg_get_endpoint+0x48>
1fffc13e:	6aab      	ldr	r3, [r5, #40]	; 0x28
1fffc140:	454b      	cmp	r3, r9
1fffc142:	d00a      	beq.n	1fffc15a <rpmsg_get_endpoint+0x5e>
		if (addr == RPMSG_ADDR_ANY && ept->dest_addr == RPMSG_ADDR_ANY)
1fffc144:	1c7b      	adds	r3, r7, #1
1fffc146:	d00b      	beq.n	1fffc160 <rpmsg_get_endpoint+0x64>
	metal_list_for_each(&rdev->endpoints, node) {
1fffc148:	6824      	ldr	r4, [r4, #0]
1fffc14a:	42b4      	cmp	r4, r6
1fffc14c:	d0df      	beq.n	1fffc10e <rpmsg_get_endpoint+0x12>
		if (addr != RPMSG_ADDR_ANY && ept->addr == addr)
1fffc14e:	f854 3c10 	ldr.w	r3, [r4, #-16]
1fffc152:	429f      	cmp	r7, r3
		ept = metal_container_of(node, struct rpmsg_endpoint, node);
1fffc154:	f1a4 0534 	sub.w	r5, r4, #52	; 0x34
		if (addr != RPMSG_ADDR_ANY && ept->addr == addr)
1fffc158:	d1e7      	bne.n	1fffc12a <rpmsg_get_endpoint+0x2e>
}
1fffc15a:	4628      	mov	r0, r5
1fffc15c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (addr == RPMSG_ADDR_ANY && ept->dest_addr == RPMSG_ADDR_ANY)
1fffc160:	6aab      	ldr	r3, [r5, #40]	; 0x28
1fffc162:	3301      	adds	r3, #1
1fffc164:	d0f9      	beq.n	1fffc15a <rpmsg_get_endpoint+0x5e>
	metal_list_for_each(&rdev->endpoints, node) {
1fffc166:	6824      	ldr	r4, [r4, #0]
1fffc168:	42b4      	cmp	r4, r6
1fffc16a:	d0d0      	beq.n	1fffc10e <rpmsg_get_endpoint+0x12>
		ept = metal_container_of(node, struct rpmsg_endpoint, node);
1fffc16c:	f1a4 0534 	sub.w	r5, r4, #52	; 0x34
		if (addr != RPMSG_ADDR_ANY && ept->addr == addr)
1fffc170:	e7d6      	b.n	1fffc120 <rpmsg_get_endpoint+0x24>

1fffc172 <rpmsg_destroy_ept>:
 *
 * @param ept - pointer to endpoint to destroy
 *
 */
void rpmsg_destroy_ept(struct rpmsg_endpoint *ept)
{
1fffc172:	b510      	push	{r4, lr}
	struct rpmsg_device *rdev;

	if (!ept || !ept->rdev)
1fffc174:	4604      	mov	r4, r0
1fffc176:	b190      	cbz	r0, 1fffc19e <rpmsg_destroy_ept+0x2c>
1fffc178:	6a03      	ldr	r3, [r0, #32]
1fffc17a:	b183      	cbz	r3, 1fffc19e <rpmsg_destroy_ept+0x2c>
		return;

	rdev = ept->rdev;

	if (ept->name[0] && rdev->support_ns &&
1fffc17c:	7802      	ldrb	r2, [r0, #0]
1fffc17e:	b14a      	cbz	r2, 1fffc194 <rpmsg_destroy_ept+0x22>
1fffc180:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
1fffc184:	b133      	cbz	r3, 1fffc194 <rpmsg_destroy_ept+0x22>
1fffc186:	6a43      	ldr	r3, [r0, #36]	; 0x24
1fffc188:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
1fffc18c:	d302      	bcc.n	1fffc194 <rpmsg_destroy_ept+0x22>
	    ept->addr >= RPMSG_RESERVED_ADDRESSES)
		(void)rpmsg_send_ns_message(ept, RPMSG_NS_DESTROY);
1fffc18e:	2101      	movs	r1, #1
1fffc190:	f7ff ff8b 	bl	1fffc0aa <rpmsg_send_ns_message>
	rpmsg_unregister_endpoint(ept);
1fffc194:	4620      	mov	r0, r4
}
1fffc196:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	rpmsg_unregister_endpoint(ept);
1fffc19a:	f7ff bf5d 	b.w	1fffc058 <rpmsg_unregister_endpoint>
}
1fffc19e:	bd10      	pop	{r4, pc}

1fffc1a0 <rpmsg_virtio_hold_rx_buffer>:
	rp_hdr->reserved |= RPMSG_BUF_HELD;
1fffc1a0:	f851 3c08 	ldr.w	r3, [r1, #-8]
1fffc1a4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
1fffc1a8:	f841 3c08 	str.w	r3, [r1, #-8]
}
1fffc1ac:	4770      	bx	lr

1fffc1ae <rpmsg_virtio_tx_callback>:
}
1fffc1ae:	4770      	bx	lr

1fffc1b0 <k_sem_give>:
1fffc1b0:	f7fe ba68 	b.w	1fffa684 <z_impl_k_sem_give>

1fffc1b4 <__metal_mutex_acquire>:
	return z_impl_k_sem_take(sem, timeout);
1fffc1b4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
1fffc1b8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
1fffc1bc:	f7fe ba82 	b.w	1fffa6c4 <z_impl_k_sem_take>

1fffc1c0 <rpmsg_virtio_release_tx_buffer>:
{
1fffc1c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	idx = rp_hdr->reserved;
1fffc1c2:	f851 6c08 	ldr.w	r6, [r1, #-8]
{
1fffc1c6:	460c      	mov	r4, r1
	metal_mutex_acquire(&rdev->lock);
1fffc1c8:	f100 0758 	add.w	r7, r0, #88	; 0x58
{
1fffc1cc:	4605      	mov	r5, r0
	idx = rp_hdr->reserved;
1fffc1ce:	b2b6      	uxth	r6, r6
1fffc1d0:	4638      	mov	r0, r7
1fffc1d2:	f7ff ffef 	bl	1fffc1b4 <__metal_mutex_acquire>
	r_desc->idx = idx;
1fffc1d6:	f824 6c08 	strh.w	r6, [r4, #-8]
	new_node->prev = node->prev;
1fffc1da:	f8d5 20b0 	ldr.w	r2, [r5, #176]	; 0xb0
1fffc1de:	f844 2c0c 	str.w	r2, [r4, #-12]
	metal_list_add_tail(&rvdev->reclaimer, &r_desc->node);
1fffc1e2:	f1a4 0310 	sub.w	r3, r4, #16
1fffc1e6:	f105 02ac 	add.w	r2, r5, #172	; 0xac
	new_node->next = node;
1fffc1ea:	f844 2c10 	str.w	r2, [r4, #-16]
	new_node->next->prev = new_node;
1fffc1ee:	f8c5 30b0 	str.w	r3, [r5, #176]	; 0xb0
	new_node->prev->next = new_node;
1fffc1f2:	f854 2c0c 	ldr.w	r2, [r4, #-12]
	k_sem_take(m, K_FOREVER);
}

static inline void __metal_mutex_release(metal_mutex_t *m)
{
	k_sem_give(m);
1fffc1f6:	4638      	mov	r0, r7
1fffc1f8:	6013      	str	r3, [r2, #0]
1fffc1fa:	f7ff ffd9 	bl	1fffc1b0 <k_sem_give>
}
1fffc1fe:	2000      	movs	r0, #0
1fffc200:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

1fffc202 <rpmsg_virtio_ns_callback>:
{
1fffc202:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct rpmsg_device *rdev = ept->rdev;
1fffc206:	6a05      	ldr	r5, [r0, #32]
	if (len != sizeof(*ns_msg))
1fffc208:	2a28      	cmp	r2, #40	; 0x28
	struct metal_io_region *io = rvdev->shbuf_io;
1fffc20a:	f8d5 00a4 	ldr.w	r0, [r5, #164]	; 0xa4
{
1fffc20e:	b088      	sub	sp, #32
1fffc210:	460f      	mov	r7, r1
	if (len != sizeof(*ns_msg))
1fffc212:	d126      	bne.n	1fffc262 <rpmsg_virtio_ns_callback+0x60>
	size_t offset = (uintptr_t)virt - (uintptr_t)io->virt;
1fffc214:	6801      	ldr	r1, [r0, #0]
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
1fffc216:	6884      	ldr	r4, [r0, #8]
	size_t offset = (uintptr_t)virt - (uintptr_t)io->virt;
1fffc218:	1a79      	subs	r1, r7, r1
	metal_io_block_read(io,
1fffc21a:	42a1      	cmp	r1, r4
1fffc21c:	bf28      	it	cs
1fffc21e:	f04f 31ff 	movcs.w	r1, #4294967295	; 0xffffffff
1fffc222:	2320      	movs	r3, #32
1fffc224:	466a      	mov	r2, sp
1fffc226:	f7ff fdcc 	bl	1fffbdc2 <metal_io_block_read>
	metal_mutex_acquire(&rdev->lock);
1fffc22a:	f105 0658 	add.w	r6, r5, #88	; 0x58
	dest = ns_msg->addr;
1fffc22e:	f8d7 8020 	ldr.w	r8, [r7, #32]
1fffc232:	4630      	mov	r0, r6
1fffc234:	f7ff ffbe 	bl	1fffc1b4 <__metal_mutex_acquire>
	_ept = rpmsg_get_endpoint(rdev, name, RPMSG_ADDR_ANY, dest);
1fffc238:	4643      	mov	r3, r8
1fffc23a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
1fffc23e:	4669      	mov	r1, sp
1fffc240:	4628      	mov	r0, r5
1fffc242:	f7ff ff5b 	bl	1fffc0fc <rpmsg_get_endpoint>
	if (ns_msg->flags & RPMSG_NS_DESTROY) {
1fffc246:	6a7b      	ldr	r3, [r7, #36]	; 0x24
1fffc248:	07db      	lsls	r3, r3, #31
	_ept = rpmsg_get_endpoint(rdev, name, RPMSG_ADDR_ANY, dest);
1fffc24a:	4604      	mov	r4, r0
	if (ns_msg->flags & RPMSG_NS_DESTROY) {
1fffc24c:	d519      	bpl.n	1fffc282 <rpmsg_virtio_ns_callback+0x80>
		if (_ept)
1fffc24e:	b960      	cbnz	r0, 1fffc26a <rpmsg_virtio_ns_callback+0x68>
1fffc250:	4630      	mov	r0, r6
1fffc252:	f7ff ffad 	bl	1fffc1b0 <k_sem_give>
		if (rdev->ns_unbind_cb)
1fffc256:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
			if (rdev->ns_bind_cb)
1fffc258:	b11b      	cbz	r3, 1fffc262 <rpmsg_virtio_ns_callback+0x60>
				rdev->ns_bind_cb(rdev, name, dest);
1fffc25a:	4642      	mov	r2, r8
1fffc25c:	4669      	mov	r1, sp
1fffc25e:	4628      	mov	r0, r5
1fffc260:	4798      	blx	r3
}
1fffc262:	2000      	movs	r0, #0
1fffc264:	b008      	add	sp, #32
1fffc266:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			_ept->dest_addr = RPMSG_ADDR_ANY;
1fffc26a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
1fffc26e:	6283      	str	r3, [r0, #40]	; 0x28
1fffc270:	4630      	mov	r0, r6
1fffc272:	f7ff ff9d 	bl	1fffc1b0 <k_sem_give>
		if (_ept && _ept->ns_unbind_cb)
1fffc276:	6b23      	ldr	r3, [r4, #48]	; 0x30
1fffc278:	2b00      	cmp	r3, #0
1fffc27a:	d0ec      	beq.n	1fffc256 <rpmsg_virtio_ns_callback+0x54>
			_ept->ns_unbind_cb(_ept);
1fffc27c:	4620      	mov	r0, r4
1fffc27e:	4798      	blx	r3
1fffc280:	e7e9      	b.n	1fffc256 <rpmsg_virtio_ns_callback+0x54>
		if (!_ept) {
1fffc282:	b920      	cbnz	r0, 1fffc28e <rpmsg_virtio_ns_callback+0x8c>
1fffc284:	4630      	mov	r0, r6
1fffc286:	f7ff ff93 	bl	1fffc1b0 <k_sem_give>
			if (rdev->ns_bind_cb)
1fffc28a:	6eab      	ldr	r3, [r5, #104]	; 0x68
1fffc28c:	e7e4      	b.n	1fffc258 <rpmsg_virtio_ns_callback+0x56>
			_ept->dest_addr = dest;
1fffc28e:	f8c0 8028 	str.w	r8, [r0, #40]	; 0x28
1fffc292:	4630      	mov	r0, r6
1fffc294:	f7ff ff8c 	bl	1fffc1b0 <k_sem_give>
 * @see metal_mutex_try_acquire, metal_mutex_acquire
 */
static inline void metal_mutex_release(metal_mutex_t *mutex)
{
	__metal_mutex_release(mutex);
}
1fffc298:	e7e3      	b.n	1fffc262 <rpmsg_virtio_ns_callback+0x60>

1fffc29a <rpmsg_virtio_send_offchannel_nocopy>:
{
1fffc29a:	b5f0      	push	{r4, r5, r6, r7, lr}
1fffc29c:	b085      	sub	sp, #20
	idx = hdr->reserved;
1fffc29e:	f853 5c08 	ldr.w	r5, [r3, #-8]
{
1fffc2a2:	9e0a      	ldr	r6, [sp, #40]	; 0x28
	rp_hdr.len = len;
1fffc2a4:	f8ad 600c 	strh.w	r6, [sp, #12]
	rp_hdr.src = src;
1fffc2a8:	e9cd 1200 	strd	r1, r2, [sp]
{
1fffc2ac:	4604      	mov	r4, r0
	rp_hdr.reserved = 0;
1fffc2ae:	2200      	movs	r2, #0
	io = rvdev->shbuf_io;
1fffc2b0:	f8d0 00a4 	ldr.w	r0, [r0, #164]	; 0xa4
	rp_hdr.reserved = 0;
1fffc2b4:	9202      	str	r2, [sp, #8]
	rp_hdr.flags = 0;
1fffc2b6:	f8ad 200e 	strh.w	r2, [sp, #14]
	hdr = RPMSG_LOCATE_HDR(data);
1fffc2ba:	f1a3 0110 	sub.w	r1, r3, #16
1fffc2be:	6803      	ldr	r3, [r0, #0]
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
1fffc2c0:	6887      	ldr	r7, [r0, #8]
	size_t offset = (uintptr_t)virt - (uintptr_t)io->virt;
1fffc2c2:	1ac9      	subs	r1, r1, r3
	status = metal_io_block_write(io, metal_io_virt_to_offset(io, hdr),
1fffc2c4:	42b9      	cmp	r1, r7
1fffc2c6:	bf28      	it	cs
1fffc2c8:	f04f 31ff 	movcs.w	r1, #4294967295	; 0xffffffff
1fffc2cc:	2310      	movs	r3, #16
1fffc2ce:	466a      	mov	r2, sp
	metal_mutex_acquire(&rdev->lock);
1fffc2d0:	f104 0758 	add.w	r7, r4, #88	; 0x58
	status = metal_io_block_write(io, metal_io_virt_to_offset(io, hdr),
1fffc2d4:	f7ff fdae 	bl	1fffbe34 <metal_io_block_write>
	idx = hdr->reserved;
1fffc2d8:	b2ad      	uxth	r5, r5
	__metal_mutex_acquire(mutex);
1fffc2da:	4638      	mov	r0, r7
1fffc2dc:	f7ff ff6a 	bl	1fffc1b4 <__metal_mutex_acquire>
		buff_len = virtqueue_get_buffer_length(rvdev->svq, idx);
1fffc2e0:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
1fffc2e4:	4629      	mov	r1, r5
1fffc2e6:	f7ff fe41 	bl	1fffbf6c <virtqueue_get_buffer_length>
	return rvdev->vdev->role;
1fffc2ea:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
	if (role == RPMSG_REMOTE) {
1fffc2ee:	699b      	ldr	r3, [r3, #24]
1fffc2f0:	2b01      	cmp	r3, #1
		buff_len = virtqueue_get_buffer_length(rvdev->svq, idx);
1fffc2f2:	4602      	mov	r2, r0
	if (role == RPMSG_REMOTE) {
1fffc2f4:	d104      	bne.n	1fffc300 <rpmsg_virtio_send_offchannel_nocopy+0x66>
		return virtqueue_add_consumed_buffer(rvdev->svq, idx, len);
1fffc2f6:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
1fffc2fa:	4629      	mov	r1, r5
1fffc2fc:	f7fd fe38 	bl	1fff9f70 <virtqueue_add_consumed_buffer>
	virtqueue_kick(rvdev->svq);
1fffc300:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
1fffc304:	f7ff fe74 	bl	1fffbff0 <virtqueue_kick>
1fffc308:	4638      	mov	r0, r7
1fffc30a:	f7ff ff51 	bl	1fffc1b0 <k_sem_give>
}
1fffc30e:	4630      	mov	r0, r6
1fffc310:	b005      	add	sp, #20
1fffc312:	bdf0      	pop	{r4, r5, r6, r7, pc}

1fffc314 <rpmsg_virtio_release_rx_buffer>:
{
1fffc314:	b570      	push	{r4, r5, r6, lr}
	idx = (uint16_t)(rp_hdr->reserved & ~RPMSG_BUF_HELD);
1fffc316:	f851 5c08 	ldr.w	r5, [r1, #-8]
{
1fffc31a:	4604      	mov	r4, r0
	metal_mutex_acquire(&rdev->lock);
1fffc31c:	f100 0658 	add.w	r6, r0, #88	; 0x58
1fffc320:	4630      	mov	r0, r6
	idx = (uint16_t)(rp_hdr->reserved & ~RPMSG_BUF_HELD);
1fffc322:	b2ad      	uxth	r5, r5
1fffc324:	f7ff ff46 	bl	1fffc1b4 <__metal_mutex_acquire>
	len = virtqueue_get_buffer_length(rvdev->rvq, idx);
1fffc328:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
1fffc32c:	4629      	mov	r1, r5
1fffc32e:	f7ff fe1d 	bl	1fffbf6c <virtqueue_get_buffer_length>
1fffc332:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
	if (role == RPMSG_REMOTE) {
1fffc336:	699b      	ldr	r3, [r3, #24]
1fffc338:	2b01      	cmp	r3, #1
	len = virtqueue_get_buffer_length(rvdev->rvq, idx);
1fffc33a:	4602      	mov	r2, r0
	if (role == RPMSG_REMOTE) {
1fffc33c:	d104      	bne.n	1fffc348 <rpmsg_virtio_release_rx_buffer+0x34>
		virtqueue_add_consumed_buffer(rvdev->rvq, idx, len);
1fffc33e:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
1fffc342:	4629      	mov	r1, r5
1fffc344:	f7fd fe14 	bl	1fff9f70 <virtqueue_add_consumed_buffer>
	virtqueue_kick(rvdev->rvq);
1fffc348:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
1fffc34c:	f7ff fe50 	bl	1fffbff0 <virtqueue_kick>
1fffc350:	4630      	mov	r0, r6
}
1fffc352:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
1fffc356:	f7ff bf2b 	b.w	1fffc1b0 <k_sem_give>

1fffc35a <rpmsg_virtio_rx_callback>:
{
1fffc35a:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	struct rpmsg_virtio_device *rvdev = vdev->priv;
1fffc35e:	6803      	ldr	r3, [r0, #0]
1fffc360:	6a5e      	ldr	r6, [r3, #36]	; 0x24
	metal_mutex_acquire(&rdev->lock);
1fffc362:	f106 0758 	add.w	r7, r6, #88	; 0x58
1fffc366:	4638      	mov	r0, r7
1fffc368:	f7ff ff24 	bl	1fffc1b4 <__metal_mutex_acquire>
1fffc36c:	f8d6 3098 	ldr.w	r3, [r6, #152]	; 0x98
	if (role == RPMSG_REMOTE) {
1fffc370:	699b      	ldr	r3, [r3, #24]
1fffc372:	2b01      	cmp	r3, #1
1fffc374:	d005      	beq.n	1fffc382 <rpmsg_virtio_rx_callback+0x28>
1fffc376:	4638      	mov	r0, r7
}
1fffc378:	b004      	add	sp, #16
1fffc37a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
1fffc37e:	f7ff bf17 	b.w	1fffc1b0 <k_sem_give>
		    virtqueue_get_available_buffer(rvdev->rvq, idx, len);
1fffc382:	f8d6 009c 	ldr.w	r0, [r6, #156]	; 0x9c
1fffc386:	aa03      	add	r2, sp, #12
1fffc388:	f10d 010a 	add.w	r1, sp, #10
1fffc38c:	f7ff fdf3 	bl	1fffbf76 <virtqueue_get_available_buffer>
1fffc390:	4604      	mov	r4, r0
1fffc392:	4638      	mov	r0, r7
1fffc394:	f7ff ff0c 	bl	1fffc1b0 <k_sem_give>
	while (rp_hdr) {
1fffc398:	b394      	cbz	r4, 1fffc400 <rpmsg_virtio_rx_callback+0xa6>
		rp_hdr->reserved = idx;
1fffc39a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
1fffc39e:	60a3      	str	r3, [r4, #8]
1fffc3a0:	4638      	mov	r0, r7
1fffc3a2:	f7ff ff07 	bl	1fffc1b4 <__metal_mutex_acquire>
			     rpmsg_ns_unbind_cb ns_unbind_cb);

static inline struct rpmsg_endpoint *
rpmsg_get_ept_from_addr(struct rpmsg_device *rdev, uint32_t addr)
{
	return rpmsg_get_endpoint(rdev, NULL, addr, RPMSG_ADDR_ANY);
1fffc3a6:	6862      	ldr	r2, [r4, #4]
1fffc3a8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
1fffc3ac:	2100      	movs	r1, #0
1fffc3ae:	4630      	mov	r0, r6
1fffc3b0:	f7ff fea4 	bl	1fffc0fc <rpmsg_get_endpoint>
1fffc3b4:	4605      	mov	r5, r0
1fffc3b6:	4638      	mov	r0, r7
1fffc3b8:	f7ff fefa 	bl	1fffc1b0 <k_sem_give>
		if (ept) {
1fffc3bc:	b175      	cbz	r5, 1fffc3dc <rpmsg_virtio_rx_callback+0x82>
			if (ept->dest_addr == RPMSG_ADDR_ANY) {
1fffc3be:	6aab      	ldr	r3, [r5, #40]	; 0x28
			status = ept->cb(ept, RPMSG_LOCATE_DATA(rp_hdr),
1fffc3c0:	6be9      	ldr	r1, [r5, #60]	; 0x3c
			if (ept->dest_addr == RPMSG_ADDR_ANY) {
1fffc3c2:	3301      	adds	r3, #1
				ept->dest_addr = rp_hdr->src;
1fffc3c4:	bf04      	itt	eq
1fffc3c6:	6823      	ldreq	r3, [r4, #0]
1fffc3c8:	62ab      	streq	r3, [r5, #40]	; 0x28
			status = ept->cb(ept, RPMSG_LOCATE_DATA(rp_hdr),
1fffc3ca:	6823      	ldr	r3, [r4, #0]
1fffc3cc:	89a2      	ldrh	r2, [r4, #12]
1fffc3ce:	9100      	str	r1, [sp, #0]
1fffc3d0:	f8d5 802c 	ldr.w	r8, [r5, #44]	; 0x2c
1fffc3d4:	f104 0110 	add.w	r1, r4, #16
1fffc3d8:	4628      	mov	r0, r5
1fffc3da:	47c0      	blx	r8
1fffc3dc:	4638      	mov	r0, r7
1fffc3de:	f7ff fee9 	bl	1fffc1b4 <__metal_mutex_acquire>
		if (!(rp_hdr->reserved & RPMSG_BUF_HELD)) {
1fffc3e2:	68a3      	ldr	r3, [r4, #8]
1fffc3e4:	2b00      	cmp	r3, #0
1fffc3e6:	db15      	blt.n	1fffc414 <rpmsg_virtio_rx_callback+0xba>
1fffc3e8:	f8d6 3098 	ldr.w	r3, [r6, #152]	; 0x98
	if (role == RPMSG_REMOTE) {
1fffc3ec:	699b      	ldr	r3, [r3, #24]
1fffc3ee:	2b01      	cmp	r3, #1
1fffc3f0:	d009      	beq.n	1fffc406 <rpmsg_virtio_rx_callback+0xac>
			virtqueue_kick(rvdev->rvq);
1fffc3f2:	f8d6 009c 	ldr.w	r0, [r6, #156]	; 0x9c
1fffc3f6:	f7ff fdfb 	bl	1fffbff0 <virtqueue_kick>
1fffc3fa:	4638      	mov	r0, r7
1fffc3fc:	f7ff fed8 	bl	1fffc1b0 <k_sem_give>
}
1fffc400:	b004      	add	sp, #16
1fffc402:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		virtqueue_add_consumed_buffer(rvdev->rvq, idx, len);
1fffc406:	9a03      	ldr	r2, [sp, #12]
1fffc408:	f8bd 100a 	ldrh.w	r1, [sp, #10]
1fffc40c:	f8d6 009c 	ldr.w	r0, [r6, #156]	; 0x9c
1fffc410:	f7fd fdae 	bl	1fff9f70 <virtqueue_add_consumed_buffer>
1fffc414:	f8d6 3098 	ldr.w	r3, [r6, #152]	; 0x98
	if (role == RPMSG_REMOTE) {
1fffc418:	699b      	ldr	r3, [r3, #24]
1fffc41a:	2b01      	cmp	r3, #1
1fffc41c:	d1e9      	bne.n	1fffc3f2 <rpmsg_virtio_rx_callback+0x98>
		    virtqueue_get_available_buffer(rvdev->rvq, idx, len);
1fffc41e:	f8d6 009c 	ldr.w	r0, [r6, #156]	; 0x9c
1fffc422:	aa03      	add	r2, sp, #12
1fffc424:	f10d 010a 	add.w	r1, sp, #10
1fffc428:	f7ff fda5 	bl	1fffbf76 <virtqueue_get_available_buffer>
		if (!rp_hdr) {
1fffc42c:	4604      	mov	r4, r0
1fffc42e:	2800      	cmp	r0, #0
1fffc430:	d0df      	beq.n	1fffc3f2 <rpmsg_virtio_rx_callback+0x98>
1fffc432:	4638      	mov	r0, r7
1fffc434:	f7ff febc 	bl	1fffc1b0 <k_sem_give>
	while (rp_hdr) {
1fffc438:	e7af      	b.n	1fffc39a <rpmsg_virtio_rx_callback+0x40>

1fffc43a <rpmsg_virtio_get_tx_payload_buffer>:
{
1fffc43a:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
1fffc43e:	4605      	mov	r5, r0
1fffc440:	f8d0 0098 	ldr.w	r0, [r0, #152]	; 0x98
	return rvdev->vdev->func->get_status(rvdev->vdev);
1fffc444:	6a03      	ldr	r3, [r0, #32]
1fffc446:	681b      	ldr	r3, [r3, #0]
1fffc448:	460f      	mov	r7, r1
1fffc44a:	4616      	mov	r6, r2
1fffc44c:	4798      	blx	r3
	if (!(status & VIRTIO_CONFIG_STATUS_DRIVER_OK))
1fffc44e:	0743      	lsls	r3, r0, #29
1fffc450:	d403      	bmi.n	1fffc45a <rpmsg_virtio_get_tx_payload_buffer+0x20>
		return NULL;
1fffc452:	2000      	movs	r0, #0
}
1fffc454:	b003      	add	sp, #12
1fffc456:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		tick_count = RPMSG_TICK_COUNT / RPMSG_TICKS_PER_INTERVAL;
1fffc45a:	2e00      	cmp	r6, #0
1fffc45c:	f643 2398 	movw	r3, #15000	; 0x3a98
1fffc460:	bf18      	it	ne
1fffc462:	461e      	movne	r6, r3
		metal_mutex_acquire(&rdev->lock);
1fffc464:	f105 0858 	add.w	r8, r5, #88	; 0x58
	node = metal_list_first(&rvdev->reclaimer);
1fffc468:	f105 09ac 	add.w	r9, r5, #172	; 0xac
1fffc46c:	4640      	mov	r0, r8
1fffc46e:	f7ff fea1 	bl	1fffc1b4 <__metal_mutex_acquire>
	return list->next == list;
1fffc472:	f8d5 40ac 	ldr.w	r4, [r5, #172]	; 0xac
	return rvdev->vdev->role;
1fffc476:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
}

static inline struct metal_list *metal_list_first(struct metal_list *list)
{
	return metal_list_is_empty(list) ? NULL : list->next;
1fffc47a:	454c      	cmp	r4, r9
1fffc47c:	699b      	ldr	r3, [r3, #24]
1fffc47e:	d01e      	beq.n	1fffc4be <rpmsg_virtio_get_tx_payload_buffer+0x84>
	if (node) {
1fffc480:	b1ec      	cbz	r4, 1fffc4be <rpmsg_virtio_get_tx_payload_buffer+0x84>
	node->next->prev = node->prev;
1fffc482:	e9d4 1200 	ldrd	r1, r2, [r4]
1fffc486:	604a      	str	r2, [r1, #4]
	node->prev->next = node->next;
1fffc488:	6821      	ldr	r1, [r4, #0]
1fffc48a:	6011      	str	r1, [r2, #0]
		if (role == RPMSG_REMOTE) {
1fffc48c:	2b01      	cmp	r3, #1
	node->next = node;
1fffc48e:	e9c4 4400 	strd	r4, r4, [r4]
1fffc492:	d00b      	beq.n	1fffc4ac <rpmsg_virtio_get_tx_payload_buffer+0x72>
1fffc494:	4640      	mov	r0, r8
1fffc496:	f7ff fe8b 	bl	1fffc1b0 <k_sem_give>
	rp_hdr->reserved = idx;
1fffc49a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
1fffc49e:	60a3      	str	r3, [r4, #8]
	*len -= sizeof(struct rpmsg_hdr);
1fffc4a0:	683b      	ldr	r3, [r7, #0]
1fffc4a2:	3b10      	subs	r3, #16
1fffc4a4:	603b      	str	r3, [r7, #0]
	return RPMSG_LOCATE_DATA(rp_hdr);
1fffc4a6:	f104 0010 	add.w	r0, r4, #16
1fffc4aa:	e7d3      	b.n	1fffc454 <rpmsg_virtio_get_tx_payload_buffer+0x1a>
			*idx = r_desc->idx;
1fffc4ac:	8921      	ldrh	r1, [r4, #8]
			*len = virtqueue_get_buffer_length(rvdev->svq, *idx);
1fffc4ae:	f8d5 00a0 	ldr.w	r0, [r5, #160]	; 0xa0
			*idx = r_desc->idx;
1fffc4b2:	f8ad 1006 	strh.w	r1, [sp, #6]
			*len = virtqueue_get_buffer_length(rvdev->svq, *idx);
1fffc4b6:	f7ff fd59 	bl	1fffbf6c <virtqueue_get_buffer_length>
1fffc4ba:	6038      	str	r0, [r7, #0]
1fffc4bc:	e7ea      	b.n	1fffc494 <rpmsg_virtio_get_tx_payload_buffer+0x5a>
	} else if (role == RPMSG_REMOTE) {
1fffc4be:	2b01      	cmp	r3, #1
1fffc4c0:	d00a      	beq.n	1fffc4d8 <rpmsg_virtio_get_tx_payload_buffer+0x9e>
1fffc4c2:	4640      	mov	r0, r8
1fffc4c4:	f7ff fe74 	bl	1fffc1b0 <k_sem_give>
		if (rp_hdr || !tick_count)
1fffc4c8:	2e00      	cmp	r6, #0
1fffc4ca:	d0c2      	beq.n	1fffc452 <rpmsg_virtio_get_tx_payload_buffer+0x18>
	return z_impl_k_sleep(timeout);
1fffc4cc:	200a      	movs	r0, #10
1fffc4ce:	2100      	movs	r1, #0
1fffc4d0:	f7fe fbc4 	bl	1fffac5c <z_impl_k_sleep>
		tick_count--;
1fffc4d4:	3e01      	subs	r6, #1
		metal_mutex_acquire(&rdev->lock);
1fffc4d6:	e7c9      	b.n	1fffc46c <rpmsg_virtio_get_tx_payload_buffer+0x32>
		data = virtqueue_get_available_buffer(rvdev->svq, idx, len);
1fffc4d8:	f8d5 00a0 	ldr.w	r0, [r5, #160]	; 0xa0
1fffc4dc:	463a      	mov	r2, r7
1fffc4de:	f10d 0106 	add.w	r1, sp, #6
1fffc4e2:	f7ff fd48 	bl	1fffbf76 <virtqueue_get_available_buffer>
1fffc4e6:	4604      	mov	r4, r0
1fffc4e8:	4640      	mov	r0, r8
1fffc4ea:	f7ff fe61 	bl	1fffc1b0 <k_sem_give>
		if (rp_hdr || !tick_count)
1fffc4ee:	2c00      	cmp	r4, #0
1fffc4f0:	d0ea      	beq.n	1fffc4c8 <rpmsg_virtio_get_tx_payload_buffer+0x8e>
1fffc4f2:	e7d2      	b.n	1fffc49a <rpmsg_virtio_get_tx_payload_buffer+0x60>

1fffc4f4 <rpmsg_virtio_init_shm_pool>:
	if (!shpool || !shb || size == 0)
1fffc4f4:	b120      	cbz	r0, 1fffc500 <rpmsg_virtio_init_shm_pool+0xc>
1fffc4f6:	b119      	cbz	r1, 1fffc500 <rpmsg_virtio_init_shm_pool+0xc>
1fffc4f8:	b112      	cbz	r2, 1fffc500 <rpmsg_virtio_init_shm_pool+0xc>
	shpool->avail = size;
1fffc4fa:	e9c0 2201 	strd	r2, r2, [r0, #4]
	shpool->base = shb;
1fffc4fe:	6001      	str	r1, [r0, #0]
}
1fffc500:	4770      	bx	lr

1fffc502 <rpmsg_init_vdev>:
{
1fffc502:	b513      	push	{r0, r1, r4, lr}
	return rpmsg_init_vdev_with_config(rvdev, vdev, ns_bind_cb, shm_io,
1fffc504:	2400      	movs	r4, #0
1fffc506:	9401      	str	r4, [sp, #4]
1fffc508:	9c04      	ldr	r4, [sp, #16]
1fffc50a:	9400      	str	r4, [sp, #0]
1fffc50c:	f7fd fe30 	bl	1fffa170 <rpmsg_init_vdev_with_config>
}
1fffc510:	b002      	add	sp, #8
1fffc512:	bd10      	pop	{r4, pc}

1fffc514 <rpmsg_deinit_vdev>:

void rpmsg_deinit_vdev(struct rpmsg_virtio_device *rvdev)
{
1fffc514:	b510      	push	{r4, lr}
	struct metal_list *node;
	struct rpmsg_device *rdev;
	struct rpmsg_endpoint *ept;

	if (rvdev) {
1fffc516:	4604      	mov	r4, r0
1fffc518:	b918      	cbnz	r0, 1fffc522 <rpmsg_deinit_vdev+0xe>
		rvdev->rvq = 0;
		rvdev->svq = 0;

		metal_mutex_deinit(&rdev->lock);
	}
}
1fffc51a:	bd10      	pop	{r4, pc}
			rpmsg_destroy_ept(ept);
1fffc51c:	3834      	subs	r0, #52	; 0x34
1fffc51e:	f7ff fe28 	bl	1fffc172 <rpmsg_destroy_ept>
	return list->next == list;
1fffc522:	6820      	ldr	r0, [r4, #0]
		while (!metal_list_is_empty(&rdev->endpoints)) {
1fffc524:	4284      	cmp	r4, r0
1fffc526:	d1f9      	bne.n	1fffc51c <rpmsg_deinit_vdev+0x8>
		rvdev->rvq = 0;
1fffc528:	2300      	movs	r3, #0
		rvdev->svq = 0;
1fffc52a:	e9c4 3327 	strd	r3, r3, [r4, #156]	; 0x9c
}
1fffc52e:	e7f4      	b.n	1fffc51a <rpmsg_deinit_vdev+0x6>

1fffc530 <rproc_virtio_virtqueue_notify>:
{
1fffc530:	b410      	push	{r4}
	vdev = vq->vq_dev;
1fffc532:	6803      	ldr	r3, [r0, #0]
	unsigned int vq_id = vq->vq_queue_index;
1fffc534:	8901      	ldrh	r1, [r0, #8]
	rpvdev->notify(rpvdev->priv, vring_info->notifyid);
1fffc536:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1fffc538:	f853 4c04 	ldr.w	r4, [r3, #-4]
1fffc53c:	2018      	movs	r0, #24
1fffc53e:	fb00 2201 	mla	r2, r0, r1, r2
1fffc542:	f853 0c10 	ldr.w	r0, [r3, #-16]
1fffc546:	6911      	ldr	r1, [r2, #16]
1fffc548:	4623      	mov	r3, r4
}
1fffc54a:	bc10      	pop	{r4}
	rpvdev->notify(rpvdev->priv, vring_info->notifyid);
1fffc54c:	4718      	bx	r3

1fffc54e <rproc_virtio_read_config>:
{
1fffc54e:	b4f0      	push	{r4, r5, r6, r7}
	vdev_rsc = rpvdev->vdev_rsc;
1fffc550:	f850 4c0c 	ldr.w	r4, [r0, #-12]
	if (offset + length <= vdev_rsc->config_len)
1fffc554:	6967      	ldr	r7, [r4, #20]
{
1fffc556:	4605      	mov	r5, r0
	if (offset + length <= vdev_rsc->config_len)
1fffc558:	1858      	adds	r0, r3, r1
1fffc55a:	42b8      	cmp	r0, r7
1fffc55c:	d811      	bhi.n	1fffc582 <rproc_virtio_read_config+0x34>
	io = rpvdev->vdev_rsc_io;
1fffc55e:	f855 0c08 	ldr.w	r0, [r5, #-8]
				metal_io_virt_to_offset(io, config + offset),
1fffc562:	6aad      	ldr	r5, [r5, #40]	; 0x28
1fffc564:	2614      	movs	r6, #20
1fffc566:	fb06 1105 	mla	r1, r6, r5, r1
1fffc56a:	311c      	adds	r1, #28
1fffc56c:	4421      	add	r1, r4
1fffc56e:	6804      	ldr	r4, [r0, #0]
1fffc570:	1b09      	subs	r1, r1, r4
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
1fffc572:	6884      	ldr	r4, [r0, #8]
		metal_io_block_read(io,
1fffc574:	42a1      	cmp	r1, r4
1fffc576:	bf28      	it	cs
1fffc578:	f04f 31ff 	movcs.w	r1, #4294967295	; 0xffffffff
}
1fffc57c:	bcf0      	pop	{r4, r5, r6, r7}
		metal_io_block_read(io,
1fffc57e:	f7ff bc20 	b.w	1fffbdc2 <metal_io_block_read>
}
1fffc582:	bcf0      	pop	{r4, r5, r6, r7}
1fffc584:	4770      	bx	lr

1fffc586 <metal_io_read.constprop.0>:
 *			4, or 8, and a compile time constant for this function
 *			to inline cleanly.
 * @return	Value.
 */
static inline uint64_t
metal_io_read(struct metal_io_region *io, unsigned long offset,
1fffc586:	b430      	push	{r4, r5}
	return (io->virt != METAL_BAD_VA && offset < io->size
1fffc588:	6805      	ldr	r5, [r0, #0]
	      memory_order order, int width)
{
	void *ptr = metal_io_virt(io, offset);

	if (io->ops.read)
1fffc58a:	6984      	ldr	r4, [r0, #24]
metal_io_read(struct metal_io_region *io, unsigned long offset,
1fffc58c:	4613      	mov	r3, r2
		: NULL);
1fffc58e:	1c6a      	adds	r2, r5, #1
1fffc590:	d104      	bne.n	1fffc59c <metal_io_read.constprop.0+0x16>
	if (io->ops.read)
1fffc592:	b93c      	cbnz	r4, 1fffc5a4 <metal_io_read.constprop.0+0x1e>
	else if (ptr && sizeof(atomic_ullong) == width)
		return atomic_load_explicit((atomic_ullong *)ptr, order);
#endif
	metal_assert(0);
	return 0; /* quiet compiler */
}
1fffc594:	4620      	mov	r0, r4
1fffc596:	2100      	movs	r1, #0
1fffc598:	bc30      	pop	{r4, r5}
1fffc59a:	4770      	bx	lr
	return (io->virt != METAL_BAD_VA && offset < io->size
1fffc59c:	6882      	ldr	r2, [r0, #8]
1fffc59e:	4291      	cmp	r1, r2
1fffc5a0:	d2f7      	bcs.n	1fffc592 <metal_io_read.constprop.0+0xc>
	if (io->ops.read)
1fffc5a2:	b11c      	cbz	r4, 1fffc5ac <metal_io_read.constprop.0+0x26>
		return (*io->ops.read)(io, offset, order, width);
1fffc5a4:	46a4      	mov	ip, r4
1fffc5a6:	2205      	movs	r2, #5
}
1fffc5a8:	bc30      	pop	{r4, r5}
		return (*io->ops.read)(io, offset, order, width);
1fffc5aa:	4760      	bx	ip
	else if (ptr && sizeof(atomic_uchar) == width)
1fffc5ac:	186a      	adds	r2, r5, r1
1fffc5ae:	d010      	beq.n	1fffc5d2 <metal_io_read.constprop.0+0x4c>
1fffc5b0:	2b01      	cmp	r3, #1
1fffc5b2:	d106      	bne.n	1fffc5c2 <metal_io_read.constprop.0+0x3c>
		return atomic_load_explicit((atomic_uchar *)ptr, order);
1fffc5b4:	f3bf 8f5b 	dmb	ish
1fffc5b8:	5c6c      	ldrb	r4, [r5, r1]
1fffc5ba:	f3bf 8f5b 	dmb	ish
1fffc5be:	b2e4      	uxtb	r4, r4
1fffc5c0:	e7e8      	b.n	1fffc594 <metal_io_read.constprop.0+0xe>
	else if (ptr && sizeof(atomic_uint) == width)
1fffc5c2:	2b04      	cmp	r3, #4
1fffc5c4:	d1e6      	bne.n	1fffc594 <metal_io_read.constprop.0+0xe>
		return atomic_load_explicit((atomic_uint *)ptr, order);
1fffc5c6:	f3bf 8f5b 	dmb	ish
1fffc5ca:	586c      	ldr	r4, [r5, r1]
1fffc5cc:	f3bf 8f5b 	dmb	ish
1fffc5d0:	e7e0      	b.n	1fffc594 <metal_io_read.constprop.0+0xe>
	return 0; /* quiet compiler */
1fffc5d2:	4614      	mov	r4, r2
1fffc5d4:	e7de      	b.n	1fffc594 <metal_io_read.constprop.0+0xe>

1fffc5d6 <rproc_virtio_get_status>:
{
1fffc5d6:	b508      	push	{r3, lr}
	rpvdev = metal_container_of(vdev, struct remoteproc_virtio, vdev);
1fffc5d8:	f1a0 0310 	sub.w	r3, r0, #16
	io = rpvdev->vdev_rsc_io;
1fffc5dc:	f850 0c08 	ldr.w	r0, [r0, #-8]
	status = metal_io_read8(io,
1fffc5e0:	6859      	ldr	r1, [r3, #4]
	size_t offset = (uintptr_t)virt - (uintptr_t)io->virt;
1fffc5e2:	6803      	ldr	r3, [r0, #0]
1fffc5e4:	3118      	adds	r1, #24
1fffc5e6:	1ac9      	subs	r1, r1, r3
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
1fffc5e8:	6883      	ldr	r3, [r0, #8]
1fffc5ea:	2201      	movs	r2, #1
1fffc5ec:	4299      	cmp	r1, r3
1fffc5ee:	bf28      	it	cs
1fffc5f0:	f04f 31ff 	movcs.w	r1, #4294967295	; 0xffffffff
1fffc5f4:	f7ff ffc7 	bl	1fffc586 <metal_io_read.constprop.0>
}
1fffc5f8:	b2c0      	uxtb	r0, r0
1fffc5fa:	bd08      	pop	{r3, pc}

1fffc5fc <rproc_virtio_get_features>:
{
1fffc5fc:	b538      	push	{r3, r4, r5, lr}
	rpvdev = metal_container_of(vdev, struct remoteproc_virtio, vdev);
1fffc5fe:	f1a0 0410 	sub.w	r4, r0, #16
	io = rpvdev->vdev_rsc_io;
1fffc602:	f850 0c08 	ldr.w	r0, [r0, #-8]
	gfeatures = metal_io_read32(io,
1fffc606:	6861      	ldr	r1, [r4, #4]
	size_t offset = (uintptr_t)virt - (uintptr_t)io->virt;
1fffc608:	6803      	ldr	r3, [r0, #0]
1fffc60a:	3110      	adds	r1, #16
1fffc60c:	1ac9      	subs	r1, r1, r3
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
1fffc60e:	6883      	ldr	r3, [r0, #8]
1fffc610:	2204      	movs	r2, #4
1fffc612:	4299      	cmp	r1, r3
1fffc614:	bf28      	it	cs
1fffc616:	f04f 31ff 	movcs.w	r1, #4294967295	; 0xffffffff
1fffc61a:	f7ff ffb4 	bl	1fffc586 <metal_io_read.constprop.0>
1fffc61e:	4605      	mov	r5, r0
	features = metal_io_read32(io,
1fffc620:	e9d4 1001 	ldrd	r1, r0, [r4, #4]
	size_t offset = (uintptr_t)virt - (uintptr_t)io->virt;
1fffc624:	6803      	ldr	r3, [r0, #0]
1fffc626:	310c      	adds	r1, #12
1fffc628:	1ac9      	subs	r1, r1, r3
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
1fffc62a:	6883      	ldr	r3, [r0, #8]
1fffc62c:	2204      	movs	r2, #4
1fffc62e:	4299      	cmp	r1, r3
1fffc630:	bf28      	it	cs
1fffc632:	f04f 31ff 	movcs.w	r1, #4294967295	; 0xffffffff
1fffc636:	f7ff ffa6 	bl	1fffc586 <metal_io_read.constprop.0>
}
1fffc63a:	4028      	ands	r0, r5
1fffc63c:	bd38      	pop	{r3, r4, r5, pc}

1fffc63e <rproc_virtio_remove_vdev>:

void rproc_virtio_remove_vdev(struct virtio_device *vdev)
{
1fffc63e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct remoteproc_virtio *rpvdev;
	unsigned int i;

	if (!vdev)
1fffc640:	4604      	mov	r4, r0
1fffc642:	b1b8      	cbz	r0, 1fffc674 <rproc_virtio_remove_vdev+0x36>
		return;
	rpvdev = metal_container_of(vdev, struct remoteproc_virtio, vdev);
1fffc644:	f1a0 0610 	sub.w	r6, r0, #16
	for (i = 0; i < vdev->vrings_num; i++) {
1fffc648:	2500      	movs	r5, #0
		struct virtqueue *vq;

		vq = vdev->vrings_info[i].vq;
1fffc64a:	2718      	movs	r7, #24
	for (i = 0; i < vdev->vrings_num; i++) {
1fffc64c:	e9d4 300a 	ldrd	r3, r0, [r4, #40]	; 0x28
1fffc650:	42ab      	cmp	r3, r5
1fffc652:	d807      	bhi.n	1fffc664 <rproc_virtio_remove_vdev+0x26>
		if (vq)
			metal_free_memory(vq);
	}
	if (vdev->vrings_info)
1fffc654:	b108      	cbz	r0, 1fffc65a <rproc_virtio_remove_vdev+0x1c>
1fffc656:	f000 f9b8 	bl	1fffc9ca <k_free>
1fffc65a:	4630      	mov	r0, r6
		metal_free_memory(vdev->vrings_info);
	metal_free_memory(rpvdev);
}
1fffc65c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
1fffc660:	f000 b9b3 	b.w	1fffc9ca <k_free>
		vq = vdev->vrings_info[i].vq;
1fffc664:	fb07 f305 	mul.w	r3, r7, r5
1fffc668:	58c0      	ldr	r0, [r0, r3]
		if (vq)
1fffc66a:	b108      	cbz	r0, 1fffc670 <rproc_virtio_remove_vdev+0x32>
1fffc66c:	f000 f9ad 	bl	1fffc9ca <k_free>
	for (i = 0; i < vdev->vrings_num; i++) {
1fffc670:	3501      	adds	r5, #1
1fffc672:	e7eb      	b.n	1fffc64c <rproc_virtio_remove_vdev+0xe>
}
1fffc674:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

1fffc676 <rproc_virtio_init_vring>:

int rproc_virtio_init_vring(struct virtio_device *vdev, unsigned int index,
			    unsigned int notifyid, void *va,
			    struct metal_io_region *io,
			    unsigned int num_descs, unsigned int align)
{
1fffc676:	b530      	push	{r4, r5, lr}
	struct virtio_vring_info *vring_info;
	unsigned int num_vrings;

	num_vrings = vdev->vrings_num;
	if ((index >= num_vrings) || (num_descs > RPROC_MAX_VRING_DESC))
1fffc678:	6a85      	ldr	r5, [r0, #40]	; 0x28
{
1fffc67a:	9c04      	ldr	r4, [sp, #16]
	if ((index >= num_vrings) || (num_descs > RPROC_MAX_VRING_DESC))
1fffc67c:	428d      	cmp	r5, r1
1fffc67e:	d90f      	bls.n	1fffc6a0 <rproc_virtio_init_vring+0x2a>
1fffc680:	f5b4 3f80 	cmp.w	r4, #65536	; 0x10000
1fffc684:	d20c      	bcs.n	1fffc6a0 <rproc_virtio_init_vring+0x2a>
		return -RPROC_EINVAL;
	vring_info = &vdev->vrings_info[index];
1fffc686:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
1fffc688:	2518      	movs	r5, #24
1fffc68a:	fb05 0101 	mla	r1, r5, r1, r0
	vring_info->io = io;
1fffc68e:	9803      	ldr	r0, [sp, #12]
	vring_info->notifyid = notifyid;
	vring_info->info.vaddr = va;
1fffc690:	604b      	str	r3, [r1, #4]
	vring_info->info.num_descs = num_descs;
	vring_info->info.align = align;
1fffc692:	9b05      	ldr	r3, [sp, #20]
	vring_info->info.num_descs = num_descs;
1fffc694:	818c      	strh	r4, [r1, #12]
	vring_info->notifyid = notifyid;
1fffc696:	e9c1 2004 	strd	r2, r0, [r1, #16]
	vring_info->info.align = align;
1fffc69a:	608b      	str	r3, [r1, #8]

	return 0;
1fffc69c:	2000      	movs	r0, #0
}
1fffc69e:	bd30      	pop	{r4, r5, pc}
		return -RPROC_EINVAL;
1fffc6a0:	f06f 0001 	mvn.w	r0, #1
1fffc6a4:	e7fb      	b.n	1fffc69e <rproc_virtio_init_vring+0x28>

1fffc6a6 <rproc_virtio_notified>:

int rproc_virtio_notified(struct virtio_device *vdev, uint32_t notifyid)
{
1fffc6a6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
1fffc6aa:	460d      	mov	r5, r1
	unsigned int num_vrings, i;
	struct virtio_vring_info *vring_info;
	struct virtqueue *vq;

	if (!vdev)
1fffc6ac:	4604      	mov	r4, r0
1fffc6ae:	b1c8      	cbz	r0, 1fffc6e4 <rproc_virtio_notified+0x3e>
		return -RPROC_EINVAL;
	/* We do nothing for vdev notification in this implementation */
	if (vdev->notifyid == notifyid)
1fffc6b0:	6803      	ldr	r3, [r0, #0]
1fffc6b2:	428b      	cmp	r3, r1
1fffc6b4:	d102      	bne.n	1fffc6bc <rproc_virtio_notified+0x16>
		return 0;
1fffc6b6:	2000      	movs	r0, #0
			vq = vring_info->vq;
			virtqueue_notification(vq);
		}
	}
	return 0;
}
1fffc6b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	num_vrings = vdev->vrings_num;
1fffc6bc:	6a87      	ldr	r7, [r0, #40]	; 0x28
	for (i = 0; i < num_vrings; i++) {
1fffc6be:	2600      	movs	r6, #0
		vring_info = &vdev->vrings_info[i];
1fffc6c0:	f04f 0818 	mov.w	r8, #24
	for (i = 0; i < num_vrings; i++) {
1fffc6c4:	42be      	cmp	r6, r7
1fffc6c6:	d0f6      	beq.n	1fffc6b6 <rproc_virtio_notified+0x10>
		vring_info = &vdev->vrings_info[i];
1fffc6c8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
1fffc6ca:	fb08 f306 	mul.w	r3, r8, r6
1fffc6ce:	18d1      	adds	r1, r2, r3
		if (vring_info->notifyid == notifyid ||
1fffc6d0:	6909      	ldr	r1, [r1, #16]
1fffc6d2:	42a9      	cmp	r1, r5
1fffc6d4:	d001      	beq.n	1fffc6da <rproc_virtio_notified+0x34>
1fffc6d6:	1c69      	adds	r1, r5, #1
1fffc6d8:	d102      	bne.n	1fffc6e0 <rproc_virtio_notified+0x3a>
			virtqueue_notification(vq);
1fffc6da:	58d0      	ldr	r0, [r2, r3]
1fffc6dc:	f7ff fcb0 	bl	1fffc040 <virtqueue_notification>
	for (i = 0; i < num_vrings; i++) {
1fffc6e0:	3601      	adds	r6, #1
1fffc6e2:	e7ef      	b.n	1fffc6c4 <rproc_virtio_notified+0x1e>
		return -RPROC_EINVAL;
1fffc6e4:	f06f 0001 	mvn.w	r0, #1
1fffc6e8:	e7e6      	b.n	1fffc6b8 <rproc_virtio_notified+0x12>

1fffc6ea <rproc_virtio_wait_remote_ready>:

void rproc_virtio_wait_remote_ready(struct virtio_device *vdev)
{
1fffc6ea:	b510      	push	{r4, lr}
1fffc6ec:	4604      	mov	r4, r0
	 */
	if (vdev->role == VIRTIO_DEV_DRIVER)
		return;
#endif
	while (1) {
		status = rproc_virtio_get_status(vdev);
1fffc6ee:	4620      	mov	r0, r4
1fffc6f0:	f7ff ff71 	bl	1fffc5d6 <rproc_virtio_get_status>
		if (status & VIRTIO_CONFIG_STATUS_DRIVER_OK)
1fffc6f4:	0743      	lsls	r3, r0, #29
1fffc6f6:	d5fa      	bpl.n	1fffc6ee <rproc_virtio_wait_remote_ready+0x4>
			return;
		metal_cpu_yield();
	}
}
1fffc6f8:	bd10      	pop	{r4, pc}

1fffc6fa <z_device_state_init>:

	while (dev < __device_end) {
		z_object_init(dev);
		++dev;
	}
}
1fffc6fa:	4770      	bx	lr

1fffc6fc <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
1fffc6fc:	b140      	cbz	r0, 1fffc710 <z_device_is_ready+0x14>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
1fffc6fe:	68c3      	ldr	r3, [r0, #12]
1fffc700:	7858      	ldrb	r0, [r3, #1]
1fffc702:	f010 0001 	ands.w	r0, r0, #1
1fffc706:	bf1e      	ittt	ne
1fffc708:	7818      	ldrbne	r0, [r3, #0]
1fffc70a:	fab0 f080 	clzne	r0, r0
1fffc70e:	0940      	lsrne	r0, r0, #5
}
1fffc710:	4770      	bx	lr

1fffc712 <arch_system_halt>:
	__asm__ volatile(
1fffc712:	f04f 0210 	mov.w	r2, #16
1fffc716:	f3ef 8311 	mrs	r3, BASEPRI
1fffc71a:	f382 8812 	msr	BASEPRI_MAX, r2
1fffc71e:	f3bf 8f6f 	isb	sy
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
1fffc722:	e7fe      	b.n	1fffc722 <arch_system_halt+0x10>

1fffc724 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
1fffc724:	b508      	push	{r3, lr}
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
1fffc726:	f7ff fff4 	bl	1fffc712 <arch_system_halt>

1fffc72a <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
1fffc72a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1fffc72c:	4605      	mov	r5, r0
1fffc72e:	460e      	mov	r6, r1
1fffc730:	f04f 0310 	mov.w	r3, #16
1fffc734:	f3ef 8711 	mrs	r7, BASEPRI
1fffc738:	f383 8812 	msr	BASEPRI_MAX, r3
1fffc73c:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
1fffc740:	f7fe faa4 	bl	1fffac8c <z_impl_z_current_get>

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
#endif

	k_sys_fatal_error_handler(reason, esf);
1fffc744:	4631      	mov	r1, r6
1fffc746:	4604      	mov	r4, r0
1fffc748:	4628      	mov	r0, r5
1fffc74a:	f7ff ffeb 	bl	1fffc724 <k_sys_fatal_error_handler>
	__asm__ volatile(
1fffc74e:	f387 8811 	msr	BASEPRI, r7
1fffc752:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
1fffc756:	4620      	mov	r0, r4
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
1fffc758:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
1fffc75c:	f7fc bfc2 	b.w	1fff96e4 <z_impl_k_thread_abort>

1fffc760 <z_early_memset>:
	(void) memset(dst, c, n);
1fffc760:	f7fe bf18 	b.w	1fffb594 <memset>

1fffc764 <z_early_memcpy>:
	(void) memcpy(dst, src, n);
1fffc764:	f7fe bf0b 	b.w	1fffb57e <memcpy>

1fffc768 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
1fffc768:	b508      	push	{r3, lr}
	__asm__ volatile(
1fffc76a:	f04f 0210 	mov.w	r2, #16
1fffc76e:	f3ef 8311 	mrs	r3, BASEPRI
1fffc772:	f382 8812 	msr	BASEPRI_MAX, r2
1fffc776:	f3bf 8f6f 	isb	sy
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
1fffc77a:	f7fc fd5d 	bl	1fff9238 <arch_cpu_idle>
1fffc77e:	e7f4      	b.n	1fffc76a <idle+0x2>

1fffc780 <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
1fffc780:	b13a      	cbz	r2, 1fffc792 <z_impl_k_sem_init+0x12>
1fffc782:	428a      	cmp	r2, r1
1fffc784:	d305      	bcc.n	1fffc792 <z_impl_k_sem_init+0x12>
	sem->limit = limit;
1fffc786:	e9c0 1202 	strd	r1, r2, [r0, #8]
	list->tail = (sys_dnode_t *)list;
1fffc78a:	e9c0 0000 	strd	r0, r0, [r0]
	return 0;
1fffc78e:	2000      	movs	r0, #0
1fffc790:	4770      	bx	lr
		return -EINVAL;
1fffc792:	f06f 0015 	mvn.w	r0, #21
}
1fffc796:	4770      	bx	lr

1fffc798 <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
1fffc798:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
1fffc79c:	6013      	str	r3, [r2, #0]
	next->prev = prev;
1fffc79e:	605a      	str	r2, [r3, #4]
	node->next = NULL;
1fffc7a0:	2300      	movs	r3, #0
	node->prev = NULL;
1fffc7a2:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dnode_init(node);
}
1fffc7a6:	4770      	bx	lr

1fffc7a8 <unpend_thread_no_timeout>:
{
1fffc7a8:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
1fffc7aa:	f7ff fff5 	bl	1fffc798 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
1fffc7ae:	7b43      	ldrb	r3, [r0, #13]
1fffc7b0:	f023 0302 	bic.w	r3, r3, #2
1fffc7b4:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
1fffc7b6:	2300      	movs	r3, #0
1fffc7b8:	6083      	str	r3, [r0, #8]
}
1fffc7ba:	bd08      	pop	{r3, pc}

1fffc7bc <add_to_waitq_locked>:
{
1fffc7bc:	b538      	push	{r3, r4, r5, lr}
1fffc7be:	4604      	mov	r4, r0
1fffc7c0:	460d      	mov	r5, r1
	unready_thread(thread);
1fffc7c2:	f7fe f889 	bl	1fffa8d8 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
1fffc7c6:	7b63      	ldrb	r3, [r4, #13]
1fffc7c8:	f043 0302 	orr.w	r3, r3, #2
1fffc7cc:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
1fffc7ce:	b1e5      	cbz	r5, 1fffc80a <add_to_waitq_locked+0x4e>
		thread->base.pended_on = wait_q;
1fffc7d0:	60a5      	str	r5, [r4, #8]
	return list->head == list;
1fffc7d2:	682b      	ldr	r3, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fffc7d4:	429d      	cmp	r5, r3
1fffc7d6:	d109      	bne.n	1fffc7ec <add_to_waitq_locked+0x30>
	sys_dnode_t *const tail = list->tail;
1fffc7d8:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
1fffc7da:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
1fffc7de:	601c      	str	r4, [r3, #0]
	list->tail = node;
1fffc7e0:	606c      	str	r4, [r5, #4]
}
1fffc7e2:	e012      	b.n	1fffc80a <add_to_waitq_locked+0x4e>
	return (node == list->tail) ? NULL : node->next;
1fffc7e4:	686a      	ldr	r2, [r5, #4]
1fffc7e6:	4293      	cmp	r3, r2
1fffc7e8:	d0f6      	beq.n	1fffc7d8 <add_to_waitq_locked+0x1c>
1fffc7ea:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
1fffc7ec:	2b00      	cmp	r3, #0
1fffc7ee:	d0f3      	beq.n	1fffc7d8 <add_to_waitq_locked+0x1c>
	int32_t b1 = thread_1->base.prio;
1fffc7f0:	f994 200e 	ldrsb.w	r2, [r4, #14]
	int32_t b2 = thread_2->base.prio;
1fffc7f4:	f993 100e 	ldrsb.w	r1, [r3, #14]
	if (b1 != b2) {
1fffc7f8:	428a      	cmp	r2, r1
1fffc7fa:	d0f3      	beq.n	1fffc7e4 <add_to_waitq_locked+0x28>
		if (z_sched_prio_cmp(thread, t) > 0) {
1fffc7fc:	4291      	cmp	r1, r2
1fffc7fe:	ddf1      	ble.n	1fffc7e4 <add_to_waitq_locked+0x28>
	sys_dnode_t *const prev = successor->prev;
1fffc800:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
1fffc802:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
1fffc806:	6014      	str	r4, [r2, #0]
	successor->prev = node;
1fffc808:	605c      	str	r4, [r3, #4]
}
1fffc80a:	bd38      	pop	{r3, r4, r5, pc}

1fffc80c <z_ready_thread>:
{
1fffc80c:	b510      	push	{r4, lr}
1fffc80e:	f04f 0310 	mov.w	r3, #16
1fffc812:	f3ef 8411 	mrs	r4, BASEPRI
1fffc816:	f383 8812 	msr	BASEPRI_MAX, r3
1fffc81a:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
1fffc81e:	f7fe f827 	bl	1fffa870 <ready_thread>
	__asm__ volatile(
1fffc822:	f384 8811 	msr	BASEPRI, r4
1fffc826:	f3bf 8f6f 	isb	sy
}
1fffc82a:	bd10      	pop	{r4, pc}

1fffc82c <z_sched_wake_thread>:
{
1fffc82c:	b538      	push	{r3, r4, r5, lr}
1fffc82e:	4604      	mov	r4, r0
	__asm__ volatile(
1fffc830:	f04f 0310 	mov.w	r3, #16
1fffc834:	f3ef 8511 	mrs	r5, BASEPRI
1fffc838:	f383 8812 	msr	BASEPRI_MAX, r3
1fffc83c:	f3bf 8f6f 	isb	sy
		if (!killed) {
1fffc840:	7b43      	ldrb	r3, [r0, #13]
1fffc842:	f013 0f28 	tst.w	r3, #40	; 0x28
1fffc846:	d10b      	bne.n	1fffc860 <z_sched_wake_thread+0x34>
			if (thread->base.pended_on != NULL) {
1fffc848:	6883      	ldr	r3, [r0, #8]
1fffc84a:	b10b      	cbz	r3, 1fffc850 <z_sched_wake_thread+0x24>
				unpend_thread_no_timeout(thread);
1fffc84c:	f7ff ffac 	bl	1fffc7a8 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_PRESTART;
1fffc850:	7b63      	ldrb	r3, [r4, #13]
			if (is_timeout) {
1fffc852:	b951      	cbnz	r1, 1fffc86a <z_sched_wake_thread+0x3e>
1fffc854:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
1fffc858:	7363      	strb	r3, [r4, #13]
			ready_thread(thread);
1fffc85a:	4620      	mov	r0, r4
1fffc85c:	f7fe f808 	bl	1fffa870 <ready_thread>
	__asm__ volatile(
1fffc860:	f385 8811 	msr	BASEPRI, r5
1fffc864:	f3bf 8f6f 	isb	sy
}
1fffc868:	bd38      	pop	{r3, r4, r5, pc}
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
1fffc86a:	f003 03eb 	and.w	r3, r3, #235	; 0xeb
}
1fffc86e:	e7f3      	b.n	1fffc858 <z_sched_wake_thread+0x2c>

1fffc870 <z_thread_timeout>:
	z_sched_wake_thread(thread, true);
1fffc870:	2101      	movs	r1, #1
1fffc872:	3818      	subs	r0, #24
1fffc874:	f7ff bfda 	b.w	1fffc82c <z_sched_wake_thread>

1fffc878 <z_unpend_first_thread>:
{
1fffc878:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
1fffc87a:	f04f 0310 	mov.w	r3, #16
1fffc87e:	f3ef 8511 	mrs	r5, BASEPRI
1fffc882:	f383 8812 	msr	BASEPRI_MAX, r3
1fffc886:	f3bf 8f6f 	isb	sy
	return list->head == list;
1fffc88a:	6804      	ldr	r4, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fffc88c:	42a0      	cmp	r0, r4
1fffc88e:	d00d      	beq.n	1fffc8ac <z_unpend_first_thread+0x34>
		if (thread != NULL) {
1fffc890:	b134      	cbz	r4, 1fffc8a0 <z_unpend_first_thread+0x28>
			unpend_thread_no_timeout(thread);
1fffc892:	4620      	mov	r0, r4
1fffc894:	f7ff ff88 	bl	1fffc7a8 <unpend_thread_no_timeout>
1fffc898:	f104 0018 	add.w	r0, r4, #24
1fffc89c:	f000 f846 	bl	1fffc92c <z_abort_timeout>
	__asm__ volatile(
1fffc8a0:	f385 8811 	msr	BASEPRI, r5
1fffc8a4:	f3bf 8f6f 	isb	sy
}
1fffc8a8:	4620      	mov	r0, r4
1fffc8aa:	bd38      	pop	{r3, r4, r5, pc}
1fffc8ac:	2400      	movs	r4, #0
1fffc8ae:	e7f7      	b.n	1fffc8a0 <z_unpend_first_thread+0x28>

1fffc8b0 <z_unpend_thread>:
{
1fffc8b0:	b510      	push	{r4, lr}
1fffc8b2:	4601      	mov	r1, r0
	__asm__ volatile(
1fffc8b4:	f04f 0310 	mov.w	r3, #16
1fffc8b8:	f3ef 8411 	mrs	r4, BASEPRI
1fffc8bc:	f383 8812 	msr	BASEPRI_MAX, r3
1fffc8c0:	f3bf 8f6f 	isb	sy
		if (thread->base.pended_on != NULL) {
1fffc8c4:	6883      	ldr	r3, [r0, #8]
1fffc8c6:	b10b      	cbz	r3, 1fffc8cc <z_unpend_thread+0x1c>
			unpend_thread_no_timeout(thread);
1fffc8c8:	f7ff ff6e 	bl	1fffc7a8 <unpend_thread_no_timeout>
	__asm__ volatile(
1fffc8cc:	f384 8811 	msr	BASEPRI, r4
1fffc8d0:	f3bf 8f6f 	isb	sy
}
1fffc8d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
1fffc8d8:	f101 0018 	add.w	r0, r1, #24
1fffc8dc:	f000 b826 	b.w	1fffc92c <z_abort_timeout>

1fffc8e0 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
1fffc8e0:	4603      	mov	r3, r0
1fffc8e2:	b920      	cbnz	r0, 1fffc8ee <z_reschedule_irqlock+0xe>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
1fffc8e4:	f3ef 8205 	mrs	r2, IPSR
1fffc8e8:	b90a      	cbnz	r2, 1fffc8ee <z_reschedule_irqlock+0xe>
	ret = arch_swap(key);
1fffc8ea:	f7fc bd01 	b.w	1fff92f0 <arch_swap>
1fffc8ee:	f383 8811 	msr	BASEPRI, r3
1fffc8f2:	f3bf 8f6f 	isb	sy
}
1fffc8f6:	4770      	bx	lr

1fffc8f8 <z_reschedule_unlocked>:
	__asm__ volatile(
1fffc8f8:	f04f 0310 	mov.w	r3, #16
1fffc8fc:	f3ef 8011 	mrs	r0, BASEPRI
1fffc900:	f383 8812 	msr	BASEPRI_MAX, r3
1fffc904:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
1fffc908:	f7ff bfea 	b.w	1fffc8e0 <z_reschedule_irqlock>

1fffc90c <z_unpend_all>:
{
1fffc90c:	b538      	push	{r3, r4, r5, lr}
1fffc90e:	4605      	mov	r5, r0
	int need_sched = 0;
1fffc910:	2000      	movs	r0, #0
	return list->head == list;
1fffc912:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
1fffc914:	42a5      	cmp	r5, r4
1fffc916:	d000      	beq.n	1fffc91a <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
1fffc918:	b904      	cbnz	r4, 1fffc91c <z_unpend_all+0x10>
}
1fffc91a:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
1fffc91c:	4620      	mov	r0, r4
1fffc91e:	f7ff ffc7 	bl	1fffc8b0 <z_unpend_thread>
		z_ready_thread(thread);
1fffc922:	4620      	mov	r0, r4
1fffc924:	f7ff ff72 	bl	1fffc80c <z_ready_thread>
		need_sched = 1;
1fffc928:	2001      	movs	r0, #1
1fffc92a:	e7f2      	b.n	1fffc912 <z_unpend_all+0x6>

1fffc92c <z_abort_timeout>:
{
1fffc92c:	b510      	push	{r4, lr}
1fffc92e:	f04f 0210 	mov.w	r2, #16
1fffc932:	f3ef 8411 	mrs	r4, BASEPRI
1fffc936:	f382 8812 	msr	BASEPRI_MAX, r2
1fffc93a:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
1fffc93e:	6803      	ldr	r3, [r0, #0]
1fffc940:	b13b      	cbz	r3, 1fffc952 <z_abort_timeout+0x26>
			remove_timeout(to);
1fffc942:	f7fe fa4d 	bl	1fffade0 <remove_timeout>
			ret = 0;
1fffc946:	2000      	movs	r0, #0
	__asm__ volatile(
1fffc948:	f384 8811 	msr	BASEPRI, r4
1fffc94c:	f3bf 8f6f 	isb	sy
}
1fffc950:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
1fffc952:	f06f 0015 	mvn.w	r0, #21
1fffc956:	e7f7      	b.n	1fffc948 <z_abort_timeout+0x1c>

1fffc958 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
1fffc958:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
1fffc95a:	f7fe fb3d 	bl	1fffafd8 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
1fffc95e:	bd08      	pop	{r3, pc}

1fffc960 <sys_clock_timeout_end_calc>:
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
1fffc960:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
1fffc964:	bf08      	it	eq
1fffc966:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
1fffc96a:	b538      	push	{r3, r4, r5, lr}
1fffc96c:	460c      	mov	r4, r1
1fffc96e:	4605      	mov	r5, r0
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
1fffc970:	d014      	beq.n	1fffc99c <sys_clock_timeout_end_calc+0x3c>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
1fffc972:	4308      	orrs	r0, r1
1fffc974:	d103      	bne.n	1fffc97e <sys_clock_timeout_end_calc+0x1e>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
1fffc976:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return sys_clock_tick_get();
1fffc97a:	f7fe bb2d 	b.w	1fffafd8 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
1fffc97e:	f06f 0001 	mvn.w	r0, #1
1fffc982:	1b40      	subs	r0, r0, r5
1fffc984:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
1fffc988:	eb63 0101 	sbc.w	r1, r3, r1
1fffc98c:	2900      	cmp	r1, #0
1fffc98e:	da04      	bge.n	1fffc99a <sys_clock_timeout_end_calc+0x3a>
		return sys_clock_tick_get() + MAX(1, dt);
1fffc990:	f7fe fb22 	bl	1fffafd8 <sys_clock_tick_get>
1fffc994:	1940      	adds	r0, r0, r5
1fffc996:	eb41 0104 	adc.w	r1, r1, r4
}
1fffc99a:	bd38      	pop	{r3, r4, r5, pc}
		return UINT64_MAX;
1fffc99c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
1fffc9a0:	4601      	mov	r1, r0
1fffc9a2:	e7fa      	b.n	1fffc99a <sys_clock_timeout_end_calc+0x3a>

1fffc9a4 <z_heap_aligned_alloc>:
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
1fffc9a4:	3204      	adds	r2, #4
{
1fffc9a6:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
1fffc9a8:	4604      	mov	r4, r0
1fffc9aa:	d208      	bcs.n	1fffc9be <z_heap_aligned_alloc+0x1a>
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
1fffc9ac:	2600      	movs	r6, #0
1fffc9ae:	2700      	movs	r7, #0
1fffc9b0:	e9cd 6700 	strd	r6, r7, [sp]
1fffc9b4:	f041 0104 	orr.w	r1, r1, #4
1fffc9b8:	f000 f81a 	bl	1fffc9f0 <k_heap_aligned_alloc>
	if (mem == NULL) {
1fffc9bc:	b910      	cbnz	r0, 1fffc9c4 <z_heap_aligned_alloc+0x20>
		return NULL;
1fffc9be:	2000      	movs	r0, #0
}
1fffc9c0:	b002      	add	sp, #8
1fffc9c2:	bdd0      	pop	{r4, r6, r7, pc}
	*heap_ref = heap;
1fffc9c4:	f840 4b04 	str.w	r4, [r0], #4
	return mem;
1fffc9c8:	e7fa      	b.n	1fffc9c0 <z_heap_aligned_alloc+0x1c>

1fffc9ca <k_free>:
	if (ptr != NULL) {
1fffc9ca:	b120      	cbz	r0, 1fffc9d6 <k_free+0xc>
		k_heap_free(*heap_ref, ptr);
1fffc9cc:	1f01      	subs	r1, r0, #4
1fffc9ce:	f850 0c04 	ldr.w	r0, [r0, #-4]
1fffc9d2:	f000 b85a 	b.w	1fffca8a <k_heap_free>
}
1fffc9d6:	4770      	bx	lr

1fffc9d8 <k_malloc>:
{
1fffc9d8:	4601      	mov	r1, r0
	void *ret = k_aligned_alloc(sizeof(void *), size);
1fffc9da:	2004      	movs	r0, #4
1fffc9dc:	f7fe bb16 	b.w	1fffb00c <k_aligned_alloc>

1fffc9e0 <k_heap_init>:
{
1fffc9e0:	b410      	push	{r4}
	sys_dlist_init(&w->waitq);
1fffc9e2:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
1fffc9e6:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
1fffc9ea:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
1fffc9ec:	f7fe bcdc 	b.w	1fffb3a8 <sys_heap_init>

1fffc9f0 <k_heap_aligned_alloc>:
SYS_INIT_NAMED(statics_init_post, statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
1fffc9f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1fffc9f4:	b085      	sub	sp, #20
1fffc9f6:	e9dd a40e 	ldrd	sl, r4, [sp, #56]	; 0x38
1fffc9fa:	4607      	mov	r7, r0
1fffc9fc:	4688      	mov	r8, r1
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
1fffc9fe:	4650      	mov	r0, sl
1fffca00:	4621      	mov	r1, r4
{
1fffca02:	4691      	mov	r9, r2
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
1fffca04:	f7ff ffac 	bl	1fffc960 <sys_clock_timeout_end_calc>
	void *ret = NULL;

	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
1fffca08:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
1fffca0c:	bf08      	it	eq
1fffca0e:	f1ba 3fff 	cmpeq.w	sl, #4294967295	; 0xffffffff
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
1fffca12:	4605      	mov	r5, r0
1fffca14:	460e      	mov	r6, r1
	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
1fffca16:	bf04      	itt	eq
1fffca18:	f04f 35ff 	moveq.w	r5, #4294967295	; 0xffffffff
1fffca1c:	f06f 4600 	mvneq.w	r6, #2147483648	; 0x80000000

	k_spinlock_key_t key = k_spin_lock(&h->lock);
1fffca20:	f107 0a14 	add.w	sl, r7, #20
	__asm__ volatile(
1fffca24:	f04f 0310 	mov.w	r3, #16
1fffca28:	f3ef 8411 	mrs	r4, BASEPRI
1fffca2c:	f383 8812 	msr	BASEPRI_MAX, r3
1fffca30:	f3bf 8f6f 	isb	sy
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
1fffca34:	f107 0b0c 	add.w	fp, r7, #12
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
1fffca38:	464a      	mov	r2, r9
1fffca3a:	4641      	mov	r1, r8
1fffca3c:	4638      	mov	r0, r7
1fffca3e:	f7fe fc4c 	bl	1fffb2da <sys_heap_aligned_alloc>
1fffca42:	9003      	str	r0, [sp, #12]
		now = sys_clock_tick_get();
1fffca44:	f7fe fac8 	bl	1fffafd8 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
1fffca48:	9b03      	ldr	r3, [sp, #12]
1fffca4a:	b13b      	cbz	r3, 1fffca5c <k_heap_aligned_alloc+0x6c>
	__asm__ volatile(
1fffca4c:	f384 8811 	msr	BASEPRI, r4
1fffca50:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
1fffca54:	4618      	mov	r0, r3
1fffca56:	b005      	add	sp, #20
1fffca58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    (ret != NULL) || ((end - now) <= 0)) {
1fffca5c:	1a28      	subs	r0, r5, r0
1fffca5e:	eb66 0101 	sbc.w	r1, r6, r1
1fffca62:	2801      	cmp	r0, #1
1fffca64:	f171 0200 	sbcs.w	r2, r1, #0
1fffca68:	dbf0      	blt.n	1fffca4c <k_heap_aligned_alloc+0x5c>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
1fffca6a:	e9cd 0100 	strd	r0, r1, [sp]
1fffca6e:	465a      	mov	r2, fp
1fffca70:	4621      	mov	r1, r4
1fffca72:	4650      	mov	r0, sl
1fffca74:	f7fd ffb4 	bl	1fffa9e0 <z_pend_curr>
	__asm__ volatile(
1fffca78:	f04f 0310 	mov.w	r3, #16
1fffca7c:	f3ef 8411 	mrs	r4, BASEPRI
1fffca80:	f383 8812 	msr	BASEPRI_MAX, r3
1fffca84:	f3bf 8f6f 	isb	sy
	return k;
1fffca88:	e7d6      	b.n	1fffca38 <k_heap_aligned_alloc+0x48>

1fffca8a <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
1fffca8a:	b538      	push	{r3, r4, r5, lr}
1fffca8c:	4604      	mov	r4, r0
1fffca8e:	f04f 0310 	mov.w	r3, #16
1fffca92:	f3ef 8511 	mrs	r5, BASEPRI
1fffca96:	f383 8812 	msr	BASEPRI_MAX, r3
1fffca9a:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
1fffca9e:	f7fe fbe4 	bl	1fffb26a <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
1fffcaa2:	f104 000c 	add.w	r0, r4, #12
1fffcaa6:	f7ff ff31 	bl	1fffc90c <z_unpend_all>
1fffcaaa:	b130      	cbz	r0, 1fffcaba <k_heap_free+0x30>
		z_reschedule(&h->lock, key);
1fffcaac:	4629      	mov	r1, r5
1fffcaae:	f104 0014 	add.w	r0, r4, #20
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
1fffcab2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&h->lock, key);
1fffcab6:	f7fd bfb1 	b.w	1fffaa1c <z_reschedule>
	__asm__ volatile(
1fffcaba:	f385 8811 	msr	BASEPRI, r5
1fffcabe:	f3bf 8f6f 	isb	sy
}
1fffcac2:	bd38      	pop	{r3, r4, r5, pc}
